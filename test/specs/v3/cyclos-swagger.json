{
  "swagger" : "2.0",
  "info" : {
    "description" : "The REST API for Cyclos 4.7.3",
    "version" : "4.7.3",
    "title" : "Cyclos 4.7.3 API"
  },
  "host" : "localhost:8080",
  "basePath" : "/cyclos/N1/api",
  "tags" : [ {
    "name" : "Auth",
    "description" : "Operations regarding the user authentication, such as login / logout,\nactivating / deactivating an access client and obtaining the current\nauthenticated user information.\n"
  }, {
    "name" : "Captcha",
    "description" : "Generate new captcha challenges, which are required for some\noperations performed as guest, in order to make it harder for bots\nto abuse the api.  \n"
  }, {
    "name" : "Users",
    "description" : "User searching, registration and profile modification. Also provides\naccess to the user map directory.\n"
  }, {
    "name" : "Operators",
    "description" : "Operations over operators, which are users created by other users to\nmanage their data. \n"
  }, {
    "name" : "Phones",
    "description" : "Management of user phones, which is done separatedly from the raw user\nprofile fields.\n"
  }, {
    "name" : "Addresses",
    "description" : "Management of user addresses, which is done separatedly from the raw\nuser profile fields.\n"
  }, {
    "name" : "Images",
    "description" : "Provides access to images of all kinds, for getting metadata, content\nand management operations.\n"
  }, {
    "name" : "Passwords",
    "description" : "Management of an user's passwords.\n"
  }, {
    "name" : "Contacts",
    "description" : "Management of an user contact list.\n"
  }, {
    "name" : "Agreements",
    "description" : "Provides access to agreements the authenticated user must accept in\norder to use the system\n"
  }, {
    "name" : "Accounts",
    "description" : "Provides access to account information, such as the status (balance,\ncredit limit and so on) and account history (list of balance transfers\nbetween accounts).\n"
  }, {
    "name" : "Transfers",
    "description" : "Provides access to balance transfers (also called transfers).\nA transfer represents the actual and definitive transfer of funds\nbetween two accounts.\n"
  }, {
    "name" : "Transactions",
    "description" : "Provides access to transactions.  A transaction is an intent to transfer balance between accounts. A transaction will generate zero or more balance transfers between accounts. For example, a direct payment beween 2 users can initially be pending administration authorization. Until it is authorized, no transfer will be generated. Once authorized, a transfer will be created. Another kind of transaction, a scheduled payment, will generate one transfer per processed installment. The kinds of transactions are: - **Direct payment**: A simple payment from / to an user or system\n  account. Depending on the configuration, can require authorization\n  to be processed. \n- **Scheduled payment**: A payment processed either on a single future\n  date or in several installments. Depending on the configuration, can\n  require authorization to be processed.\n- **Recurring payment**: A payment which is repeated for a fixed number\n  of occurrences or until manually canceled. Depending on the\n  configuration, can require authorization to be processed.\n- **Chargeback**: A chargeback triggers a transfer with the same origin\n  and destination as an original transfer, but with negative amount,\n  effectively returning the balance to the original account.\n- **Payment request**: A payment filled-in by the payee. Once the payer\n  accepts the payment, either a direct or scheduled payment is created\n  (which could, depending on the configuration, be pending\n  authorization).\n- **External payment**: A payment to an user not yet registered on the\n  system. The payment amount is reserved to either an e-mail address or\n  mobile phone number. Once an user registers using either data, the\n  payment.  \n- **Import**: A transaction was imported from file. \n"
  }, {
    "name" : "Payments",
    "description" : "Provides access for performing payments or scheduled payments.\n"
  }, {
    "name" : "POS",
    "description" : "Provides access for receiving payments or scheduled payments in\nPoint-Of-Sale (POS) operations.\n"
  }, {
    "name" : "Clients",
    "description" : "Access clients provide a token for user authentication without\ndecoupled from the login name and password. \n"
  }, {
    "name" : "Vouchers",
    "description" : "Vouchers provide tickets which can be used by (possibly external) users\nto buy at places that accept payments in Cyclos. \n"
  }, {
    "name" : "Mobile",
    "description" : "Contains operations used by the Cyclos mobile application, but can also\nbe useful for third-party mobile applications.\n"
  }, {
    "name" : "Records",
    "description" : "Provices access to custom records\n"
  }, {
    "name" : "Operations",
    "description" : "Provices access to custom operations\n"
  }, {
    "name" : "Marketplace",
    "description" : "Provices access to the marketplace, that is, searching or managing advertisements. Currently both `simple` and `webshop` are support for searching, but only simple advertisements can be managed via this API.\n"
  }, {
    "name" : "NFC",
    "description" : "Contains operations regarding NFC tags\n"
  } ],
  "produces" : [ "application/json" ],
  "paths" : {
    "/accounts/data-for-user-balances" : {
      "get" : {
        "tags" : [ "Accounts" ],
        "summary" : "Returns data for searching users together with their balances",
        "description" : "Returns configuration data for searching users together with their\nbalances. The account types are returned, and the account type needs\nto be passed in the other `user-balances` operations.\n",
        "operationId" : "getUserBalancesData",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for searching users with balances",
            "schema" : {
              "$ref" : "#/definitions/DataForUserBalancesSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/accounts/{accountType}/user-balances" : {
      "get" : {
        "tags" : [ "Accounts" ],
        "summary" : "Searches for users together with balance information",
        "description" : "Returns the users, together with their balances\n",
        "operationId" : "searchUsersWithBalances",
        "parameters" : [ {
          "name" : "accountType",
          "in" : "path",
          "description" : "The account type",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "usersToExclude",
          "in" : "query",
          "description" : "Indicated the users to be excluded from the result\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "usersToInclude",
          "in" : "query",
          "description" : "Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "activationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user activation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user creation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "lastLoginPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user last login date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Either id or internal names of groups / group sets",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "brokers",
          "in" : "query",
          "description" : "Either id or a principal (login name, e-mail, etc) for brokers",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "mainBrokerOnly",
          "in" : "query",
          "description" : "When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "latitude",
          "in" : "query",
          "description" : "The reference latitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "longitude",
          "in" : "query",
          "description" : "The reference longitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "maxDistance",
          "in" : "query",
          "description" : "Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position.\n",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "addressResult",
          "in" : "query",
          "description" : "Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * none: Addresses are not returned. * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * primary: The primary (default) address is returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "none", "all", "nearest", "primary" ],
          "x-type" : "AddressInSearchResultEnum"
        }, {
          "name" : "includeGroup",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user groups, will return the `group` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "includeGroupSet",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "balanceRange",
          "in" : "query",
          "description" : "The minimum and / or maximum balance for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bould as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "integer"
          }
        }, {
          "name" : "lastIncomingTransferPeriod",
          "in" : "query",
          "description" : "The minimum / maximum date of the last incoming transfer for users to be returned.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "lastOutgoingTransferPeriod",
          "in" : "query",
          "description" : "The minimum / maximum date of the last outgoing transfer for users to be returned.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "negativeSincePeriod",
          "in" : "query",
          "description" : "The minimum / maximum negative-since date for users to be returned.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "mediumBalanceRange",
          "in" : "query",
          "description" : "An array with 2 elements, describing the lower and upper medium balance bounds. If not specified, the range defined in the account type will be used. If that one is also not defined, there will be no definitions for balance levels. Both bounds need to be set as 2 element in the array, or it won't be considered.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "integer"
          }
        }, {
          "name" : "orderBy",
          "in" : "query",
          "description" : "Contains the possible 'order by' values when searching for users with balances  Possible values are: * balanceAsc: User are ordered by balance, lower balances first. * balanceDesc: User are ordered by balance, higher balances first. * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "balanceAsc", "balanceDesc", "alphabeticallyAsc", "alphabeticallyDesc" ],
          "x-type" : "UserBalancesOrderByEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The users together with their balances",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/UserWithBalanceResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/accounts/{accountType}/user-balances/summary" : {
      "get" : {
        "tags" : [ "Accounts" ],
        "summary" : "Returns summarized information for the user balances search",
        "description" : "Returns summaries for each balance level (if ranges are defined in either\naccount type or filter), as well as the total summary.\n",
        "operationId" : "getUserBalancesSummary",
        "parameters" : [ {
          "name" : "accountType",
          "in" : "path",
          "description" : "The account type",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "usersToExclude",
          "in" : "query",
          "description" : "Indicated the users to be excluded from the result\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "usersToInclude",
          "in" : "query",
          "description" : "Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "activationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user activation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user creation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "lastLoginPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user last login date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Either id or internal names of groups / group sets",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "brokers",
          "in" : "query",
          "description" : "Either id or a principal (login name, e-mail, etc) for brokers",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "mainBrokerOnly",
          "in" : "query",
          "description" : "When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "latitude",
          "in" : "query",
          "description" : "The reference latitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "longitude",
          "in" : "query",
          "description" : "The reference longitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "maxDistance",
          "in" : "query",
          "description" : "Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position.\n",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "addressResult",
          "in" : "query",
          "description" : "Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * none: Addresses are not returned. * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * primary: The primary (default) address is returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "none", "all", "nearest", "primary" ],
          "x-type" : "AddressInSearchResultEnum"
        }, {
          "name" : "includeGroup",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user groups, will return the `group` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "includeGroupSet",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "balanceRange",
          "in" : "query",
          "description" : "The minimum and / or maximum balance for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bould as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "integer"
          }
        }, {
          "name" : "lastIncomingTransferPeriod",
          "in" : "query",
          "description" : "The minimum / maximum date of the last incoming transfer for users to be returned.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "lastOutgoingTransferPeriod",
          "in" : "query",
          "description" : "The minimum / maximum date of the last outgoing transfer for users to be returned.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "negativeSincePeriod",
          "in" : "query",
          "description" : "The minimum / maximum negative-since date for users to be returned.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "mediumBalanceRange",
          "in" : "query",
          "description" : "An array with 2 elements, describing the lower and upper medium balance bounds. If not specified, the range defined in the account type will be used. If that one is also not defined, there will be no definitions for balance levels. Both bounds need to be set as 2 element in the array, or it won't be considered.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "integer"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The summary of user balances matching the parameters",
            "schema" : {
              "$ref" : "#/definitions/UserBalancesSummary"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/addresses/countries" : {
      "get" : {
        "tags" : [ "Addresses" ],
        "summary" : "Lists all known countries with the ISO code and display name",
        "description" : "The country code is the 2-letter, `ISO 3166-1 alpha-2` code, and the\ndisplay name is returned in the authenticated user's language \n",
        "operationId" : "listCountries",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The list of countries\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Country"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/addresses/{id}" : {
      "get" : {
        "tags" : [ "Addresses" ],
        "summary" : "Returns details of a specific address",
        "description" : "Returns information about an address, located by id",
        "operationId" : "viewAddress",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The address data",
            "schema" : {
              "$ref" : "#/definitions/AddressView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "put" : {
        "tags" : [ "Addresses" ],
        "summary" : "Updates an existing address",
        "description" : "Updates an existing address",
        "operationId" : "updateAddress",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "address",
          "description" : "The address to be edited",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/AddressEdit"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The address was updated"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "delete" : {
        "tags" : [ "Addresses" ],
        "summary" : "Removes an address",
        "description" : "Removes an address",
        "operationId" : "deleteAddress",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The address was deleted"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/addresses/{id}/data-for-edit" : {
      "get" : {
        "tags" : [ "Addresses" ],
        "summary" : "Returns data to edit a new address",
        "description" : "Returns configuration data for editing an address, plus the current\nAddressEdit object that can be altered and sent back\n",
        "operationId" : "getAddressDataForEdit",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for editing an address",
            "schema" : {
              "$ref" : "#/definitions/AddressDataForEdit"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/agreements/accept" : {
      "post" : {
        "tags" : [ "Agreements" ],
        "summary" : "Accept one or more agreements",
        "description" : "Accept all the given agreements \n",
        "operationId" : "acceptPendingAgreement",
        "parameters" : [ {
          "name" : "agreements",
          "in" : "query",
          "description" : "The identifiers or internal names of the agreements to be accepted\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The agreements were accepted"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/agreements/pending" : {
      "get" : {
        "tags" : [ "Agreements" ],
        "summary" : "Returns the agreements the authenticated user needs to accept in\norder to use the system\n",
        "description" : "Returns a list with all agreements the authenticated user is pending\nto accept. Until accepting the pending agreements, the usage of the\nsystem is limited. \n",
        "operationId" : "listPendingAgreements",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of agreements, or empty if there are no pending agreements\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Agreement"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth" : {
      "get" : {
        "tags" : [ "Auth" ],
        "summary" : "Returns data about the currently authenticated user",
        "description" : "Returns the logged user information.\n",
        "operationId" : "getCurrentAuth",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "An object containing the authenticated user information\n",
            "schema" : {
              "$ref" : "#/definitions/Auth"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth/access-client" : {
      "delete" : {
        "tags" : [ "Auth" ],
        "summary" : "Disconnect the current access client",
        "description" : "Changes the status of the access client used for authentication,\ndisconnecting it. To be reused, it has to be activated again.\n",
        "operationId" : "disconnectCurrentClient",
        "parameters" : [ {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The access client was disconnected"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth/data-for-login" : {
      "get" : {
        "tags" : [ "Auth" ],
        "summary" : "Returns data containing the configuration for logging-in",
        "description" : "Contains data useful for login, such as the allowed user identification\nmethods, the password type and data for the forgot password request.\n",
        "operationId" : "getDataForLogin",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "Data for the login functionality",
            "schema" : {
              "$ref" : "#/definitions/DataForLogin"
            }
          },
          "204" : {
            "description" : "If there is an authenticated user already"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth/forgotten-password" : {
      "post" : {
        "tags" : [ "Auth" ],
        "summary" : "Changes the a forgotten password after have completed the request\n",
        "description" : "Changes the password (if manual), or sends a new one by e-mail (if generated) after the forgotten password reset process is completed. \n",
        "operationId" : "changeForgottenPassword",
        "parameters" : [ {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters for changing the password",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ChangeForgottenPassword"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The password is changed (if manual) or reset and sent by e-mail (if\ngenerated) and nothing is returned.\n"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth/forgotten-password/data-for-change" : {
      "get" : {
        "tags" : [ "Auth" ],
        "summary" : "Returns configuration data used to change a forgotten password after\nthe initial request\n",
        "description" : "After the user has requested a forgotten password reset, using the `POST /auth/forgotten-password/request` path, the link on the received e-mail will contain a key which can be used to actually change the password. This key must be passed to this operation in order to request input on the new password, and maybe confirm the security question, depending on the Cyclos configuration. \n",
        "operationId" : "getDataForChangeForgottenPassword",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "key",
          "in" : "query",
          "description" : "The validation key which was sent by e-mail to the user",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for proceeding with the forgot password reset\n",
            "schema" : {
              "$ref" : "#/definitions/DataForChangeForgottenPassword"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth/forgotten-password/request" : {
      "post" : {
        "tags" : [ "Auth" ],
        "summary" : "Requests a forgotten password, notifying the user with instructions\nto reset it\n",
        "description" : "Sends an e-mail (in the future SMS will be supported) with instructions on how to reset the password, in case it was forgotten. In order to work, the Cyclos configuration options, both to show the forgotten password link and to enable for users need to be set.\n",
        "operationId" : "forgottenPasswordRequest",
        "parameters" : [ {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters for requesting a forgotten password reset",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/ForgottenPasswordRequest"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The password e-mail is sent and nothing is returned\n"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth/otp" : {
      "post" : {
        "tags" : [ "Auth" ],
        "summary" : "Generates a new One-Time-Password (OTP) for the authenticated user",
        "description" : "Sends a new OTP for the authenticated user. Used when the confirmation password of a specific action. Used when `PasswordInput.mode` is `otp`. \n",
        "operationId" : "newOtp",
        "parameters" : [ {
          "name" : "medium",
          "in" : "query",
          "description" : "The medium the user wants to receive the OTP Possible values are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)\n",
          "required" : true,
          "type" : "string",
          "enum" : [ "email", "sms" ],
          "x-type" : "SendMediumEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The OTP is sent to the user, and the e-mail or list of normalized\nmobile phone numbers that received the OTP are returned.\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "There was an error when generating the OTP",
            "schema" : {
              "$ref" : "#/definitions/OtpError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/auth/session" : {
      "post" : {
        "tags" : [ "Auth" ],
        "summary" : "Logs-in the currently authenticated user",
        "description" : "Logs-in the currently authenticated user, returning the session token.\nThis token can then be used on subsequent requests. After finishing\nthe session, the user can then logout by sending an HTTP DELETE to /auth.\n",
        "operationId" : "login",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "Information about the authenticated user. Is the same data returned\non GET /auth\n",
            "schema" : {
              "$ref" : "#/definitions/Auth"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "delete" : {
        "tags" : [ "Auth" ],
        "summary" : "Log-out the current session",
        "description" : "Invalidates the session used for authentication",
        "operationId" : "logout",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The session was invalidated"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "session" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/captcha" : {
      "post" : {
        "tags" : [ "Captcha" ],
        "summary" : "Returns a new captcha challenge",
        "description" : "Only allowed when internal captchas are in use. \n",
        "operationId" : "newCaptcha",
        "produces" : [ "application/json", "text/plain" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "query",
          "description" : "On public / user registration, it is possible to specify a\ndestination group, so the captcha background image will be taken\nfrom this new group's configured theme.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "201" : {
            "description" : "A new captcha challenge has been created. The captcha id is\nreturned on the body\n",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for the image to get the captcha challenge"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/captcha/{id}" : {
      "get" : {
        "tags" : [ "Captcha" ],
        "summary" : "Returns a captcha image content",
        "description" : "Returns the image content of a captcha text. When neither `width` nor `height` are specified, returns the original size. The original ratio is always maintained. When only of one of  the dimensions is specified, it is used as maximum, and the other is calculated. When both are informed, the maximum size with the original ratio that fits both dimensions is used. \n",
        "operationId" : "getCaptchaContent",
        "produces" : [ "application/json", "image/jpeg", "image/gif", "image/png" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "group",
          "in" : "query",
          "description" : "On public / user registration, it is possible to specify a\ndestination group, so the captcha background image will be taken\nfrom this new group's configured theme.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "width",
          "in" : "query",
          "description" : "The requested image width",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "height",
          "in" : "query",
          "description" : "The requested file height",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "The image content"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/clients/activate" : {
      "post" : {
        "tags" : [ "Clients" ],
        "summary" : "Activates an access client",
        "description" : "Activates an access client belonging to the currently authenticated user.\n",
        "operationId" : "activateClient",
        "parameters" : [ {
          "name" : "code",
          "in" : "query",
          "description" : "The activation code. Must match the activation code obtained in\nCyclos, which belongs to the authenticated user.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "prefix",
          "in" : "query",
          "description" : "A prefix to be added to the generated access client token. Can be\nused to increase the size of the generated token, and to increase\nthe security on clients that have to store the token. This can be\naccomplished by using some sort of client application hash or\nidentifier, which should be stable. The prefix is not returned by\nthis method. When later passing in the full token, the prefix should\nprepend the returned token without any separator.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Returns the token to be used on subsequent requests\n",
            "schema" : {
              "$ref" : "#/definitions/ActivateClientResult"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/clients/{key}" : {
      "get" : {
        "tags" : [ "Clients" ],
        "summary" : "Returns details of an access client",
        "description" : "Returns the access client details, together with permissions\n",
        "operationId" : "viewClient",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "key",
          "in" : "path",
          "description" : "The access client id or token",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The access client details\n",
            "schema" : {
              "$ref" : "#/definitions/ClientView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/clients/{key}/unassign" : {
      "post" : {
        "tags" : [ "Clients" ],
        "summary" : "Unassign (disconnects) an access client",
        "description" : "Unassigns an access client by id or token. It must be currently assigned. After this call, the client can be assigned again if needed.\n",
        "operationId" : "unassignClient",
        "parameters" : [ {
          "name" : "key",
          "in" : "path",
          "description" : "The access client id or token",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "Nothing is returned, and the access client is unassigned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/general-records/record-types" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Lists the record types for general search",
        "description" : "Returns the record types the authenticated user can use to search records\nin general, that is, without being of a particular user, but any managed\nuser. \n",
        "operationId" : "listRecordTypesForGeneralSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of visible record types\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/RecordTypeWithMenu"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/general-records/{type}" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Searches for records of a specific type over any owner",
        "description" : "Returns records matching the search criteria, for a specific type. The custom fields returned on each record depend on the field configuration, which needs to be enabled to return on list. The profile fields available as search filters for records are assigned in the products (or admin group permissions).\n",
        "operationId" : "searchGeneralRecords",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the identifier or internal name of the record type",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "brokers",
          "in" : "query",
          "description" : "Either the ids or identification methods of record owners' brokers\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Either the ids or internal names of record owners' groups\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum record creation date\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for searching records\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/RecordWithOwnerResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/general-records/{type}/data-for-search" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Returns data for searching records of a type over any owner",
        "description" : "Returns data for searching records of a specific type over any owner. Is not tied to a particular owner (user or system), hence, is considered a general search. \n",
        "operationId" : "getRecordDataForGeneralSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the identifier or internal name of the record type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for searching records of this type\n",
            "schema" : {
              "$ref" : "#/definitions/RecordDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/images/temp" : {
      "get" : {
        "tags" : [ "Images" ],
        "summary" : "Lists temporary images related to the currently authenticated user or guest\n",
        "description" : "Returns all uploaded temporary images by the current user, or guest,\nmatching by IP address. Cyclos may be configured to allow sessions from\nany IP address. In this case it might be possible that images uploaded\nas guest by the same client are not returned.\n",
        "operationId" : "listTempImages",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of images\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Image"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Images" ],
        "summary" : "Adds a new temporary image for the currently authenticated user or guest.\n",
        "description" : "Uploads a new temporary image. Those images can later be related to a new user registration or advertisement, so they will have images the beginning. Temporary images won't be immediately associated to the next registered entity, but each id must be explicitly associated on the `images` field.\nImages as guest can only be uploaded if on the destination group products the image profile field is allowed at registrations. Users may upload images if they can register new users or create advertisements.\n",
        "operationId" : "uploadTempImage",
        "produces" : [ "application/json", "text/plain" ],
        "consumes" : ["multipart/form-data"],
        "parameters" : [ {
          "name" : "name",
          "in" : "query",
          "description" : "The name for the new image. If not informed will fall back to the\noriginal file name in the form data\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "image",
          "in" : "formData",
          "description" : "The image being uploaded",
          "required" : true,
          "type" : "file"
        } ],
        "responses" : {
          "201" : {
            "description" : "The image is saved, its id is returned in the body and the URL to get the content is returned in the `Location` header\n",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for obtaining the image content"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/x-www-form-urlencoded"
      }
    },
    "/images/{id}" : {
      "get" : {
        "tags" : [ "Images" ],
        "summary" : "Returns an image details by id",
        "description" : "Returns metadata about an image given its id",
        "operationId" : "viewImage",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The image details",
            "schema" : {
              "$ref" : "#/definitions/ImageView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "delete" : {
        "tags" : [ "Images" ],
        "summary" : "Removes an image by id",
        "description" : "Removes the image with the given internal id. Any image kind can be removed using this operation, but the authenticated user needs the appropriate permission to do so. \n",
        "operationId" : "deleteImage",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The image was deleted"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/images/{kind}/{file}" : {
      "get" : {
        "tags" : [ "Images" ],
        "summary" : "Returns an image content",
        "description" : "Returns the content of an image, given the image kind and key. When neither `width` nor `height` are specified, returns the original content. The original ratio is always maintained. When only of one of  the dimensions is specified, it is used as maximum, and the other is calculated. When both are informed, the maximum size with the original ratio that fits both dimensions is used. \n",
        "operationId" : "getImageContent",
        "produces" : [ "application/json", "image/jpeg", "image/gif", "image/png" ],
        "parameters" : [ {
          "name" : "kind",
          "in" : "path",
          "description" : "Determines the kind of an image Possible values are: * profile: User profile images are those associated with the user profile. The first profile image is used to depict the user on search results. * userCustom: User custom images are additional images that can be used on rich text contents. * systemCustom: System custom images are additional images an administrator that can be used on rich text contents. * ad: Advertisement images are associated with an advertisement, be it simple or for web shop. * temp: A temporary image which can upload for later associating with an entity being registered (for example, user or advertisement).\n",
          "required" : true,
          "type" : "string",
          "enum" : [ "profile", "userCustom", "systemCustom", "ad", "temp" ],
          "x-type" : "ImageKind"
        }, {
          "name" : "file",
          "in" : "path",
          "description" : "The file name. This is not the original uploaded file name,\nbut a generated one.\n",
          "required" : true,
          "type" : "string",
          "x-dotInPath" : true
        }, {
          "name" : "width",
          "in" : "query",
          "description" : "The requested image width",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "height",
          "in" : "query",
          "description" : "The requested file height",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "The image content"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/marketplace" : {
      "get" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Search for advertisements",
        "description" : "Returns a page of advertisements that match a given criteria\n",
        "operationId" : "searchAds",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "category",
          "in" : "query",
          "description" : "Either id or internal name of a category",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "currency",
          "in" : "query",
          "description" : "Either id or internal name of a currency for the price",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "priceRange",
          "in" : "query",
          "description" : "The minumum / maximum price.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "number"
          }
        }, {
          "name" : "hasImages",
          "in" : "query",
          "description" : "When set to `true` only advertisements with images are returned\n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "publicationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum publication date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "expirationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum expiration date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "simple", "webshop" ],
          "x-type" : "AdKind"
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "The possible status for an advertisement Possible values for each array element are: * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * active: The advertisement is published and can be seen by other users. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "draft", "pending", "active", "scheduled", "expired", "hidden", "disabled" ]
          },
          "x-type" : "List<AdStatusEnum>"
        }, {
          "name" : "orderBy",
          "in" : "query",
          "description" : "Indicates how advertisements results are ordered. Possible values are: * relevance: This is the default if keywords are used. Best matching advertisements come first. * date: Newest advertisements are returned first. * priceAsc: Smaller prices are returned first. Advertisements without price are returned last. * priceDesc: Higher prices are returned first. Advertisements without price are returned last. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Without definite order\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "relevance", "date", "priceAsc", "priceDesc", "distance", "random" ],
          "x-type" : "AdOrderByEnum"
        }, {
          "name" : "latitude",
          "in" : "query",
          "description" : "The reference latitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "longitude",
          "in" : "query",
          "description" : "The reference longitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "maxDistance",
          "in" : "query",
          "description" : "Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position.\n",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "addressResult",
          "in" : "query",
          "description" : "Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * none: Addresses are not returned. * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * primary: The primary (default) address is returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "none", "all", "nearest", "primary" ],
          "x-type" : "AddressInSearchResultEnum"
        }, {
          "name" : "owner",
          "in" : "query",
          "description" : "Either id or an identification, such as login name, e-mail, etc, for\nthe advertisement owner. The allowed identification methods are those\nthe authenticated user can use on keywords search.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "broker",
          "in" : "query",
          "description" : "Either id or an identification, such as login name, e-mail, etc, for\nthe broker of the advertisement owner. The allowed identification\nmethods are those the authenticated user can use on keywords search.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Array of either id or internal names of user groups the advertisement\nowner must belong to\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "returnEditable",
          "in" : "query",
          "description" : "Whether to return the editable property. Passing `true` will impact\nthe performance a bit, as for each returned advertisement some\nstatuses and permissions need to be checked. \n",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "The advertisements matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/AdResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/marketplace/data-for-search" : {
      "get" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Returns configuration data to search advertisements",
        "description" : "Returns data needed on for a general advertisements search \n",
        "operationId" : "getAdDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "Indicates the kind of advertisement that should be searched. When nothing is passed (default) all kinds will be searched. Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "simple", "webshop" ],
          "x-type" : "AdKind"
        }, {
          "name" : "brokered",
          "in" : "query",
          "description" : "If the authenticated is a broker, passing the `true` value will indicate the advertisements to be searched are from managed users of that broker. The default is `false`.\n",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for advertisements search",
            "schema" : {
              "$ref" : "#/definitions/AdDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/marketplace/{id}" : {
      "get" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Returns details of an advertisement",
        "description" : "Returns detailed information of a marketplace\n",
        "operationId" : "viewAd",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The advertisement details",
            "schema" : {
              "$ref" : "#/definitions/AdView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "put" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Updates an existing ad",
        "description" : "Updates an existing ad",
        "operationId" : "updateAd",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "ad",
          "description" : "The advertisement to be edited",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/AdEdit"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The advertisement was updated"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "delete" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Removes an advertisement",
        "description" : "Removes an advertisement",
        "operationId" : "deleteAd",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The advertisement was deleted"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/marketplace/{id}/data-for-edit" : {
      "get" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Returns data for editing an advertisement",
        "description" : "Returns configuration data which can be used to edit an advertisement\n",
        "operationId" : "getAdDataForEdit",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for editing an advertisement",
            "schema" : {
              "$ref" : "#/definitions/AdDataForEdit"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/marketplace/{id}/images" : {
      "get" : {
        "tags" : [ "Images" ],
        "summary" : "Lists the images of an advertisement\n",
        "description" : "Returns the images of an advertisement.\n",
        "operationId" : "listAdImages",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of images\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Image"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Images" ],
        "summary" : "Adds a new image for the given advertisement.\n",
        "description" : "Uploads a new image for the given advertisement.\n",
        "operationId" : "uploadAdImage",
        "produces" : [ "application/json", "text/plain" ],
        "consumes" : ["multipart/form-data"],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "The name for the new image. If not informed will fall back to the\noriginal file name in the form data\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "image",
          "in" : "formData",
          "description" : "The image being uploaded",
          "required" : true,
          "type" : "file"
        } ],
        "responses" : {
          "201" : {
            "description" : "The image is saved, its id is returned in the body and the URL to get the content is returned in the `Location` header\n",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for obtaining the image content"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/x-www-form-urlencoded"
      }
    },
    "/marketplace/{id}/images/list-data" : {
      "get" : {
        "tags" : [ "Images" ],
        "summary" : "Returns the images of an advertisement, plus additional permissions and data \n",
        "description" : "Returns the images of an advertisement. Additional data, such as the\nmaximum images and whether the images can be managed by the\nauthenticated user are also returned.\n",
        "operationId" : "getAdImagesListData",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The images and additional information\n",
            "schema" : {
              "$ref" : "#/definitions/ImagesListData"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/marketplace/{id}/images/order" : {
      "put" : {
        "tags" : [ "Images" ],
        "summary" : "Changes the order of the images of an advertisement \n",
        "description" : "The new order is defined by the list of ids, so that images appear in\nthe same order as the ids.\n",
        "operationId" : "reorderAdImages",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ids",
          "in" : "query",
          "description" : "The array of ids (comma-separated) reflecting the desired order",
          "required" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The image order is changed and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/mobile/data-for-guest" : {
      "get" : {
        "tags" : [ "Mobile" ],
        "summary" : "Returns data the mobile application uses while in guest mode",
        "description" : "The data returned can be controlled with a cache key. Each data type has a parameter, such as `headerIf`, which returns the data only if it has changed since the last request.\n",
        "operationId" : "dataForMobileGuest",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "cyclosVersion",
          "in" : "query",
          "description" : "The last known Cyclos version. Sometimes, data to be cached depends on the version of the Cyclos application, and this helps controlling such cases\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "headerIf",
          "in" : "query",
          "description" : "Controls the header cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "footerIf",
          "in" : "query",
          "description" : "Controls the footer cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "themeIf",
          "in" : "query",
          "description" : "Controls the theme cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "translationsIf",
          "in" : "query",
          "description" : "Controls the translations cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for the mobile guest page",
            "schema" : {
              "$ref" : "#/definitions/DataForMobileGuest"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/mobile/data-for-user" : {
      "get" : {
        "tags" : [ "Mobile" ],
        "summary" : "Returns data the mobile application uses in either user or POS mode\n",
        "description" : "The data returned can be controlled with a cache key. Each data type has a parameter, such as `helpIf`, which returns the data only if it has changed since the last request.\n",
        "operationId" : "dataForMobileUser",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "cyclosVersion",
          "in" : "query",
          "description" : "The last known Cyclos version. Sometimes, data to be cached depends on the version of the Cyclos application, and this helps controlling such cases\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "themeIf",
          "in" : "query",
          "description" : "Controls the theme cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "translationsIf",
          "in" : "query",
          "description" : "Controls the translations cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "mobileHelpIf",
          "in" : "query",
          "description" : "Controls the mobile help cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it. Only taken into account when not accessing as access client (not in POS mode).\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "posHelpIf",
          "in" : "query",
          "description" : "Controls the POS help cache. If is a boolean value (`true` or `false`) will forcibly return or skip the content. Otherwise, it should be a string in the form `id|version`. In this case, the content will be returned only when changed. When blank will always return it. Only taken into account when accessing as access client (POS mode).\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for the mobile user page",
            "schema" : {
              "$ref" : "#/definitions/DataForMobileUser"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/mobile/page/{id}" : {
      "get" : {
        "tags" : [ "Mobile" ],
        "summary" : "Returns the content of a mobile page\n",
        "description" : "Returns the content of a mobile page, either by id or internal name\n",
        "operationId" : "mobilePageContent",
        "produces" : [ "application/json", "text/html" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The mobile page id",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The page content",
            "schema" : {
              "type" : "string"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/cancel" : {
      "post" : {
        "tags" : [ "NFC" ],
        "summary" : "Cancels a NFC tag",
        "description" : "Cancels a NFC token. Must be authenticated as a manager (administrator / broker) of the token owner, and have the correct permission. \n",
        "operationId" : "cancelNfc",
        "parameters" : [ {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters for canceling.\n",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/NfcTokenParameter"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The NFC tag is canceled and nothing is returned\n"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/data-for-initialize" : {
      "get" : {
        "tags" : [ "NFC" ],
        "summary" : "Returns data for NFC tag initialization. Optionally the user can personalize the tag too.",
        "description" : "Returns data with the NFC token types the authenticated user can use to initialize NFC tags.\n",
        "operationId" : "getNfcDataForInitialize",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for NFC tag initialization\n",
            "schema" : {
              "$ref" : "#/definitions/NfcDataForInitialize"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/data-for-personalize" : {
      "get" : {
        "tags" : [ "NFC" ],
        "summary" : "Returns data for perfornalizing an initialized NFC tag for an user",
        "description" : "Returns data for personalizing a NFC tag for a given user.\n",
        "operationId" : "getNfcDataForPersonalize",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "tokenType",
          "in" : "query",
          "description" : "The token type reference (id or internal name) of the token principal\ntype, which is stored on the NFC card being personalized. \n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "user",
          "in" : "query",
          "description" : "The user reference (id or an identification method) of the user\nto whom the NFC tag will be personalized.\nWhen authenticated as a manager of that user (administrator or\nbroker) no confirmation password will be required for the\npersonalization. However, if the authenticated user is not a manager,\nthe user will be required a confirmation password.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for NFC tag personalization\n",
            "schema" : {
              "$ref" : "#/definitions/NfcDataForPersonalize"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/external-auth" : {
      "post" : {
        "tags" : [ "NFC" ],
        "summary" : "NFC external authentication",
        "description" : "The NFC tag will normally perform a mutual authentication, by first generating a challenge that must be encrypted by the external system with the device key. With this the external system is authenticated. Cyclos also returns a challenge that should be encrypted by the NFC tag. This challenge can later be passed in specific operations (for example, when performing a payment) for Cyclos to make sure the NFC tag is present on the operation.\n",
        "operationId" : "nfcExternalAuth",
        "parameters" : [ {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters for the external authentication. If the `token` value is informed, it will be performed an external authentication with the token itself, using the Application Master Key (AMK). If the `token` is not informed, the authentication will be done using the PICC Master Key (PMK), which is useful, for example, when initializing the NFC tag. \n",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/NfcExternalAuthenticateParameter"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Returns the challenge to be encrypted by the NFC tag in a\nsubsequent operation\n",
            "schema" : {
              "$ref" : "#/definitions/NfcExternalAuthenticateResult"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "If a NFC external authentication error has occurred",
            "schema" : {
              "$ref" : "#/definitions/NfcAuthError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/initialize" : {
      "post" : {
        "tags" : [ "NFC" ],
        "summary" : "Initializes a NFC tag",
        "description" : "Initializes a NFC tag, creating a new `token` in Cyclos. Returns the keys (PICC Master Key, Application Master Key and the Operational Key) to be stored on the NFC tag.\n",
        "operationId" : "initializeNfc",
        "parameters" : [ {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters for initializing the NFC tag. If the `user` value is left blank, the NFC tag will be only initialized, but not personalized (assigned to any user). If an user is given, the permission to personalize is required (besides the permission to initialize), and is a shortcut to initializing and later personalizing the tag. The initialization is a sensitive operation, as the result contains the plain keys that should be stored on the NFC tag. Hence, can only be performed by managers (with granted permission). Later on, other users (for example, businesses) will be able to personalize the NFC tag for customers. \n",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/NfcInitializeParameter"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for NFC tag initialization\n",
            "schema" : {
              "$ref" : "#/definitions/NfcInitializeResult"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "If a NFC tag inititalization error has occurred",
            "schema" : {
              "$ref" : "#/definitions/InitializeNfcError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/personalize" : {
      "post" : {
        "tags" : [ "NFC" ],
        "summary" : "Personalizes a NFC tag",
        "description" : "Personalization requires a NFC tag that was previously initialized, but is still unassigned. This operation doesn't store any key in the NFC tag itself, hence the plain keys are not returned. What is needed is an external authentication with the NFC tag, in order to ensure the card is physically present. The flow for personalizing a tag is: - `GET /nfc/data-for-personalize?user={user}`: Obtain the data for\n  personalizing NFC tags for this user. The most important information\n  is which the confirmation password will be required, if any;\n- `POST /nfc/external-auth`: With a challenge previously encrypted by the\n  NFC tag, invoke this operation. If the challenge matches the NFC token\n  in Cyclos, it will be encrypted and returned. Also a new challenge will\n  be returned, which should be then encrypted by the NFC tag for later\n  being sent back;\n- `POST /nfc/personalize`: With the encrypted challenge and the\n  confirmation password (if any), this operation will update the NFC\n  token in Cyclos, so it is now assigned to the specified user. From\n  this point on, the NFC tag is operational.\n",
        "operationId" : "personalizeNfc",
        "parameters" : [ {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters for the initialization.\n",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/NfcPersonalizeParameter"
          }
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The NFC tag is personalized and nothing is returned\n"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "If a NFC tag personalization error has occurred",
            "schema" : {
              "$ref" : "#/definitions/PersonalizeNfcError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/personalize/otp" : {
      "post" : {
        "tags" : [ "NFC" ],
        "summary" : "Generates a new One-Time-Password (OTP) for a personalizing a NFC tag\n",
        "description" : "Sends a new OTP for the customer which will own the NFC tag. The OTP belongs to the NFC tag owner, not the authenticated user.\n",
        "operationId" : "getOtpForPersonalizeNfc",
        "parameters" : [ {
          "name" : "medium",
          "in" : "query",
          "description" : "The medium the user wants to receive the otp Possible values are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)\n",
          "required" : true,
          "type" : "string",
          "enum" : [ "email", "sms" ],
          "x-type" : "SendMediumEnum"
        }, {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters identifying the token and the user",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/NfcPersonalizeOtpParameter"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The OTP is sent to the user, and no content is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "There was an error when generating the OTP",
            "schema" : {
              "$ref" : "#/definitions/OtpError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/nfc/{tokenType}/{value}" : {
      "get" : {
        "tags" : [ "NFC" ],
        "summary" : "Retrieve the NFC token detailed data",
        "description" : "Returns the token's data and the user owner of the token (i.e the assigned user, if any)",
        "operationId" : "getNfcToken",
        "parameters" : [ {
          "name" : "tokenType",
          "in" : "path",
          "description" : "The internal name or id of the token type",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "value",
          "in" : "path",
          "description" : "The token value",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Returns the token data\n",
            "schema" : {
              "$ref" : "#/definitions/TokenDetailed"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/operators" : {
      "get" : {
        "tags" : [ "Operators" ],
        "summary" : "Search the visible operators (of any managed user)",
        "description" : "Returns a page of operators that match a given criteria\n",
        "operationId" : "searchGeneralOperators",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "userGroups",
          "in" : "query",
          "description" : "Either id or internal names of user groups / group sets",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "broker",
          "in" : "query",
          "description" : "Either id or a principal (login name, e-mail, etc) of the user broker",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user creation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * removed: The user was permanently removed. It's profile is kept for historical purposes. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "active", "blocked", "disabled", "removed", "pending" ]
          },
          "x-type" : "List<UserStatusEnum>"
        } ],
        "responses" : {
          "200" : {
            "description" : "The users matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/UserResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/operators/data-for-search" : {
      "get" : {
        "tags" : [ "Operators" ],
        "summary" : "Get configuration data for searching operators of any managed user",
        "description" : "Returns data with the current configuration regarding the search of\noperators of managed users. This is meant to be used by either\nadministrators or brokers \n",
        "operationId" : "getGeneralOperatorsDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for operators search",
            "schema" : {
              "$ref" : "#/definitions/GeneralOperatorsDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/passwords/{type}/generate" : {
      "post" : {
        "tags" : [ "Passwords" ],
        "summary" : "Generates the value of a generated password for the first time",
        "description" : "Generates the value of a password whose type's `mode` is  `generated`. Only the password owner can perform\n  this operation, and only in one of these conditions:\n  - If the password `status` is `neverCreated`\n    it can only be generated if the password doesn't require the\n    administrator authorization to generate. This can be configured in\n    the password type.\n  - The password can be generated if its `status` is one of the\n    following: `pending`, \n    `expired` or `reset`.\n",
        "operationId" : "generatePassword",
        "produces" : [ "application/json", "text/plain" ],
        "parameters" : [ {
          "name" : "type",
          "in" : "path",
          "description" : "Either the id or internal name of the password type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The plain value of the generated password. This is the only time\nthis plain value is ever returned.\n",
            "schema" : {
              "type" : "string"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/phones/{id}" : {
      "get" : {
        "tags" : [ "Phones" ],
        "summary" : "Returns details of a specific phone",
        "description" : "Returns information about a phone, located by id",
        "operationId" : "viewPhone",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The phone data",
            "schema" : {
              "$ref" : "#/definitions/PhoneView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "put" : {
        "tags" : [ "Phones" ],
        "summary" : "Updates an existing phone",
        "description" : "Updates an existing phone",
        "operationId" : "updatePhone",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "phone",
          "description" : "The phone to be edited",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PhoneEdit"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The phone was updated"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "delete" : {
        "tags" : [ "Phones" ],
        "summary" : "Removes a phone",
        "description" : "Removes a phone",
        "operationId" : "deletePhone",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The phone was deleted"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/phones/{id}/data-for-edit" : {
      "get" : {
        "tags" : [ "Phones" ],
        "summary" : "Returns data to edit a new phone",
        "description" : "Returns configuration data for editing a phone, plus the current `PhoneEdit` object that can be altered and sent back\n",
        "operationId" : "getPhoneDataForEdit",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for editing a phone",
            "schema" : {
              "$ref" : "#/definitions/PhoneDataForEdit"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/phones/{id}/disable-for-sms" : {
      "post" : {
        "tags" : [ "Phones" ],
        "summary" : "Marks a phone as disabled to receive SMS notifications and operate in\nthe SMS channel\n",
        "description" : "Marks a phone as disabled to receive SMS notifications and operate in.\nIf the confirmation password is enabled, it must be passed in.\nOnly allowed if is a verified mobile phone not already enabled for SMS. \nOnly the phone owner can verify phones with this method.\nAdministrators / brokers can directly mark a phone number as verified.\n",
        "operationId" : "disablePhoneForSms",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The phone is disabled for SMS and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/phones/{id}/enable-for-sms" : {
      "post" : {
        "tags" : [ "Phones" ],
        "summary" : "Marks a phone as enabled to receive SMS notifications and operate in\nthe SMS channel\n",
        "description" : "Marks a phone as enabled to receive SMS notifications and operate in.\nOnly allowed if is a verified mobile phone not already enabled for SMS. \nOnly the phone owner can verify phones with this method.\nAdministrators / brokers can directly mark a phone number as verified.\n",
        "operationId" : "enablePhoneForSms",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The phone is enabled for SMS and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/phones/{id}/send-verification-code" : {
      "post" : {
        "tags" : [ "Phones" ],
        "summary" : "Sends the verification code for an user to verify the mobile phone",
        "description" : "Sends an SMS text with a verification code the user can use to verify\nhis mobile phone. Only verified phones can be used for receiving SMS\nnotifications or to operate in the SMS operations channel. Only the\nphone owner can verify phones with this method. Administrators / brokers\ncan directly mark a phone number as verified.\n",
        "operationId" : "sendPhoneVerificationCode",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The phone number which received the SMS",
            "schema" : {
              "type" : "string"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/phones/{id}/verify" : {
      "post" : {
        "tags" : [ "Phones" ],
        "summary" : "Marks a phone as verified if the code matches",
        "description" : "Verifies a mobile phone by submitting the code received by SMS.\nOnly verified phones can be enabled for receiving SMS\nnotifications or to operate in the SMS operations channel. \nOnly the phone owner can verify phones with this method.\nAdministrators / brokers can directly mark a phone number as verified.\n",
        "operationId" : "verifyPhone",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "code",
          "in" : "query",
          "description" : "The verification code received by SMS",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The verification status",
            "schema" : {
              "$ref" : "#/definitions/CodeVerificationStatusEnum"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/pos" : {
      "post" : {
        "tags" : [ "POS" ],
        "summary" : "Receives a payment (POS)",
        "description" : "Receives either a direct or scheduled payment in a POS operation for the authenticated user. The payer user should be informed in the `subject` parameter. The payment id is returned on the response, and a link to the transaction details is returned on the `Location` header.\n",
        "operationId" : "receivePayment",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "payment",
          "description" : "The receive payment parameters",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PerformPayment"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "The created payment",
            "schema" : {
              "$ref" : "#/definitions/Transaction"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the transaction details"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "If a payment error has occurred",
            "schema" : {
              "$ref" : "#/definitions/PaymentError"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/pos/data-for-pos" : {
      "get" : {
        "tags" : [ "POS" ],
        "summary" : "Returns configuration data for receiving a payment (POS)",
        "description" : "Returns configuration data for receiving a payment in POS operation \n",
        "operationId" : "dataForReceivePayment",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "from",
          "in" : "query",
          "description" : "Identification of the payer user",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "query",
          "description" : "The payment type id or qualified internal name (in the form `fromAccountType.paymentType`). If no payment type is provided, the possible types will be returned, so the payer can choose.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for receiving a payment",
            "schema" : {
              "$ref" : "#/definitions/DataForTransaction"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "If a POS error has occurred",
            "schema" : {
              "$ref" : "#/definitions/PosError"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/pos/installments" : {
      "get" : {
        "tags" : [ "POS" ],
        "summary" : "Calculates the default installments for a scheduled payment",
        "description" : "Used to calculate installments for a scheduled payment. Will return an\ninstallment every month. When later receiving the payment, these can be\n(optionally) customized (such as changing some due dates or amounts) and\nused on the payment installments.   \n",
        "operationId" : "calculateReceivePaymentInstallments",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "from",
          "in" : "query",
          "description" : "The payment origin",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "count",
          "in" : "query",
          "description" : "The number of installments",
          "required" : true,
          "type" : "integer"
        }, {
          "name" : "amount",
          "in" : "query",
          "description" : "The total scheduled payment amount",
          "required" : true,
          "type" : "string",
          "format" : "number"
        }, {
          "name" : "currency",
          "in" : "query",
          "description" : "The payment currency. Used when no `type` is not provided, to narrow the possible payment types by currency.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "query",
          "description" : "The payment type id or qualified internal name (in the form  `fromAccountType.paymentType`). If not provided, will use the first possible type (possibly narrowed by the `currency` parameter). However, if more than one type is available, a validation error will be raised.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "firstDate",
          "in" : "query",
          "description" : "The due date of the first installment. If none is provided, it is\nassumed that the first installment is paid immediately, and others\nwill be with regular 1 month interval\n",
          "required" : false,
          "type" : "string",
          "format" : "date-time"
        } ],
        "responses" : {
          "200" : {
            "description" : "The calculated installments",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/PerformScheduledPaymentInstallment"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "If a POS error has occurred",
            "schema" : {
              "$ref" : "#/definitions/PosError"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/pos/otp" : {
      "post" : {
        "tags" : [ "POS" ],
        "summary" : "Generates a new One-Time-Password (OTP) for a pos payment",
        "description" : "Sends a new OTP for the customer of the POS for a payment. The OTP belongs to the payer, not the authenticated user. The entire payment object must be sent on the request body. This is the same object which is sent both either preview or actually receive the payment. \n",
        "operationId" : "receivePaymentOtp",
        "parameters" : [ {
          "name" : "medium",
          "in" : "query",
          "description" : "The medium the user wants to receive the otp Possible values are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)\n",
          "required" : true,
          "type" : "string",
          "enum" : [ "email", "sms" ],
          "x-type" : "SendMediumEnum"
        }, {
          "in" : "body",
          "name" : "payment",
          "description" : "The receive payment parameters",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PerformPayment"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The OTP is sent to the user, and no content is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "There was an error when generating the OTP",
            "schema" : {
              "$ref" : "#/definitions/OtpError"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/pos/preview" : {
      "post" : {
        "tags" : [ "POS" ],
        "summary" : "Previews a POS payment before receiving it",
        "description" : "Previews a payment or scheduled payment. The actual balance checking\nis not performed in the preview. \n",
        "operationId" : "previewReceivePayment",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "in" : "body",
          "name" : "payment",
          "description" : "The receive payment parameters",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PerformPayment"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The payment preview",
            "schema" : {
              "$ref" : "#/definitions/PaymentPreview"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "If a POS error has occurred",
            "schema" : {
              "$ref" : "#/definitions/PosError"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/records/{id}" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Returns details of a specific record",
        "description" : "Returns information about a record, located by id",
        "operationId" : "viewRecord",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The record data",
            "schema" : {
              "$ref" : "#/definitions/RecordView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "put" : {
        "tags" : [ "Records" ],
        "summary" : "Updates an existing record",
        "description" : "Updates an existing record",
        "operationId" : "updateRecord",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "record",
          "description" : "The record to be edited",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/RecordEdit"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The record was updated"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "delete" : {
        "tags" : [ "Records" ],
        "summary" : "Removes a record",
        "description" : "Removes a record",
        "operationId" : "deleteRecord",
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The record was deleted"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/records/{id}/data-for-edit" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Returns data to edit an existing record",
        "description" : "Returns configuration data for editing a record, plus the current `RecordEdit` object that can be altered and sent back\n",
        "operationId" : "getRecordDataForEdit",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "id",
          "in" : "path",
          "description" : "The object identification",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for editing a record",
            "schema" : {
              "$ref" : "#/definitions/RecordDataForEdit"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/shared-records" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Searches for records with shared fields",
        "description" : "Returns records matching the search criteria, using shared fields. This allows searching over multiple record types that use shared fields. The custom fields returned on each record depend on the field configuration, which needs to be enabled to return on list. The profile fields available as search filters for records are assigned in the products (or admin group permissions).\n",
        "operationId" : "searchSharedRecords",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "types",
          "in" : "query",
          "description" : "Either the ids or identification methods of record types\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "brokers",
          "in" : "query",
          "description" : "Either the ids or identification methods of record owners' brokers\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Either the ids or internal names of record owners' groups\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum record creation date\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for searching records\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/RecordWithOwnerResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/shared-records/data-for-search" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Returns data for searching records with shared fields",
        "description" : "Returns data for searching records from multiple types, using shared fields. Only user records can be shared this way. \n",
        "operationId" : "getRecordDataForSharedSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for searching records with shared fields\n",
            "schema" : {
              "$ref" : "#/definitions/RecordDataForSharedSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/transactions/{key}" : {
      "get" : {
        "tags" : [ "Transactions" ],
        "summary" : "Returns details about a transaction",
        "description" : "Returns details about a transaction.",
        "operationId" : "viewTransaction",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "key",
          "in" : "path",
          "description" : "Either the id or transaction number",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Transaction details",
            "schema" : {
              "$ref" : "#/definitions/TransactionView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/transfers" : {
      "get" : {
        "tags" : [ "Transfers" ],
        "summary" : "Searches for transfers over multiple accounts",
        "description" : "Searches for transfers over multiple accounts. This operation can\nonly be performed by administrators or brokers over managed users.\n",
        "operationId" : "searchTransfers",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "datePeriod",
          "in" : "query",
          "description" : "The minimum / maximum transfer date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "transferFilters",
          "in" : "query",
          "description" : "Reference to the transfer filters, which filters transfers by type.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "transactionNumber",
          "in" : "query",
          "description" : "The transaction number of the matching transfer\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "user",
          "in" : "query",
          "description" : "Reference an user that should have either received / performed the\ntransfer.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Reference to the user group used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "by",
          "in" : "query",
          "description" : "Reference to the user that was authenticated when the transfer was\nperformed. Is only taken into account if authenticated as\nadministrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "broker",
          "in" : "query",
          "description" : "Reference to the broker of users involved in transfers. Is only\ntaken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "channels",
          "in" : "query",
          "description" : "Reference to the channel used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "excludedIds",
          "in" : "query",
          "description" : "List of transfers ids to be excluded from the result.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "accessClients",
          "in" : "query",
          "description" : "References to access clients used to perform / receive the transfer\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "Transfer statuses used as search criteria. Each array element should be either the identifier or the status qualified internal name, composed by flow internal name, a dot, and the status internal name. For example, `loan.open` would be a valid internal name.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "amountRange",
          "in" : "query",
          "description" : "The minimum / maximum amount.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "number"
          }
        }, {
          "name" : "transferKinds",
          "in" : "query",
          "description" : "Indicates the reason the transfer was created Possible values for each array element are: * payment: A transfer generated by a direct payment or accepting a webshop order * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * recurringPayment: A transfer generated when processing a recurring payment * chargeback: A transfer which is a chargeback of another transfer * initialCredit: A transfer which is the initial credit for a newly created account * transferFee: A transfer generated by a transfer fee charge * accountFee: A transfer generated by an account fee charge * import: An imported transfer\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "payment", "scheduledPaymentInstallment", "recurringPayment", "chargeback", "initialCredit", "transferFee", "accountFee", "import" ]
          },
          "x-type" : "List<TransferKind>"
        }, {
          "name" : "chargedBack",
          "in" : "query",
          "description" : "When set to either `true` will only return transfers that were charged-back. When set to false, will only return transfers that were not charged-back. When left blank will not filter by this creterion.\n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "currency",
          "in" : "query",
          "description" : "Either id or internal name of the currency",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "fromAccountType",
          "in" : "query",
          "description" : "Either id or internal name of the origin account type",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "toAccountType",
          "in" : "query",
          "description" : "Either id or internal name of the destination account type",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "orderBy",
          "in" : "query",
          "description" : "Contains the possible 'order by' values when searching for transfers  Possible values are: * dateAsc: The result is ordered by date ascendant * dateDesc: The result is ordered by date descendant * amountAsc: The result is ordered by amount descendant * amountDesc: The result is ordered by amount descendant\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "dateAsc", "dateDesc", "amountAsc", "amountDesc" ],
          "x-type" : "AccountHistoryOrderByEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The users together with their balances",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Transfer"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/transfers/data-for-search" : {
      "get" : {
        "tags" : [ "Transfers" ],
        "summary" : "Returns data for searching transfers over multiple accounts",
        "description" : "Returns configuration data for searching transfers over multiple\naccounts. This operation can only be performed by administrators or\nbrokers over managed users.\n",
        "operationId" : "getTransferDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "Transaction details",
            "schema" : {
              "$ref" : "#/definitions/TransferDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/transfers/{key}" : {
      "get" : {
        "tags" : [ "Transfers" ],
        "summary" : "Returns details about a transfer",
        "description" : "Returns details about a transfer.",
        "operationId" : "viewTransfer",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "key",
          "in" : "path",
          "description" : "Either the id or transaction number",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Transaction details",
            "schema" : {
              "$ref" : "#/definitions/TransferView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/transfers/{key}/chargeback" : {
      "post" : {
        "tags" : [ "Transfers" ],
        "summary" : "Perform the chargeback of a transfer",
        "description" : "The chargeback generates a new transaction with `kind` = `chargeback`. A new transfer is generated with the same from / to, and negative amount. This will effectively return the amount to the original account. Only top-level transfers can be charged back. For example, a transfer used to charge a fee cannot be charged back. Also, the hability to chargeback a transfer depends on permissions and configuration like the maximum allowed time for the chargeback. \n",
        "operationId" : "chargebackTransfer",
        "produces" : [ "application/json", "text/plain" ],
        "parameters" : [ {
          "name" : "key",
          "in" : "path",
          "description" : "Either the id or transaction number",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "201" : {
            "description" : "The chargeback id",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the created chargeback"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "There was an error while creating the chargeback payment\n",
            "schema" : {
              "$ref" : "#/definitions/PaymentError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "Search for users",
        "description" : "Returns a page of users that match a given criteria. The fields returned depend on the products, in the profile fields of other users setting. Only fields (both basic or custom) marked to be returned on user list are returned. If no fields are set to be returned, the resulting objects will have the `display` and `shortDisplay` filled in. However, those fields are not returned when another profile field is returned, preventing duplicated data to be returned. \n",
        "operationId" : "searchUsers",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "usersToExclude",
          "in" : "query",
          "description" : "Indicated the users to be excluded from the result\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "usersToInclude",
          "in" : "query",
          "description" : "Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "activationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user activation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user creation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "lastLoginPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user last login date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Either id or internal names of groups / group sets",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "brokers",
          "in" : "query",
          "description" : "Either id or a principal (login name, e-mail, etc) for brokers",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "mainBrokerOnly",
          "in" : "query",
          "description" : "When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "latitude",
          "in" : "query",
          "description" : "The reference latitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "longitude",
          "in" : "query",
          "description" : "The reference longitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "maxDistance",
          "in" : "query",
          "description" : "Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position.\n",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "addressResult",
          "in" : "query",
          "description" : "Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * none: Addresses are not returned. * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * primary: The primary (default) address is returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "none", "all", "nearest", "primary" ],
          "x-type" : "AddressInSearchResultEnum"
        }, {
          "name" : "includeGroup",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user groups, will return the `group` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "includeGroupSet",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "ignoreProfileFieldsInList",
          "in" : "query",
          "description" : "When set to `true`, instead of returning users with corresponding profile fields set on list, will return them with `display` and `shortDisplay`. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "excludeContacts",
          "in" : "query",
          "description" : "When set to `true` will not return any user that is already a contact of the currently authenticated user.\n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * removed: The user was permanently removed. It's profile is kept for historical purposes. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "active", "blocked", "disabled", "removed", "pending" ]
          },
          "x-type" : "List<UserStatusEnum>"
        }, {
          "name" : "roles",
          "in" : "query",
          "description" : "The main role the user has. Possible values for each array element are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "administrator", "broker", "member", "operator" ]
          },
          "x-type" : "List<RoleEnum>"
        }, {
          "name" : "orderBy",
          "in" : "query",
          "description" : "Possible options for ordering the results of an user search. Possible values are: * relevance: This is the default if keywords are used. Best matching users come first. * creationDate: Newly registered users are returned first. * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Users will be randomly returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "relevance", "creationDate", "alphabeticallyAsc", "alphabeticallyDesc", "distance", "random" ],
          "x-type" : "UserOrderByEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The users matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/UserResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Users" ],
        "summary" : "Registers a new user",
        "description" : "Can either be a public registration, requiring no authorization,\nor an user registration by an administrator or broker. The public\nregistration normally requires a CAPTCHA challenge to prevent bots.\nOn user registration the following data is also user data is also\ncreated:\n* Address\n* Mobile phone\n* Landline phone\n* Images\nAfter the registration those data are managed separatedly than the\nuser profile data. \n",
        "operationId" : "createUser",
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "The user to be registered",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UserNew"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "The result of the registration",
            "schema" : {
              "$ref" : "#/definitions/UserRegistrationResult"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the registered user's profile"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users/data-for-new" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "Get configuration data for registering new users",
        "description" : "Almost every aspect of an user profile is configurable in Cyclos,\nsuch as enabled basic profile fields, custom profile fields, address\nfields, phone configuration and so on. As such, if a front-end needs\nto be robust to such a dynamic nature, it should get this information\nin order to create a correct registration form. \n",
        "operationId" : "getUserDataForNew",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "group",
          "in" : "query",
          "description" : "The intial group for the new user",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An object containing the data",
            "schema" : {
              "$ref" : "#/definitions/UserDataForNew"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users/data-for-search" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "Get configuration data for searching users",
        "description" : "Returns data with the current configuration regarding the user search\n",
        "operationId" : "getUserDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for user search",
            "schema" : {
              "$ref" : "#/definitions/UserDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users/groups-for-registration" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "Returns the groups the authenticated user or guest can register on",
        "description" : "Returns the list of groups the authenticated user can use to perform a\nnew user registration. If authenticated as guest, will return the groups\ncurrently set for public registration. When there is an authenticated\nadministrator or broker, will be the configured groups for new users.\n",
        "operationId" : "getGroupsForUserRegistration",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of groups",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/GroupForRegistration"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users/map" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "Search the user directory (map)",
        "description" : "Returns a page of users in the map directory that match a given criteria\n",
        "operationId" : "searchMapDirectory",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "usersToExclude",
          "in" : "query",
          "description" : "Indicated the users to be excluded from the result\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "usersToInclude",
          "in" : "query",
          "description" : "Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "activationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user activation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user creation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "lastLoginPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user last login date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Either id or internal names of groups / group sets",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "brokers",
          "in" : "query",
          "description" : "Either id or a principal (login name, e-mail, etc) for brokers",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "mainBrokerOnly",
          "in" : "query",
          "description" : "When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "latitude",
          "in" : "query",
          "description" : "The reference latitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "longitude",
          "in" : "query",
          "description" : "The reference longitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "maxDistance",
          "in" : "query",
          "description" : "Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position.\n",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "addressResult",
          "in" : "query",
          "description" : "Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * none: Addresses are not returned. * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * primary: The primary (default) address is returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "none", "all", "nearest", "primary" ],
          "x-type" : "AddressInSearchResultEnum"
        }, {
          "name" : "includeGroup",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user groups, will return the `group` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "includeGroupSet",
          "in" : "query",
          "description" : "When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "ignoreProfileFieldsInList",
          "in" : "query",
          "description" : "When set to `true`, instead of returning users with corresponding profile fields set on list, will return them with `display` and `shortDisplay`. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "excludeContacts",
          "in" : "query",
          "description" : "When set to `true` will not return any user that is already a contact of the currently authenticated user.\n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * removed: The user was permanently removed. It's profile is kept for historical purposes. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "active", "blocked", "disabled", "removed", "pending" ]
          },
          "x-type" : "List<UserStatusEnum>"
        }, {
          "name" : "roles",
          "in" : "query",
          "description" : "The main role the user has. Possible values for each array element are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "administrator", "broker", "member", "operator" ]
          },
          "x-type" : "List<RoleEnum>"
        }, {
          "name" : "orderBy",
          "in" : "query",
          "description" : "Possible options for ordering the results of an user search. Possible values are: * relevance: This is the default if keywords are used. Best matching users come first. * creationDate: Newly registered users are returned first. * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Users will be randomly returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "relevance", "creationDate", "alphabeticallyAsc", "alphabeticallyDesc", "distance", "random" ],
          "x-type" : "UserOrderByEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The users matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/UserResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users/map/data-for-search" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "Get configuration data for searching the user directory (map)",
        "description" : "Returns data with the current configuration regarding the user \ndirectory (map)\n",
        "operationId" : "getDataForMapDirectory",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for user directory (map)",
            "schema" : {
              "$ref" : "#/definitions/UserDataForMap"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users/{user}" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "View an user details",
        "description" : "Returns the profile information of an user.\n",
        "operationId" : "viewUser",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "User details",
            "schema" : {
              "$ref" : "#/definitions/UserView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "put" : {
        "tags" : [ "Users" ],
        "summary" : "Save an user details",
        "description" : "Saves the user profile. Only the basic fields (full name, login name,\ne-mail) and custom fields can be saved with this operation. Addresses,\nphones and images must be managed through their own paths.\n",
        "operationId" : "updateUser",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "The user to be saved",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UserEdit"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "If the save is correct, nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/users/{user}/data-for-edit" : {
      "get" : {
        "tags" : [ "Users" ],
        "summary" : "Get configuration data to edit an user profile",
        "description" : "Returns data to edit an user profile.\n",
        "operationId" : "getUserDataForEdit",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "User profile details",
            "schema" : {
              "$ref" : "#/definitions/UserDataForEdit"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/vouchers/{key}" : {
      "get" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Returns data for a particular voucher",
        "description" : "Returns details about a particular voucher, as well as the transactions used to buy and redeem, and the permissions for authenticated over it.\n",
        "operationId" : "viewVoucher",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "key",
          "in" : "path",
          "description" : "The voucher `id` or `token`. When the token is fully numeric, it must be preceded by a single quote (`'`).\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The voucher details",
            "schema" : {
              "$ref" : "#/definitions/VoucherView"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/vouchers/{key}/qr-code" : {
      "get" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Returns the QR-code image for the given voucher",
        "description" : "The api documentation page, using swagger-ui (or any direct usage of an image tag), generates a second  request to show the image contents on the preview. This is a new GET request, without passing-in the authentication parameters. As this path requires authentication, the image is shown broken, but the first request works as expected, returning the image content. Optionally, to solve the problem described above and allow to authenticate the user when using sessions, a `sessionToken` or `accessClientToken` plus a `channel` query parameters could be specified.\n",
        "operationId" : "getVoucherQrCode",
        "produces" : [ "application/json", "image/jpeg", "image/gif", "image/png" ],
        "parameters" : [ {
          "name" : "key",
          "in" : "path",
          "description" : "The voucher `id` or `token`. When the token is fully numeric, it must be preceded by a single quote (`'`).\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "The possible sizes of images. The actual pixel size depends on the configuration in Cyclos Possible values are: * small: Small thumbnail * medium: Medium thumbnail * large: Full image size\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "small", "medium", "large" ],
          "x-type" : "ImageSizeEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The image content"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/accounts" : {
      "get" : {
        "tags" : [ "Accounts" ],
        "summary" : "Lists accounts of the given owner with their statuses",
        "description" : "Lists all visible accounts of the given user, or system accounts if the owner 'system' is used. Each account has status information, like the current balance, avaliable balance and so on. However, the returned data depend on the configuration, in the `Account status indicators` option, which is used to limit the amount of data returned.\n",
        "operationId" : "listAccountsByOwner",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The accounts with their statuses.",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/AccountWithStatus"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/accounts/{accountType}" : {
      "get" : {
        "tags" : [ "Accounts" ],
        "summary" : "Returns the status of an account by owner and type",
        "description" : "Returns the account status for a specific account. The account type may be either the identifier or internal name. The status will contain both instant status information, that is, the same fields as `AccountStatus`, plus status that depend on the input parameters, such as those defined in `AccountWithHistoryStatus`. The actual data inside the result depend on the configuration, in the `Account status indicators` option, which is used to limit the amount of data returned.\n",
        "operationId" : "getAccountStatusByOwnerAndType",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountType",
          "in" : "path",
          "description" : "The internal name or id of the account type",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "datePeriod",
          "in" : "query",
          "description" : "The minimum / maximum transfer date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "transferFilters",
          "in" : "query",
          "description" : "Reference to the transfer filters, which filters transfers by type.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "transactionNumber",
          "in" : "query",
          "description" : "The transaction number of the matching transfer\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "user",
          "in" : "query",
          "description" : "Reference an user that should have either received / performed the\ntransfer.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Reference to the user group used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "by",
          "in" : "query",
          "description" : "Reference to the user that was authenticated when the transfer was\nperformed. Is only taken into account if authenticated as\nadministrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "broker",
          "in" : "query",
          "description" : "Reference to the broker of users involved in transfers. Is only\ntaken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "channels",
          "in" : "query",
          "description" : "Reference to the channel used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "excludedIds",
          "in" : "query",
          "description" : "List of transfers ids to be excluded from the result.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "accessClients",
          "in" : "query",
          "description" : "References to access clients used to perform / receive the transfer\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "Transfer statuses used as search criteria. Each array element should be either the identifier or the status qualified internal name, composed by flow internal name, a dot, and the status internal name. For example, `loan.open` would be a valid internal name.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "amountRange",
          "in" : "query",
          "description" : "The minimum / maximum amount.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "number"
          }
        }, {
          "name" : "transferKinds",
          "in" : "query",
          "description" : "Indicates the reason the transfer was created Possible values for each array element are: * payment: A transfer generated by a direct payment or accepting a webshop order * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * recurringPayment: A transfer generated when processing a recurring payment * chargeback: A transfer which is a chargeback of another transfer * initialCredit: A transfer which is the initial credit for a newly created account * transferFee: A transfer generated by a transfer fee charge * accountFee: A transfer generated by an account fee charge * import: An imported transfer\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "payment", "scheduledPaymentInstallment", "recurringPayment", "chargeback", "initialCredit", "transferFee", "accountFee", "import" ]
          },
          "x-type" : "List<TransferKind>"
        }, {
          "name" : "chargedBack",
          "in" : "query",
          "description" : "When set to either `true` will only return transfers that were charged-back. When set to false, will only return transfers that were not charged-back. When left blank will not filter by this creterion.\n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Indicates whether from an account POV a transfer is a credit or debit Possible values are: * credit: The transfer impacts the balance positively * debit: The transfer impacts the balance negatively\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "credit", "debit" ],
          "x-type" : "TransferDirectionEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The account",
            "schema" : {
              "$ref" : "#/definitions/AccountWithHistoryStatus"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/accounts/{accountType}/data-for-history" : {
      "get" : {
        "tags" : [ "Accounts" ],
        "summary" : "Returns data for searching an account history by owner and type",
        "description" : "Returns configuration data for searching entries in a specific account\nhistory, as well as status information for that account information.\n",
        "operationId" : "getAccountHistoryDataByOwnerAndType",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountType",
          "in" : "path",
          "description" : "The internal name or id of the account type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for searching account history",
            "schema" : {
              "$ref" : "#/definitions/DataForAccountHistory"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/accounts/{accountType}/history" : {
      "get" : {
        "tags" : [ "Accounts" ],
        "summary" : "Search an account history",
        "description" : "Returns a page of account history entries for a specific account,\naccording to the given criteria\n",
        "operationId" : "searchAccountHistory",
        "parameters" : [ {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountType",
          "in" : "path",
          "description" : "The account type",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "datePeriod",
          "in" : "query",
          "description" : "The minimum / maximum transfer date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "transferFilters",
          "in" : "query",
          "description" : "Reference to the transfer filters, which filters transfers by type.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "transactionNumber",
          "in" : "query",
          "description" : "The transaction number of the matching transfer\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "user",
          "in" : "query",
          "description" : "Reference an user that should have either received / performed the\ntransfer.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Reference to the user group used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "by",
          "in" : "query",
          "description" : "Reference to the user that was authenticated when the transfer was\nperformed. Is only taken into account if authenticated as\nadministrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "broker",
          "in" : "query",
          "description" : "Reference to the broker of users involved in transfers. Is only\ntaken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "channels",
          "in" : "query",
          "description" : "Reference to the channel used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "excludedIds",
          "in" : "query",
          "description" : "List of transfers ids to be excluded from the result.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "accessClients",
          "in" : "query",
          "description" : "References to access clients used to perform / receive the transfer\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "Transfer statuses used as search criteria. Each array element should be either the identifier or the status qualified internal name, composed by flow internal name, a dot, and the status internal name. For example, `loan.open` would be a valid internal name.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "amountRange",
          "in" : "query",
          "description" : "The minimum / maximum amount.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "number"
          }
        }, {
          "name" : "transferKinds",
          "in" : "query",
          "description" : "Indicates the reason the transfer was created Possible values for each array element are: * payment: A transfer generated by a direct payment or accepting a webshop order * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * recurringPayment: A transfer generated when processing a recurring payment * chargeback: A transfer which is a chargeback of another transfer * initialCredit: A transfer which is the initial credit for a newly created account * transferFee: A transfer generated by a transfer fee charge * accountFee: A transfer generated by an account fee charge * import: An imported transfer\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "payment", "scheduledPaymentInstallment", "recurringPayment", "chargeback", "initialCredit", "transferFee", "accountFee", "import" ]
          },
          "x-type" : "List<TransferKind>"
        }, {
          "name" : "chargedBack",
          "in" : "query",
          "description" : "When set to either `true` will only return transfers that were charged-back. When set to false, will only return transfers that were not charged-back. When left blank will not filter by this creterion.\n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Indicates whether from an account POV a transfer is a credit or debit Possible values are: * credit: The transfer impacts the balance positively * debit: The transfer impacts the balance negatively\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "credit", "debit" ],
          "x-type" : "TransferDirectionEnum"
        }, {
          "name" : "orderBy",
          "in" : "query",
          "description" : "Contains the possible 'order by' values when searching for transfers  Possible values are: * dateAsc: The result is ordered by date ascendant * dateDesc: The result is ordered by date descendant * amountAsc: The result is ordered by amount descendant * amountDesc: The result is ordered by amount descendant\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "dateAsc", "dateDesc", "amountAsc", "amountDesc" ],
          "x-type" : "AccountHistoryOrderByEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The account history entries matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/AccountHistoryResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/operations" : {
      "get" : {
        "tags" : [ "Operations" ],
        "summary" : "Lists the custom operations over the system or user",
        "description" : "Returns the custom operations the authenticated user can run over the\ngiven user or system if the `system` owner is used. \n",
        "operationId" : "listOperationsByOwner",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of custom operations\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Operation"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/operations/{operation}/data-for-run" : {
      "get" : {
        "tags" : [ "Operations" ],
        "summary" : "Returns configuration data for running a custom operation",
        "description" : "Returns data to run a specific custom operation over a specific over the\ngiven user or system if the `system` owner is used. \n",
        "operationId" : "getOperationDataForRun",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "operation",
          "in" : "path",
          "description" : "Either the id or internal name of the custom operation",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data used to run the operation\n",
            "schema" : {
              "$ref" : "#/definitions/OperationDataForRun"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/operations/{operation}/run" : {
      "post" : {
        "tags" : [ "Operations" ],
        "summary" : "Runs a custom operation either for system or user",
        "description" : "Runs a specific custom operation over a specific over the given user or system if the `system` owner is used. If the operation resulted in a file download (either because the `resultType` is `fileDownload` or is a `resultPage` running for either PDF or CSV) the resulting contente type will be of the file itself. Otherwise will result in an `application/json` with the result object. \n",
        "operationId" : "runOperation",
        "produces" : [ "application/json", "text/plain", "text/html", "text/css", "text/yaml", "text/javascript", "text/csv", "image/jpeg", "image/gif", "image/png", "application/pdf", "application/zip", "image/svg+xml", "application/octet-stream" ],
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "operation",
          "in" : "path",
          "description" : "Either the id or internal name of the custom operation",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "params",
          "description" : "The custom operation parameters",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/RunOperation"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The custom operation result, either as `RunOperationResult` or as\nthe file itself\n",
            "schema" : {
              "$ref" : "#/definitions/RunOperationResult"
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json",
        "x-produces-any" : true
      }
    },
    "/{owner}/operations/{operation}/run-upload" : {
      "post" : {
        "tags" : [ "Operations" ],
        "summary" : "Runs a custom operation either for system or user while uploading a file\n",
        "description" : "Runs a specific custom operation over a specific over the given user or system if the `system` owner is used.  This path allows uploading a file, by using a `multipart-form-data` post. If the operation resulted in a file download (either because the `resultType` is `fileDownload` or is a `resultPage` running for either PDF or CSV) the resulting contente type will be of the file itself. Otherwise will result in an `application/json` with the result object. \n",
        "operationId" : "runOperationWithUpload",
        "consumes" : [ "multipart/form-data" ],
        "produces" : [ "application/json", "text/plain", "text/html", "text/css", "text/yaml", "text/javascript", "text/csv", "image/jpeg", "image/gif", "image/png", "application/pdf", "application/zip", "image/svg+xml", "application/octet-stream" ],
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "operation",
          "in" : "path",
          "description" : "Either the id or internal name of the custom operation",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "params",
          "in" : "formData",
          "description" : "The custom operation parameters, encoded as `RunOperation`. \n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "file",
          "in" : "formData",
          "description" : "The file being uploaded",
          "required" : true,
          "type" : "file"
        } ],
        "responses" : {
          "200" : {
            "description" : "The custom operation result, either as `RunOperationResult` or as\nthe file itself\n",
            "schema" : {
              "$ref" : "#/definitions/RunOperationResult"
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "multipart/form-data",
        "x-produces-any" : true
      }
    },
    "/{owner}/payments" : {
      "post" : {
        "tags" : [ "Payments" ],
        "summary" : "Performs a payment from the given owner",
        "description" : "Performs either a direct or scheduled payment from the owner indicated on the path to the owner specified on the body. The destination user should be informed in the `subject` parameter. If the `subject` is `system`, it will be a payment to a system account. The payment id is returned on the response, and a link to the transaction details is returned on the `Location` header.\n",
        "operationId" : "performPayment",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "payment",
          "description" : "The perform payment parameters",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PerformPayment"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "The created payment",
            "schema" : {
              "$ref" : "#/definitions/Transaction"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the transaction details"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "If a payment error has occurred",
            "schema" : {
              "$ref" : "#/definitions/PaymentError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/payments/data-for-perform" : {
      "get" : {
        "tags" : [ "Payments" ],
        "summary" : "Returns configuration data for performing a payment",
        "description" : "Returns configuration data for performing a payment \n",
        "operationId" : "dataForPerformPayment",
        "parameters" : [ {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "to",
          "in" : "query",
          "description" : "The payment destination. Either the string `system` for a payment to system or an user identification.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "query",
          "description" : "The payment type id or qualified internal name (in the form `fromAccountType.paymentType`). If no payment type is provided, the possible types will be returned, so the payer can choose.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for performing a payment",
            "schema" : {
              "$ref" : "#/definitions/DataForTransaction"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/payments/installments" : {
      "get" : {
        "tags" : [ "Payments" ],
        "summary" : "Calculates the default installments for a scheduled payment",
        "description" : "Used to calculate installments for a scheduled payment. Will return an\ninstallment every month. When later performing the payment, these can be\n(optionally) customized (such as changing some due dates or amounts) and\nused on the payment installments.   \n",
        "operationId" : "calculatePerformPaymentInstallments",
        "parameters" : [ {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "to",
          "in" : "query",
          "description" : "The payment destination",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "count",
          "in" : "query",
          "description" : "The number of installments",
          "required" : true,
          "type" : "integer"
        }, {
          "name" : "amount",
          "in" : "query",
          "description" : "The total scheduled payment amount",
          "required" : true,
          "type" : "string",
          "format" : "number"
        }, {
          "name" : "currency",
          "in" : "query",
          "description" : "The payment currency. Used when no `type` is not provided, to narrow the possible payment types by currency.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "query",
          "description" : "The payment type id or qualified internal name (in the form  `fromAccountType.paymentType`). If not provided, will use the first possible type (possibly narrowed by the `currency` parameter). However, if more than one type is available, a validation error will be raised.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "firstDate",
          "in" : "query",
          "description" : "The due date of the first installment. If none is provided, it is\nassumed that the first installment is paid immediately, and others\nwill be with regular 1 month interval\n",
          "required" : false,
          "type" : "string",
          "format" : "date-time"
        } ],
        "responses" : {
          "200" : {
            "description" : "The calculated installments",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/PerformScheduledPaymentInstallment"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/payments/preview" : {
      "post" : {
        "tags" : [ "Payments" ],
        "summary" : "Previews a payment before performing it",
        "description" : "Previews a payment or scheduled payment. The actual balance checking\nis not performed in the preview. \n",
        "operationId" : "previewPayment",
        "parameters" : [ {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "in" : "body",
          "name" : "payment",
          "description" : "The perform payment parameters",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PerformPayment"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The payment preview",
            "schema" : {
              "$ref" : "#/definitions/PaymentPreview"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/record-types" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Lists the record types over an user or system",
        "description" : "Returns the record types the authenticated user can view over the\ngiven user or system if the `system` owner is used. \n",
        "operationId" : "listRecordTypesByOwner",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of visible record types\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/OwnerRecordPermissions"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/record-types/{type}" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Returns a single record type over an user or system",
        "description" : "Returns the a specific record type the authenticated user can view over the\ngiven user or system if the `system` owner is used. \n",
        "operationId" : "getRecordTypeByOwner",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the identifier or internal name of the record type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The record type details\n",
            "schema" : {
              "$ref" : "#/definitions/OwnerRecordPermissions"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/records/{type}" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Searches for records of a specific type and owner",
        "description" : "Returns records matching the search criteria, for a specific type,  either for system or user records, depending on the `owner` parameter. The custom fields returned on each record depend on the field configuration, which needs to be enabled to return on list. The profile fields available as search filters for records are assigned in the products (or admin group permissions).\n",
        "operationId" : "searchOwnerRecords",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the identifier or internal name of the record type",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum record creation date\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for searching records\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/RecordResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Records" ],
        "summary" : "Creates a new record for the given owner and type",
        "description" : "Creates a new record for the given owner and type.\nIf the owner is `system` will be a system\nrecord. Otherwise will be an user record.\n",
        "operationId" : "createRecord",
        "produces" : [ "application/json", "text/plain" ],
        "parameters" : [ {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the identifier or internal name of the record type",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "record",
          "description" : "The record to be created",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/RecordNew"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Returns the identifier of the new record",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the record details"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/records/{type}/data-for-new" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Returns data to create a new record",
        "description" : "Returns configuration data for creating a record for the given owner\nand type. If the owner is `system` will be a system\nrecord. Otherwise will be an user record. \n",
        "operationId" : "getRecordDataForNew",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "The record type to be created",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for creating a record",
            "schema" : {
              "$ref" : "#/definitions/RecordDataForNew"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/records/{type}/data-for-search" : {
      "get" : {
        "tags" : [ "Records" ],
        "summary" : "Returns data for searching records of a specific type and owner",
        "description" : "Returns data for searching records of a specific type, either for system or user records, depending on the `owner` parameter. \n",
        "operationId" : "getRecordDataForOwnerSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the identifier or internal name of the record type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for searching records\n",
            "schema" : {
              "$ref" : "#/definitions/RecordDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/transactions" : {
      "get" : {
        "tags" : [ "Transactions" ],
        "summary" : "Searches transactions of an account owner",
        "description" : "Returns the transactions of a given account owner that match the\nspecified criteria. Each result will will be relative to this owner.\nThe amount may be positive or negative, depending on whether this\nowner has performed or received the transaction.\n",
        "operationId" : "searchTransactions",
        "parameters" : [ {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "accountTypes",
          "in" : "query",
          "description" : "The account types",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "datePeriod",
          "in" : "query",
          "description" : "The minimum / maximum transaction date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "transactionNumber",
          "in" : "query",
          "description" : "The transaction number of the matching transfer\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "user",
          "in" : "query",
          "description" : "Reference an user that should have either received / performed the\ntransfer.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "groups",
          "in" : "query",
          "description" : "Reference to the user group used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "by",
          "in" : "query",
          "description" : "Reference to the user that was authenticated when the transfer was\nperformed. Is only taken into account if authenticated as\nadministrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "broker",
          "in" : "query",
          "description" : "Reference to the broker of users involved in transfers. Is only\ntaken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "channels",
          "in" : "query",
          "description" : "Reference to the channel used to perform / receive the transfer.\nOnly taken into account if authenticated as administrator.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "accessClients",
          "in" : "query",
          "description" : "References to access clients used to perform / receive the transfer\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "kinds",
          "in" : "query",
          "description" : "The kind of a transaction  Possible values for each array element are: * payment: A direct payment * recurringPayment: A payment which is processed again periodically * scheduledPayment: A scheduled payment which is either a payment scheduled for a future date or has multiple installments * paymentRequest: A request for another user to accept a payment  * externalPayment: A payment to an external user * chargeback: Chargeback of a given transfer * import: An imported transaction * order: Transaction generated by confirming an order\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "payment", "recurringPayment", "scheduledPayment", "paymentRequest", "externalPayment", "chargeback", "import", "order" ]
          },
          "x-type" : "List<TransactionKind>"
        } ],
        "responses" : {
          "200" : {
            "description" : "The transaction entries matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/TransactionResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{owner}/transactions/data-for-search" : {
      "get" : {
        "tags" : [ "Transactions" ],
        "summary" : "Returns data for searching transactions of an account owner",
        "description" : "Returns data which can be used to filter a transaction search",
        "operationId" : "getTransactionsDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "owner",
          "in" : "path",
          "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Data for searching transactions of an account owner",
            "schema" : {
              "$ref" : "#/definitions/TransactionDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/addresses" : {
      "get" : {
        "tags" : [ "Addresses" ],
        "summary" : "Lists all (visible) user addresses",
        "description" : "Returns a list with all addresses of the given user that the currently\nauthenticated user can see. \n",
        "operationId" : "listAddressesByUser",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of visible user addresses\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/AddressResult"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Addresses" ],
        "summary" : "Creates a new address for the given user",
        "description" : "Creates a new address for the given user. If it is set to\nbe the default one, the previous default (if any) will no longer be\nthe default address for that user.\n",
        "operationId" : "createAddress",
        "produces" : [ "application/json", "text/plain" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "address",
          "description" : "The address to be created",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/AddressNew"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Returns the identifier of the new address",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the address details"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/addresses/data-for-new" : {
      "get" : {
        "tags" : [ "Addresses" ],
        "summary" : "Returns data to create a new address",
        "description" : "Returns configuration data for creating an address for the given user\n",
        "operationId" : "getAddressDataForNew",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for creating an address",
            "schema" : {
              "$ref" : "#/definitions/AddressDataForNew"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/addresses/list-data" : {
      "get" : {
        "tags" : [ "Addresses" ],
        "summary" : "Returns data for addresses listing of the given user",
        "description" : "Returns data containing the (visible) user addresses, plus additional\ndata related to addresses.\n",
        "operationId" : "getUserAddressesListData",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for listing addresses",
            "schema" : {
              "$ref" : "#/definitions/UserAddressesListData"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/addresses/primary" : {
      "get" : {
        "tags" : [ "Addresses" ],
        "summary" : "Returns the primary address of a given user",
        "description" : "Returns the primary (default) address of the given user,\nin case it is visible\n",
        "operationId" : "getUserPrimaryAddress",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The primary addresses",
            "schema" : {
              "$ref" : "#/definitions/Address"
            }
          },
          "204" : {
            "description" : "No content when no address is primary"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/client-types" : {
      "get" : {
        "tags" : [ "Clients" ],
        "summary" : "Returns the list of access clients types for an user",
        "description" : "Returns the access client types for a given user that the authenticated\nuser has access.\n",
        "operationId" : "listClientTypesForUser",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "channel",
          "in" : "query",
          "description" : "If a channel id or internal name is specified, will only list\naccess client types that can be used to access that channel\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of access clients types, with permissions, for the user\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/UserClientTypePermissions"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/contacts" : {
      "get" : {
        "tags" : [ "Contacts" ],
        "summary" : "Search for an user contacts",
        "description" : "Returns a page of users that are in the contact list of the given user The fields returned depend on the products, in the profile fields of other users setting. Only fields (both basic or custom) marked to be returned on user list are returned. If no fields are set to be returned, the resulting objects will have the `display` and `shortDisplay` filled in. However, those fields are not returned when another profile field is returned, preventing duplicated data to be returned.\n",
        "operationId" : "searchContacts",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The users in the contact list which match the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/UserResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/contacts/{contact}" : {
      "post" : {
        "tags" : [ "Contacts" ],
        "summary" : "Adds an user in the contact list of the given user",
        "description" : "Adds an user in the contact list of the given user",
        "operationId" : "addContact",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "contact",
          "in" : "path",
          "description" : "The user to be added to the contact list",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Indicates whether the contact was really added (true) or if not\nadded, probably because was already a contact (false)\n",
            "schema" : {
              "type" : "boolean"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "delete" : {
        "tags" : [ "Contacts" ],
        "summary" : "Removes an user from the contact list of the given user",
        "description" : "Removes an user from the contact list of the given user",
        "operationId" : "removeContact",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "contact",
          "in" : "path",
          "description" : "The user to be removed from the contact list",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Indicates whether the contact was really removed (true) or if not\nremoved, probably because was not in the contact list (false)\n",
            "schema" : {
              "type" : "boolean"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "409" : {
            "description" : "This operation expected an entity state, but it has resulted in a conflict",
            "schema" : {
              "$ref" : "#/definitions/ConflictError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/images" : {
      "get" : {
        "tags" : [ "Images" ],
        "summary" : "Lists either `profile` or `custom` images for a given user \n",
        "description" : "Returns either `profile` or `custom`\nimages for the given user. For `profile`, the user \nmust be visible by the authenticated user. For `custom`,\nthe authenticated user must either be the owner or a manager\n(administrator or broker).\n",
        "operationId" : "listUserImages",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "The kind of images to be returned.\n  The default value is `profile`\nPossible values are: * profile: User profile images are those associated with the user profile. The first profile image is used to depict the user on search results. * custom: User custom images are additional images that can be used on rich text contents.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "profile", "custom" ],
          "x-type" : "UserImageKind"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of images\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Image"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Images" ],
        "summary" : "Adds a new image for the given user. The image kind is either  `profile` or `custom`.\n",
        "description" : "Uploads a new image, either `profile` (by default)\nor `custom`, for the given user.\n",
        "operationId" : "uploadUserImage",
        "produces" : [ "application/json", "text/plain" ],
        "consumes" : ["multipart/form-data"],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "The kind of images to be returned.\n  The default value is `profile`\nPossible values are: * profile: User profile images are those associated with the user profile. The first profile image is used to depict the user on search results. * custom: User custom images are additional images that can be used on rich text contents.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "profile", "custom" ],
          "x-type" : "UserImageKind"
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "The name for the new image. If not informed will fall back to the\noriginal file name in the form data\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "image",
          "in" : "formData",
          "description" : "The image being uploaded",
          "required" : true,
          "type" : "file"
        } ],
        "responses" : {
          "201" : {
            "description" : "The image is saved, its id is returned in the body and the URL to get the content is returned in the `Location` header\n",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for obtaining the image content"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/x-www-form-urlencoded"
      }
    },
    "/{user}/images/list-data" : {
      "get" : {
        "tags" : [ "Images" ],
        "summary" : "Returns either `profile` or `custom` images for a given user, plus additional permissions and data \n",
        "description" : "Returns either `profile` or `custom`\nimages for the given user. For `profile`, the user \nmust be visible by the authenticated user. For `custom`,\nthe authenticated user must either be the owner or a manager\n(administrator or broker). Additional data, such as the maximum images and\nwhether the images can be managed by the authenticated user are also\nreturned.\n",
        "operationId" : "getUserImagesListData",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "The kind of images to be returned.\n  The default value is `profile`\nPossible values are: * profile: User profile images are those associated with the user profile. The first profile image is used to depict the user on search results. * custom: User custom images are additional images that can be used on rich text contents.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "profile", "custom" ],
          "x-type" : "UserImageKind"
        } ],
        "responses" : {
          "200" : {
            "description" : "The images and additional information\n",
            "schema" : {
              "$ref" : "#/definitions/ImagesListData"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/images/order" : {
      "put" : {
        "tags" : [ "Images" ],
        "summary" : "Changes the order of an user's profile images \n",
        "description" : "The new order is defined by the list of ids, so that images appear in\nthe same order as the ids.\n",
        "operationId" : "reorderProfileImages",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ids",
          "in" : "query",
          "description" : "The array of ids (comma-separated) reflecting the desired order",
          "required" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The image order is changed and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/marketplace" : {
      "get" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Search for advertisements of a specific user",
        "description" : "Returns a page of advertisements that match a given criteria for a given user. Equivallent to calling `GET /marketplace?owner={user}`\n",
        "operationId" : "searchUserAds",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "keywords",
          "in" : "query",
          "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "profileFields",
          "in" : "query",
          "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "customFields",
          "in" : "query",
          "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "category",
          "in" : "query",
          "description" : "Either id or internal name of a category",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "currency",
          "in" : "query",
          "description" : "Either id or internal name of a currency for the price",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "priceRange",
          "in" : "query",
          "description" : "The minumum / maximum price.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "number"
          }
        }, {
          "name" : "hasImages",
          "in" : "query",
          "description" : "When set to `true` only advertisements with images are returned\n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "publicationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum publication date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "expirationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum expiration date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "simple", "webshop" ],
          "x-type" : "AdKind"
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "The possible status for an advertisement Possible values for each array element are: * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * active: The advertisement is published and can be seen by other users. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "draft", "pending", "active", "scheduled", "expired", "hidden", "disabled" ]
          },
          "x-type" : "List<AdStatusEnum>"
        }, {
          "name" : "orderBy",
          "in" : "query",
          "description" : "Indicates how advertisements results are ordered. Possible values are: * relevance: This is the default if keywords are used. Best matching advertisements come first. * date: Newest advertisements are returned first. * priceAsc: Smaller prices are returned first. Advertisements without price are returned last. * priceDesc: Higher prices are returned first. Advertisements without price are returned last. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Without definite order\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "relevance", "date", "priceAsc", "priceDesc", "distance", "random" ],
          "x-type" : "AdOrderByEnum"
        }, {
          "name" : "latitude",
          "in" : "query",
          "description" : "The reference latitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "longitude",
          "in" : "query",
          "description" : "The reference longitude for distance searches",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "maxDistance",
          "in" : "query",
          "description" : "Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position.\n",
          "required" : false,
          "type" : "number",
          "format" : "double"
        }, {
          "name" : "addressResult",
          "in" : "query",
          "description" : "Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * none: Addresses are not returned. * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * primary: The primary (default) address is returned\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "none", "all", "nearest", "primary" ],
          "x-type" : "AddressInSearchResultEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The advertisements matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/AdResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Creates a new advertisement for the given user",
        "description" : "Creates a new advertisement for the given user\n",
        "operationId" : "createAd",
        "produces" : [ "application/json", "text/plain" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "advertisement",
          "description" : "The advertisement to be created",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/AdNew"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Returns the identifier of the new advertisement",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the advertisement details"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/marketplace/data-for-new" : {
      "get" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Returns data for creating a new advertisement for an user and kind\n",
        "description" : "Returns data for creating a new advertisement for the given user. The `kind` should be informed. If not set, `simple` is assumed. Currently only `simple` advertisements can be created through this API.      \n",
        "operationId" : "getAdDataForNew",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "simple", "webshop" ],
          "x-type" : "AdKind"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for creating a new advertisement",
            "schema" : {
              "$ref" : "#/definitions/AdDataForNew"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/marketplace/data-for-search" : {
      "get" : {
        "tags" : [ "Marketplace" ],
        "summary" : "Returns configuration data for searching advertisements of an user",
        "description" : "Returns data needed on for a user's advertisements search \n",
        "operationId" : "getUserAdDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "kind",
          "in" : "query",
          "description" : "Indicates the kind of advertisement that should be searched. When nothing is passed (default) all kinds will be searched. Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "simple", "webshop" ],
          "x-type" : "AdKind"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for this user's advertisements",
            "schema" : {
              "$ref" : "#/definitions/UserAdDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/operators" : {
      "get" : {
        "tags" : [ "Operators" ],
        "summary" : "Search the operators of a given user",
        "description" : "Returns a page of operators that match a given criteria\n",
        "operationId" : "searchUserOperators",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "ignoreProfileFieldsInList",
          "in" : "query",
          "description" : "When set to `true`, instead of returning users with corresponding profile fields set on list, will return them with `display` and `shortDisplay`. \n",
          "required" : false,
          "type" : "boolean"
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum user creation date. Only taken into account\nif searching as administrator or managing broker.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "operatorGroups",
          "in" : "query",
          "description" : "An array of operator group ids",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * removed: The user was permanently removed. It's profile is kept for historical purposes. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "active", "blocked", "disabled", "removed", "pending" ]
          },
          "x-type" : "List<UserStatusEnum>"
        } ],
        "responses" : {
          "200" : {
            "description" : "The users matching the criteria",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/UserResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/operators/data-for-search" : {
      "get" : {
        "tags" : [ "Operators" ],
        "summary" : "Get configuration data for searching operators of the given user",
        "description" : "Returns data with the current configuration regarding the operators\nof the given user \n",
        "operationId" : "getUserOperatorsDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for operators search over an user",
            "schema" : {
              "$ref" : "#/definitions/UserOperatorsDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords" : {
      "get" : {
        "tags" : [ "Passwords" ],
        "summary" : "Returns the status for each passwords the given user have",
        "description" : "Returns the passwords, with their statuses, for a given user.\nAlso, permissions on which operations are enabled are also returned.\n",
        "operationId" : "listUserPasswords",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of password statuses and permissions\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/PasswordStatusAndPermissions"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords/list-data" : {
      "get" : {
        "tags" : [ "Passwords" ],
        "summary" : "Returns the status for each passwords the given user have",
        "description" : "Returns the passwords, with their statuses, for a given user.\nAlso, permissions on which operations are enabled are also returned.\nIt is also returned additional data, such as the confirmation password\ninput in case some action is needed\n",
        "operationId" : "getUserPasswordsListData",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of password statuses and permissions\n",
            "schema" : {
              "$ref" : "#/definitions/DataForUserPasswords"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords/{type}/change" : {
      "post" : {
        "tags" : [ "Passwords" ],
        "summary" : "Changes a manual password",
        "description" : "Changes a manual password of the given user. When the user is changing his own password he needs to pass in the `oldPassword` as well. When an adminitrator / broker is changing the password of a managed user, he/she can optionally force the password change on next login.  \n",
        "operationId" : "changePassword",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the id or internal name of the password type",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "params",
          "description" : "The parameters for password change",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/ChangePassword"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "The password is changed, and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords/{type}/disable" : {
      "post" : {
        "tags" : [ "Passwords" ],
        "summary" : "Disables a password, making it unusable until manually re-enabled",
        "description" : "Disables a password. It cannot be used again until enabled again.\n",
        "operationId" : "disablePassword",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the id or internal name of the password type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The password is disabled, and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords/{type}/enable" : {
      "post" : {
        "tags" : [ "Passwords" ],
        "summary" : "Re-enables a disabled a password",
        "description" : "Re-enables a password that was previously disabled.\n",
        "operationId" : "enablePassword",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the id or internal name of the password type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The password is re-enabled, and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords/{type}/reset" : {
      "post" : {
        "tags" : [ "Passwords" ],
        "summary" : "Resets a generated password, allowing it to be generated again",
        "description" : "Resets a generated password. This can only be done by administrators / brokers over managed users, and allow them to generate the password value again.\n",
        "operationId" : "resetPassword",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the id or internal name of the password type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The password is reset, and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords/{type}/reset-and-send" : {
      "post" : {
        "tags" : [ "Passwords" ],
        "summary" : "Generates a new value for a manual password and send it to the user via e-mail \n",
        "description" : "Resets a manual password to a generated value and send it to the user.\n  Can also be used to reset and send the main channel's access password if it\n  is generated. The new password is initially expired, so the user needs\n  to change it on first login.\n",
        "operationId" : "resetAndSendPassword",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the id or internal name of the password type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The password is reset and sent, and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/passwords/{type}/unblock" : {
      "post" : {
        "tags" : [ "Passwords" ],
        "summary" : "Unblocks a password that has been blocked by exceeding the wrong tries \n",
        "description" : "The password is unblocked if its status is either  `temporarilyBlocked` or `indefinitelyBlocked`.\n",
        "operationId" : "unblockPassword",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "path",
          "description" : "Either the id or internal name of the password type",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "204" : {
            "description" : "The password is unblocked, and nothing is returned"
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/phones" : {
      "get" : {
        "tags" : [ "Phones" ],
        "summary" : "Lists all (visible) user phones",
        "description" : "Returns a list with all phones of the given user that the currently\nauthenticated user can see. \n",
        "operationId" : "listPhonesByUser",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of visible user phones\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/PhoneResult"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      },
      "post" : {
        "tags" : [ "Phones" ],
        "summary" : "Creates a new phone for the given user",
        "description" : "Creates a new phone for the given user",
        "operationId" : "createPhone",
        "produces" : [ "application/json", "text/plain" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "phone",
          "description" : "The phone to be created",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PhoneNew"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Returns the identifier of the new phone",
            "schema" : {
              "type" : "string"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the mobile phone details"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "422" : {
            "description" : "Input error. Either a validation error or the maximum allowed items was exceeded\n",
            "schema" : {
              "$ref" : "#/definitions/InputError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/phones/data-for-new" : {
      "get" : {
        "tags" : [ "Phones" ],
        "summary" : "Returns data to create a new phone",
        "description" : "Returns configuration data for creating a phone for the given user\n",
        "operationId" : "getPhoneDataForNew",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "query",
          "description" : "Type of phone Possible values are: * mobile: A mobile phone * landLine: A landline phone\n",
          "required" : true,
          "type" : "string",
          "enum" : [ "mobile", "landLine" ],
          "x-type" : "PhoneKind"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for creating a phone",
            "schema" : {
              "$ref" : "#/definitions/PhoneDataForNew"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/phones/list-data" : {
      "get" : {
        "tags" : [ "Phones" ],
        "summary" : "Returns data for listing an user's phones",
        "description" : "Returns data containing the (visible) user phones, plus additional data\nrelated to phones.\n",
        "operationId" : "getUserPhonesListData",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An object containing the phones plus additional information\n",
            "schema" : {
              "$ref" : "#/definitions/UserPhonesListData"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/vouchers" : {
      "get" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Searches for vouchers an user has bought or redeemed",
        "description" : "Returns the list of matching vouchers the given user has either bought (default) or redeemed (if `type` is `redeemed`)\n",
        "operationId" : "searchUserVouchers",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number (zero-based) of the search. The default value is zero.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "pageSize",
          "in" : "query",
          "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "relation",
          "in" : "query",
          "description" : "Indicates the relation used to filter the vouchers. Possible values are: * bought: A voucher the user has bought * redeemed: A voucher the user has redeemed\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "bought", "redeemed" ],
          "x-type" : "VoucherRelationEnum"
        }, {
          "name" : "amountRange",
          "in" : "query",
          "description" : "The minimum / maximum voucher amount\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "number"
          }
        }, {
          "name" : "creationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum voucher creation date.\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "expirationPeriod",
          "in" : "query",
          "description" : "The minimum / maximum voucher expiration date\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "redeemPeriod",
          "in" : "query",
          "description" : "The minimum / maximum voucher redeem date\nIs expressed an array, with the lower bound as first element, and\nthe upper bould as second element. When only one element, will have\njust the lower bound. To specify only the upper bound, prefix the value\nwith a comma.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "format" : "date-time"
          }
        }, {
          "name" : "statuses",
          "in" : "query",
          "description" : "The voucher statuses Possible values for each array element are: * open: The voucher has been generated / bought, and is open * expired: The voucher has expired without being redeemed * canceled: The voucher was canceled, and cannot be further used * redeemed: The voucher has been redeemed, and the corresponding payment was done\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "open", "expired", "canceled", "redeemed" ]
          },
          "x-type" : "List<VoucherStatusEnum>"
        }, {
          "name" : "token",
          "in" : "query",
          "description" : "The voucher token (with or without mask)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "types",
          "in" : "query",
          "description" : "The ids or internal names of voucher types",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of matching vouchers. The `buyer` and `redeemer` fields will not be returned when searching for bought and redeemed vouchers (respectively), because they are always the user passed as parameter.\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/VoucherResult"
              }
            },
            "headers" : {
              "X-Total-Count" : {
                "type" : "integer",
                "description" : "The total number of results"
              },
              "X-Page-Size" : {
                "type" : "integer",
                "description" : "The maximum number of results per page"
              },
              "X-Current-Page" : {
                "type" : "integer",
                "description" : "The current page the results are in"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/vouchers/buy" : {
      "post" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Buys one or more vouchers for the given user",
        "description" : "Buys vouchers. If the payment type has custom fields, the values should be passed as well \n",
        "operationId" : "buyVouchers",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "confirmationPassword",
          "in" : "header",
          "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
          "required" : false,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "params",
          "description" : "The buy voucher parameters",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/BuyVoucher"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The identifiers of all generated vouchers\n",
            "schema" : {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "An error occurred while buying the voucher(s)",
            "schema" : {
              "$ref" : "#/definitions/BuyVoucherError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/vouchers/data-for-buy" : {
      "get" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Returns data for buying a voucher of a specified type",
        "description" : "Data for buying a voucher",
        "operationId" : "getVoucherDataForBuy",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "query",
          "description" : "Either the `id` or `internalName` of the voucher type\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for buying vouchers\n",
            "schema" : {
              "$ref" : "#/definitions/VoucherDataForBuy"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/vouchers/data-for-redeem" : {
      "get" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Returns initial data for redeeming vouchers",
        "description" : "Returns initial data for redeeming vouchers",
        "operationId" : "getVoucherInitialDataForRedeem",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for redeeming vouchers\n",
            "schema" : {
              "$ref" : "#/definitions/VoucherInitialDataForRedeem"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/vouchers/data-for-search" : {
      "get" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Returns data for searching vouchers an user has bought or redeemed",
        "description" : "Returns configuration data used to search vouchers the user has either bought (default) or redeemed (if `type` is `redeemed`)\n",
        "operationId" : "getUserVouchersDataForSearch",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "relation",
          "in" : "query",
          "description" : "Indicates the relation used to filter the vouchers. Possible values are: * bought: A voucher the user has bought * redeemed: A voucher the user has redeemed\n",
          "required" : false,
          "type" : "string",
          "enum" : [ "bought", "redeemed" ],
          "x-type" : "VoucherRelationEnum"
        } ],
        "responses" : {
          "200" : {
            "description" : "The configuration data for searching an user's vouchers\n",
            "schema" : {
              "$ref" : "#/definitions/UserVouchersDataForSearch"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/vouchers/{token}/data-for-redeem" : {
      "get" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Returns data for redeeming a voucher by token",
        "description" : "Data for redeeming a specific voucher",
        "operationId" : "getVoucherDataForRedeem",
        "parameters" : [ {
          "name" : "fields",
          "in" : "query",
          "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          },
          "collectionFormat" : "multi"
        }, {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "token",
          "in" : "path",
          "description" : "The voucher token to be redeemed",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The data for redeeming vouchers\n",
            "schema" : {
              "$ref" : "#/definitions/VoucherDataForRedeem"
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "Unexpected error",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    },
    "/{user}/vouchers/{token}/redeem" : {
      "post" : {
        "tags" : [ "Vouchers" ],
        "summary" : "Redeems a voucher for the given user",
        "description" : "Redeems a voucher \n",
        "operationId" : "redeemVoucher",
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "token",
          "in" : "path",
          "description" : "The voucher token to be redeemed",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "redeem",
          "description" : "Additional redeem data",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/RedeemVoucher"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "The identifiers of the voucher and the generated payment for redeem\n",
            "schema" : {
              "$ref" : "#/definitions/VoucherRedeemResult"
            },
            "headers" : {
              "Location" : {
                "type" : "string",
                "description" : "URL for viewing the redeemed voucher"
              }
            }
          },
          "401" : {
            "description" : "Unauthorized access. Missing or invalid crendentials supplied for such operation",
            "schema" : {
              "$ref" : "#/definitions/UnauthorizedError"
            }
          },
          "403" : {
            "description" : "Permission denied for such operation",
            "schema" : {
              "$ref" : "#/definitions/ForbiddenError"
            }
          },
          "404" : {
            "description" : "An expected data was not found",
            "schema" : {
              "$ref" : "#/definitions/NotFoundError"
            }
          },
          "500" : {
            "description" : "An error occurred while redeeming the voucher",
            "schema" : {
              "$ref" : "#/definitions/RedeemVoucherError"
            }
          }
        },
        "security" : [ {
          "basic" : [ ]
        }, {
          "session" : [ ]
        }, {
          "accessClient" : [ ]
        } ],
        "x-accepts" : "application/json",
        "x-contentType" : "application/json"
      }
    }
  },
  "securityDefinitions" : {
    "session" : {
      "type" : "apiKey",
      "name" : "Session-Token",
      "in" : "header"
    },
    "basic" : {
      "description" : "Stateless, the user and password are sent on every request\n",
      "type" : "basic"
    },
    "accessClient" : {
      "type" : "apiKey",
      "name" : "Access-Client-Token",
      "in" : "header"
    }
  },
  "definitions" : {
    "Entity" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Entity identifier"
        }
      },
      "description" : "Basic definition of a persistent entity"
    },
    "NamedEntity" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The entity name"
          }
        }
      } ],
      "description" : "Basic definition of a persistent entity which has a name"
    },
    "InternalNamedEntity" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "internalName" : {
            "type" : "string",
            "description" : "The entity internal name, which can be seen as an extra identifier\n"
          }
        }
      } ],
      "description" : "Basic definition of a persistent entity which has both a\nname and an internal name\n"
    },
    "VersionedEntity" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version stamp for the current object, used for optimistic locking.\nWhen saving, the same version as previously received needs to be passed\nback. If no one else has saved the object, the version will match and\nthe object will be updated. However, if someone other has saved the\nobject, the version will no longer match, and an error will be raised.\nThis is used to prevent multiple users (or processes) from updating the\nsame object and unwilingly overridding the property values, leading to\ndata loss. \n"
          }
        }
      } ],
      "description" : "Basic definition of a persistent entity which has a version"
    },
    "EntityReference" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object"
      } ],
      "description" : "Represents an entity that is being referenced from another one,\nwithout caring about the type of the referenced entity.\n"
    },
    "DatePeriod" : {
      "type" : "object",
      "properties" : {
        "begin" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The period begin date, if any. Generally a period without a begin date\ncan be seen as since all time.\n"
        },
        "end" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The period end date, if any. Generally a period without an end date\ncan be seen as without a limit.\n"
        }
      },
      "description" : "A period comprised of a begin and an end date"
    },
    "CustomFieldTypeEnum" : {
      "type" : "string",
      "description" : "The data type for the custom field Possible values are: * string: A single line string * text: A multi line string * richText: A multi line string formatted as HTML * singleSelection: A single enumerated value * multiSelection: Multiple enumerated values * dynamicSelection: Single selection based on options generated by a custom script * integer: An integer value * decimal: A decimal value * date: A date value * boolean: A boolean value * url: An URL * linkedEntity: Another entity. Uses the `linkedEntityType` to define which kind of entity is it\n",
      "enum" : [ "string", "text", "richText", "singleSelection", "multiSelection", "dynamicSelection", "integer", "decimal", "date", "boolean", "url", "linkedEntity" ]
    },
    "LinkedEntityTypeEnum" : {
      "type" : "string",
      "description" : "When the type is linkedEntity, indicates the entity type Possible values are: * user: An user * transaction: A transaction (payment, scheduled payment, payment request, etc) * transfer: A transfer * record: A record (user or system) * advertisement: An advertisement\n",
      "enum" : [ "user", "transaction", "transfer", "record", "advertisement" ]
    },
    "CustomFieldControlEnum" : {
      "type" : "string",
      "description" : "The UI control (widget) type that should be used to render this field for edit. Most notably, the types that can have distinct controls are singleSelection, that could be rendered as a single selection widget or radio button group, and multi selection, which could be rendered as a multi selection widget or a checkbox group. Possible values are: * text: A single line text * textarea: A multi line text * richEditor: An HTML editor * singleSelection: A single-selection field * radio: A radio button group * multiSelection: A multi-selection field * checkbox: A checkbox group * entitySelection: A widget to select a linked entity (for example, an auto-complete for users)\n",
      "enum" : [ "text", "textarea", "richEditor", "singleSelection", "radio", "multiSelection", "checkbox", "entitySelection" ]
    },
    "CustomFieldSizeEnum" : {
      "type" : "string",
      "description" : "The size of the widget that should be rendered Possible values are: * tiny: A very small widget * small: A small widget * medium: A medium widget * large: A large widget * full: The widget should occupy 100% of the available area\n",
      "enum" : [ "tiny", "small", "medium", "large", "full" ]
    },
    "CustomField" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "description" : "The data type for the custom field Possible values are: * string: A single line string * text: A multi line string * richText: A multi line string formatted as HTML * singleSelection: A single enumerated value * multiSelection: Multiple enumerated values * dynamicSelection: Single selection based on options generated by a custom script * integer: An integer value * decimal: A decimal value * date: A date value * boolean: A boolean value * url: An URL * linkedEntity: Another entity. Uses the `linkedEntityType` to define which kind of entity is it\n",
            "$ref" : "#/definitions/CustomFieldTypeEnum"
          },
          "linkedEntityType" : {
            "description" : "When the type is linkedEntity, indicates the entity type Possible values are: * user: An user * transaction: A transaction (payment, scheduled payment, payment request, etc) * transfer: A transfer * record: A record (user or system) * advertisement: An advertisement\n",
            "$ref" : "#/definitions/LinkedEntityTypeEnum"
          },
          "control" : {
            "description" : "The UI control (widget) type that should be used to render this field for edit. Most notably, the types that can have distinct controls are singleSelection, that could be rendered as a single selection widget or radio button group, and multi selection, which could be rendered as a multi selection widget or a checkbox group. Possible values are: * text: A single line text * textarea: A multi line text * richEditor: An HTML editor * singleSelection: A single-selection field * radio: A radio button group * multiSelection: A multi-selection field * checkbox: A checkbox group * entitySelection: A widget to select a linked entity (for example, an auto-complete for users)\n",
            "$ref" : "#/definitions/CustomFieldControlEnum"
          }
        }
      } ],
      "description" : "Contains reference to a custom field\n"
    },
    "CustomFieldDetailed" : {
      "allOf" : [ {
        "$ref" : "#/definitions/CustomField"
      }, {
        "type" : "object",
        "properties" : {
          "informationText" : {
            "type" : "string",
            "description" : "Additional text that can be shown to the user as a hint of this field\n"
          },
          "size" : {
            "description" : "The size of the widget that should be rendered Possible values are: * tiny: A very small widget * small: A small widget * medium: A medium widget * large: A large widget * full: The widget should occupy 100% of the available area\n",
            "$ref" : "#/definitions/CustomFieldSizeEnum"
          },
          "pattern" : {
            "type" : "string",
            "description" : "The mask to be applied to string values. Optional."
          },
          "required" : {
            "type" : "boolean",
            "description" : "Indicates whether this field is required"
          },
          "allSelectedLabel" : {
            "type" : "string",
            "description" : "The label to be shown when all values are selected for a \nmulti selection field.\n"
          },
          "defaultValue" : {
            "type" : "string",
            "description" : "The value that should be suggested as default. For multi selection\nwill be a comma-separated string with possible values ids or internal\nnames.\n"
          },
          "possibleValueCategories" : {
            "type" : "array",
            "description" : "Only applicable when the custom field is enumerated (single or multi\nselect). Contains the possible value categories.\n",
            "items" : {
              "$ref" : "#/definitions/EntityReference"
            }
          },
          "possibleValues" : {
            "type" : "array",
            "description" : "Only applicable when the custom field is enumerated (single or multi\nselection). Contains the possible values for selection.\nEach value may or may not have a category.\nWhen they have, it will be a string pointing to the internal name\n(if available) or id of the possible value category,\nwhich can be looked up in the categories property.\n",
            "items" : {
              "$ref" : "#/definitions/CustomFieldPossibleValue"
            }
          },
          "dynamicValues" : {
            "type" : "array",
            "description" : "Only applicable when the custom field is dynamic selection.\nContains the script-generated possible values.\n",
            "items" : {
              "$ref" : "#/definitions/CustomFieldDynamicValue"
            }
          }
        }
      } ],
      "description" : "Contains all information needed to render a widget for a custom field value\n"
    },
    "CustomFieldValue" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "field" : {
            "description" : "The custom field reference",
            "$ref" : "#/definitions/CustomField"
          },
          "stringValue" : {
            "type" : "string",
            "description" : "The field value if the field type is either `string`, `text`, `richText` or `url`.\n"
          },
          "dateValue" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The field value if the field type is `date`.\n"
          },
          "booleanValue" : {
            "type" : "boolean",
            "description" : "The field value if the field type is `bool`.\n"
          },
          "integerValue" : {
            "type" : "integer",
            "description" : "The field value if the field type is `integer`.\n"
          },
          "decimalValue" : {
            "type" : "string",
            "format" : "number",
            "description" : "The field value if the field type is `decimal`.\n"
          },
          "enumeratedValues" : {
            "type" : "array",
            "description" : "The field value if the field type is either `singleSelection` or `multiSelection`. For single selections will either be an empty array or an array with a single elemenet\n",
            "items" : {
              "$ref" : "#/definitions/CustomFieldPossibleValue"
            }
          },
          "linkedEntityValue" : {
            "description" : "The field value if the field type is `linkedEntity`.\n",
            "$ref" : "#/definitions/EntityReference"
          },
          "dynamicValue" : {
            "description" : "The field value if the field type is `dynamicSelection`.\n",
            "$ref" : "#/definitions/CustomFieldDynamicValue"
          }
        }
      } ],
      "description" : "Holds detailed information about a custom field value. The actual value should be read from a property depending on the field type. If the type is either `string`, `text`, `richText` or `url`, the property containing the value is `stringValue`. If the type is `integer`, the property is `integerValue`. If `decimal`, `decimalValue`. If `date`, `dateValue`. If `bool`, `booleanValue`. If either `singleSelection` or `multiSelection`, `possibleValues`. If `dynamicSelection`, `dynamicValue`. Finally, if `linkedEntity`, `linkedEntityValue`.\n \n"
    },
    "CustomFieldPossibleValue" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "value" : {
            "type" : "string",
            "description" : "The display value"
          },
          "default" : {
            "type" : "boolean",
            "description" : "Indicates if this possible value is the default one."
          },
          "internalName" : {
            "type" : "string",
            "description" : "The entity internal name, which can be seen as an extra identifier\n"
          },
          "category" : {
            "description" : "The internal name (if available) or id of the possible value\ncategory. Optional, and never used if custom field type is\ndynamic selection.\n",
            "$ref" : "#/definitions/EntityReference"
          }
        }
      } ],
      "description" : "Represents a single possible value of an enumerated (single or multi\nselection) custom field\n"
    },
    "CustomFieldDynamicValue" : {
      "type" : "object",
      "properties" : {
        "value" : {
          "type" : "string",
          "description" : "The internal value"
        },
        "label" : {
          "type" : "string",
          "description" : "The display label"
        },
        "defaultValue" : {
          "type" : "boolean",
          "description" : "The value that should be suggested as default."
        }
      },
      "description" : "Represents a single possible value of a dynamic custom field\n"
    },
    "TimeFieldEnum" : {
      "type" : "string",
      "description" : "Determines a time field, such as seconds, hours or months Possible values are: * millis: Millisecond(s) * seconds: Second(s) * minutes: Minute(s) * hours: Hour(s) * days: Day(s) * weeks: Week(s) * months: Month(s) * years: Year(s)\n",
      "enum" : [ "millis", "seconds", "minutes", "hours", "days", "weeks", "months", "years" ]
    },
    "TimeInterval" : {
      "type" : "object",
      "properties" : {
        "amount" : {
          "type" : "integer",
          "description" : "The amount of time units"
        },
        "field" : {
          "description" : "Determines a time field, such as seconds, hours or months Possible values are: * millis: Millisecond(s) * seconds: Second(s) * minutes: Minute(s) * hours: Hour(s) * days: Day(s) * weeks: Week(s) * months: Month(s) * years: Year(s)\n",
          "$ref" : "#/definitions/TimeFieldEnum"
        }
      },
      "description" : "Represents a time interval such as 1 month, 3 weeks, 12 months, etc.\n"
    },
    "PreselectedPeriod" : {
      "type" : "object",
      "properties" : {
        "defaultOption" : {
          "type" : "boolean",
          "description" : "Indicates whether this period should be pre-selected"
        },
        "name" : {
          "type" : "string",
          "description" : "The period display name"
        },
        "begin" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The period begin date"
        },
        "end" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The period begin date"
        }
      },
      "description" : "Represents a pre-calculated date period\n"
    },
    "DateFormatEnum" : {
      "type" : "string",
      "description" : "The format for dates Possible values are: * dmySlash: DD/MM/YYYY * dmyDash: DD-MM-YYYY * dmyPeriod: DD.MM.YYYY * mdySlash: MM/DD/YYYY * mdyDash: MM-DD-YYYY * mdyPeriod: MM.DD.YYYY * ymdSlash: YYYY/MM/DD * ymdDash: YYYY-MM-DD * ymdPeriod: YYYY.MM.DD\n",
      "enum" : [ "dmySlash", "dmyDash", "dmyPeriod", "mdySlash", "mdyDash", "mdyPeriod", "ymdSlash", "ymdDash", "ymdPeriod" ]
    },
    "TimeFormatEnum" : {
      "type" : "string",
      "description" : "The format for times Possible values are: * h24: 24-hour * h12: 12-hour with AM/PM indicator\n",
      "enum" : [ "h24", "h12" ]
    },
    "NumberFormatEnum" : {
      "type" : "string",
      "description" : "The format for numbers Possible values are: * commaAsDecimal: 9.999,99 * periodAsDecimal: 9,999.99\n",
      "enum" : [ "commaAsDecimal", "periodAsDecimal" ]
    },
    "WeekDayEnum" : {
      "type" : "string",
      "description" : "The days of the week Possible values are: * sun: Sunday * mon: Monday * tue: Tuesday * wed: Wednesday * thu: Thursday * fri: Friday * sat: Saturday\n",
      "enum" : [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ]
    },
    "OutboundSmsStatusEnum" : {
      "type" : "string",
      "description" : "Statuses for an outbound SMS message sent to an user. Possible values are: * success: The SMS message was successfully sent * invalid: The parameters for sending an SMS message were invalid * maxMessagesReached: The maximum SMS messages for the user (or guest) have been reached * gatewayUreachable: Network problem, or gateway server down * timeout: Timeout while connecting or waiting for a gateway server reply * rejected: The gateway has rejected the SMS message * unexpected: An unexpected error has occurred\n",
      "enum" : [ "success", "invalid", "maxMessagesReached", "gatewayUreachable", "timeout", "rejected", "unexpected" ]
    },
    "NotificationLevelEnum" : {
      "type" : "string",
      "description" : "Defines the severity level of a notification shown to users Possible values are: * information: A general informative message * warning: A warning message, when special caution is required * error: An error message, when some operation went wrong  \n",
      "enum" : [ "information", "warning", "error" ]
    },
    "SendMediumEnum" : {
      "type" : "string",
      "description" : "Mediums used to send information to the user (e.g: a confirmation code) Possible values are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)\n",
      "enum" : [ "email", "sms" ]
    },
    "ImageSizeEnum" : {
      "type" : "string",
      "description" : "The possible sizes of images. The actual pixel size depends on the configuration in Cyclos Possible values are: * small: Small thumbnail * medium: Medium thumbnail * large: Full image size\n",
      "enum" : [ "small", "medium", "large" ]
    },
    "AvailabilityEnum" : {
      "type" : "string",
      "description" : "Determines the availability of a data Possible values are: * disabled: The data is disabled * optional: The data is enabled and optional * required: The data is enabled and required\n",
      "enum" : [ "disabled", "optional", "required" ]
    },
    "ErrorKind" : {
      "type" : "string",
      "description" : "Error types associated to the HTTP Status 500 Possible values are: * payment: An error has occurred when making a payment * pos: An error has occurred when receiving a payment on a POS operation * buyVoucher: An error has occurred when buying a voucher  * redeemVoucher: An error has occurred when redeeming a voucher  * otp: An error has occurred requesting an OTP * initializeNfc: An error has occurred when initializing a NFC token * personalizeNfc: An error has occurred when personalizing a NFC token * nfcAuth: An error has occurred when making an external NFC authentication * general: An unexpected error has occurred\n",
      "enum" : [ "payment", "pos", "buyVoucher", "redeemVoucher", "otp", "initializeNfc", "personalizeNfc", "nfcAuth", "general" ]
    },
    "Error" : {
      "type" : "object",
      "required" : [ "exceptionType" ],
      "properties" : {
        "kind" : {
          "description" : "Error types associated to the HTTP Status 500 Possible values are: * payment: An error has occurred when making a payment * pos: An error has occurred when receiving a payment on a POS operation * buyVoucher: An error has occurred when buying a voucher  * redeemVoucher: An error has occurred when redeeming a voucher  * otp: An error has occurred requesting an OTP * initializeNfc: An error has occurred when initializing a NFC token * personalizeNfc: An error has occurred when personalizing a NFC token * nfcAuth: An error has occurred when making an external NFC authentication * general: An unexpected error has occurred\n",
          "$ref" : "#/definitions/ErrorKind"
        },
        "exceptionType" : {
          "type" : "string",
          "description" : "The server exception class name (not intended to be shown to \nfinal users. Only for logging purposes)\n"
        },
        "exceptionMessage" : {
          "type" : "string",
          "description" : "The server exception message (not intended to be shown to \nfinal users. Only for logging purposes)\n"
        }
      },
      "description" : "An error that happened during the request processing"
    },
    "UnauthorizedErrorCode" : {
      "type" : "string",
      "description" : "Error codes for 401 Unauthorized HTTP status.  Possible values are: * missingAuthorization: Attempt to access an operation as guest, but the operation requires authentication * invalidAccessClient: The access client used for access is invalid * login: Either user identification (principal) or password are invalid. May have additional information, such as the user / password status * loggedOut: The session token used for access is invalid * remoteAddressBlocked: The IP address being used for access has been blocked by exceeding tries with invalid users * unauthorizedAddress: The user cannot access the system using an IP address that is not white-listed * unauthorizedUrl: The user's configuration demands access using a specific URL, and this access is being done using another one * invalidChannelUsage: Attempt to login on a stateless-only channel, or use stateless in a stateful-only channel, or invoke as guest in a channel configuration which is only for users * invalidNetwork: Attempt to access a network that has been disabled\n",
      "enum" : [ "missingAuthorization", "invalidAccessClient", "login", "loggedOut", "remoteAddressBlocked", "unauthorizedAddress", "unauthorizedUrl", "invalidChannelUsage", "invalidNetwork" ]
    },
    "UnauthorizedError" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "Error codes for 401 Unauthorized HTTP status.  Possible values are: * missingAuthorization: Attempt to access an operation as guest, but the operation requires authentication * invalidAccessClient: The access client used for access is invalid * login: Either user identification (principal) or password are invalid. May have additional information, such as the user / password status * loggedOut: The session token used for access is invalid * remoteAddressBlocked: The IP address being used for access has been blocked by exceeding tries with invalid users * unauthorizedAddress: The user cannot access the system using an IP address that is not white-listed * unauthorizedUrl: The user's configuration demands access using a specific URL, and this access is being done using another one * invalidChannelUsage: Attempt to login on a stateless-only channel, or use stateless in a stateful-only channel, or invoke as guest in a channel configuration which is only for users * invalidNetwork: Attempt to access a network that has been disabled\n",
          "$ref" : "#/definitions/UnauthorizedErrorCode"
        },
        "userStatus" : {
          "description" : "May only returned when `code` is `login`. Possible values are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * removed: The user was permanently removed. It's profile is kept for historical purposes. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users.\n",
          "$ref" : "#/definitions/UserStatusEnum"
        },
        "passwordStatus" : {
          "description" : "May only returned when `code` is `login`.  Possible values are: * active: The password is active and valid * neverCreated: The password has never been created for the user * pending: The password was manually allowed (by admins) for the user to generate it, but it was not yet generated (never used for manual passwords) * disabled: The password has been manually disabled * reset: The password has been reset (can be used for login but must then be changed) * temporarilyBlocked: The password is temporarily blocked by exceeding the maximum attempts * indefinitelyBlocked: The password is blocked by exceeding the maximum attempts until it is manually unblocked * expired: The password is expired\n",
          "$ref" : "#/definitions/PasswordStatusEnum"
        }
      },
      "description" : "Error returned when a HTTP status code 401 occurs"
    },
    "ForbiddenErrorCode" : {
      "type" : "string",
      "description" : "Error codes for 403 Forbidden HTTP status.  Possible values are: * expiredPassword: The password being used has expired * illegalAction: Attempt to perform an action that is not allowed on this context * inaccessibleChannel: This channel cannot be accessed by the user  * invalidPassword: The password being used is invalid (normally the confirmation password) * operatorWithPendingAgreements: The operator cannot access because his owner member has pending agreements * permissionDenied: The operation was denied because a required permission was not granted * temporarilyBlocked: The password was temporarily blocked by exceeding the allowed attempts * indefinitelyBlocked: The password was indefinitely blocked by exceeding the allowed attempts \n",
      "enum" : [ "expiredPassword", "illegalAction", "inaccessibleChannel", "invalidPassword", "operatorWithPendingAgreements", "permissionDenied", "temporarilyBlocked", "indefinitelyBlocked" ]
    },
    "ForbiddenError" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "Error codes for 403 Forbidden HTTP status.  Possible values are: * expiredPassword: The password being used has expired * illegalAction: Attempt to perform an action that is not allowed on this context * inaccessibleChannel: This channel cannot be accessed by the user  * invalidPassword: The password being used is invalid (normally the confirmation password) * operatorWithPendingAgreements: The operator cannot access because his owner member has pending agreements * permissionDenied: The operation was denied because a required permission was not granted * temporarilyBlocked: The password was temporarily blocked by exceeding the allowed attempts * indefinitelyBlocked: The password was indefinitely blocked by exceeding the allowed attempts \n",
          "$ref" : "#/definitions/ForbiddenErrorCode"
        }
      },
      "description" : "Error returned when a HTTP status code 403 occurs"
    },
    "NotFoundError" : {
      "type" : "object",
      "properties" : {
        "entityType" : {
          "type" : "string",
          "description" : "The name of the entity being attempted, but not found"
        },
        "key" : {
          "type" : "string",
          "description" : "The identifier used to attempt to find the entity,\nsuch as id, internal name, principal, etc  \n"
        }
      },
      "description" : "Error returned when some expected data was not found"
    },
    "InputErrorCode" : {
      "type" : "string",
      "description" : "Error codes for 422 Unprocessable entity HTTP status. It means there was an error with the input sent to the operation.  Possible values are: * validation: One or more of the fields sent contains invalid values * maxItems: There was an attempt to create an item, but the maximum number of allowed items was exceeded * queryParse: A full-text query keywords contained an invalid text * dataConversion: Some data conversion has failed. For example, when sending a date with an invalid format \n",
      "enum" : [ "validation", "maxItems", "queryParse", "dataConversion" ]
    },
    "InputError" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "Error codes for 422 Unprocessable entity HTTP status. It means there was an error with the input sent to the operation.  Possible values are: * validation: One or more of the fields sent contains invalid values * maxItems: There was an attempt to create an item, but the maximum number of allowed items was exceeded * queryParse: A full-text query keywords contained an invalid text * dataConversion: Some data conversion has failed. For example, when sending a date with an invalid format \n",
          "$ref" : "#/definitions/InputErrorCode"
        },
        "generalErrors" : {
          "type" : "array",
          "description" : "A list of errors that cannot be attributed to a specific property. Only returned if `code` is `validation`.\n",
          "items" : {
            "type" : "string"
          }
        },
        "propertyErrors" : {
          "type" : "object",
          "description" : "An object keyed by property name, whose values are lists of errors for that property. Only returned if `code` is `validation`.\n",
          "additionalProperties" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "customFieldErrors" : {
          "type" : "object",
          "description" : "An object keyed by custom field internal name, whose values are lists of errors for that custom field. Only returned if `code` is `validation`.\n",
          "additionalProperties" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "maxItems" : {
          "type" : "integer",
          "description" : "The maximum allowed items. Only returned if `code` is `maxItems`.\n"
        },
        "value" : {
          "type" : "string",
          "description" : "The value that failed conversion to the expected data type, or the original full-text query keywords that failed parsing. Only returned if `code` is either `dataConversion` or `queryParse`.\n"
        }
      },
      "description" : "Error returned when some input data failed validation"
    },
    "ConflictErrorCode" : {
      "type" : "string",
      "description" : "Error codes for 409 Conflict entity HTTP status  Possible values are: * staleEntity: Failure in the optimistic lock. It means some entity was fetched for editing by 2 clients. Then they both saved it. The first one is successful, but the second one will fail. If you get this error, make sure the `version` field is being sent with the correct value, as fetched from the server. * constraintViolatedOnRemove: An attempt to remove some entity has failed, probably because that entity is in use, that is, is being referenced by some other entity. \n",
      "enum" : [ "staleEntity", "constraintViolatedOnRemove" ]
    },
    "ConflictError" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "Error codes for 409 Conflict entity HTTP status  Possible values are: * staleEntity: Failure in the optimistic lock. It means some entity was fetched for editing by 2 clients. Then they both saved it. The first one is successful, but the second one will fail. If you get this error, make sure the `version` field is being sent with the correct value, as fetched from the server. * constraintViolatedOnRemove: An attempt to remove some entity has failed, probably because that entity is in use, that is, is being referenced by some other entity. \n",
          "$ref" : "#/definitions/ConflictErrorCode"
        }
      },
      "description" : "Error returned when there was a conflict with some expected status vs the actual database status"
    },
    "BadRequestErrorCode" : {
      "type" : "string",
      "description" : "Error codes for 400 Bad request HTTP status  Possible values are: * json: Error in the JSON format * general: Bad request format\n",
      "enum" : [ "json", "general" ]
    },
    "BadRequestError" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "description" : "Error codes for 400 Bad request HTTP status  Possible values are: * json: Error in the JSON format * general: Bad request format\n",
          "$ref" : "#/definitions/BadRequestErrorCode"
        },
        "message" : {
          "type" : "string",
          "description" : "A (technical) message explaining the problem"
        },
        "line" : {
          "type" : "integer",
          "description" : "The request body line that shows the problem"
        },
        "column" : {
          "type" : "integer",
          "description" : "The request body column that shows the problem"
        }
      },
      "description" : "Error returned when the request format / body is not in the expected format"
    },
    "CaptchaResponse" : {
      "type" : "object",
      "properties" : {
        "challenge" : {
          "type" : "string",
          "description" : "The captcha challenge identifier"
        },
        "response" : {
          "type" : "string",
          "description" : "The captcha response, as informed by the user"
        }
      },
      "description" : "Data sent to the server containing the response of an user to a captcha\nchallenge\n"
    },
    "RoleEnum" : {
      "type" : "string",
      "description" : "The main role the user has. Possible values are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data.\n",
      "enum" : [ "administrator", "broker", "member", "operator" ]
    },
    "CaptchaProviderEnum" : {
      "type" : "string",
      "description" : "Possibles captcha provider Possible values are: * internal: Default provider using images\n",
      "enum" : [ "internal" ]
    },
    "TokenTypeEnum" : {
      "type" : "string",
      "description" : "The kind of a token principal type. Possible values are: * nfcTag: A NFC tag/card  * nfcDevice: A device (e.g. cell phone) with support for NFC * barcode: A barcode with the token * swipe: A swipe/magnetic card containing the token * other: Any other type containing a token\n",
      "enum" : [ "nfcTag", "nfcDevice", "barcode", "swipe", "other" ]
    },
    "PrincipalTypeKind" : {
      "type" : "string",
      "description" : "The kind of a principal type (user identification method) Possible values are: * username: The username identifies the user * email: The email identifies the user * mobilePhone: A mobile phone number identifies the user * accountNumber: An account number identifies the user * customField: A unique custom field identifies the user  * token: A token identifies the user * accessClient: An access client token (remote application) identifies the user \n",
      "enum" : [ "username", "email", "mobilePhone", "accountNumber", "customField", "token", "accessClient" ]
    },
    "OtpErrorCode" : {
      "type" : "string",
      "description" : "Application-specific error codes for an OTP error. Possible values are: * errorSendingSms: An error has occurred trying to send the OTP through SMS. * unexpected: An unexpected error has occurred. \n",
      "enum" : [ "errorSendingSms", "unexpected" ]
    },
    "DataForLogin" : {
      "type" : "object",
      "properties" : {
        "principalTypes" : {
          "type" : "array",
          "description" : "The identification methods accepted for login",
          "items" : {
            "$ref" : "#/definitions/PrincipalTypeInput"
          }
        },
        "defaultPrincipalType" : {
          "type" : "string",
          "description" : "The internal name of the identification method that is marked as\ndefault for the current channel configuration. This is optional, and\nif there is no default, all possible identification methods will be\nattempted for login.\n"
        },
        "loginPasswordInput" : {
          "description" : "Contains data for the password used on login",
          "$ref" : "#/definitions/PasswordInput"
        },
        "forgotPasswordCaptchaProvider" : {
          "description" : "If the forgot password request requires a captcha, will be the  provider used to request one. Otherwise will be null. Possible values are: * internal: Default provider using images\n",
          "$ref" : "#/definitions/CaptchaProviderEnum"
        },
        "forgotPasswordMediums" : {
          "type" : "array",
          "description" : "If the forgot password request is enabled, returns the mediums the user can choose to receive the confirmation key or code.  If nothing is returned, forgot password is not enabled. Possibles values for each array element are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)\n",
          "items" : {
            "$ref" : "#/definitions/SendMediumEnum"
          }
        }
      },
      "description" : "Contains data useful for a login form, as well as forgot password\n"
    },
    "Auth" : {
      "type" : "object",
      "properties" : {
        "user" : {
          "description" : "The authenticated user",
          "$ref" : "#/definitions/User"
        },
        "global" : {
          "type" : "boolean",
          "description" : "Indicates whether this user belongs to global mode"
        },
        "role" : {
          "description" : "The main role the user has. Possible values are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data.\n",
          "$ref" : "#/definitions/RoleEnum"
        },
        "systemAdministrator" : {
          "type" : "boolean",
          "description" : "Indicates whether this user is a system administrator, that is, either\nbelongs to the global system administrators group or to the network\nsystem administrators group\n"
        },
        "aliasOperator" : {
          "type" : "boolean",
          "description" : "Indicates whether this user is an operator which is an alias of his\nowner member, that is, has all member permissions, and is not\nrestricted to an operator group.\n"
        },
        "permissions" : {
          "description" : "The granted permissions for the authenticated user or guest",
          "$ref" : "#/definitions/Permissions"
        },
        "sessionToken" : {
          "type" : "string",
          "description" : "A token that must be passed in on the Session-Token header on\nsubsequent requests instead of the login name and password.\n"
        },
        "accessClient" : {
          "description" : "Only returned when authenticated as access client, contains \ninformation about it\n",
          "$ref" : "#/definitions/EntityReference"
        },
        "principalType" : {
          "description" : "Returns a reference to the principal type used for authentication.\nMay be some of the built-in types (login name, e-mail, mobile phone or\naccount number), a profile field, a token type or an access client type\n",
          "$ref" : "#/definitions/EntityReference"
        },
        "principal" : {
          "type" : "string",
          "description" : "The principal (user identification) used on authentication. Can be the\nvalue of the login name, e-mail, account number, custom field or token\nused on authentication or at the moment of login. Is not returned when\nthe authentication was performed via access client.\n"
        },
        "expiredPassword" : {
          "type" : "boolean",
          "description" : "Returns whether the current access password is expired.\nIf so, the user will have to change the password,\nor all other actions will be denied.\n"
        },
        "pendingAgreements" : {
          "type" : "boolean",
          "description" : "Returns whether the current user has some agreements pending accept.\nIf so, a call to GET /agreements/pending should be performed to get\nthe content of the pending agreements, and then a POST \n/agreements/pending{id_or_internal_name} to accept each agreement.\n"
        }
      },
      "description" : "Contains relevant information for the authenticated user and his granted\npermissions. \n"
    },
    "Permissions" : {
      "type" : "object",
      "properties" : {
        "users" : {
          "description" : "Permissions over other users",
          "$ref" : "#/definitions/UsersPermissions"
        },
        "accounts" : {
          "type" : "array",
          "description" : "Permissions over each owned account",
          "items" : {
            "$ref" : "#/definitions/AccountPermissions"
          }
        },
        "marketplace" : {
          "description" : "Permissions for marketplace",
          "$ref" : "#/definitions/MarketplacePermissions"
        },
        "userRecords" : {
          "type" : "array",
          "description" : "List of user record types the user has access",
          "items" : {
            "$ref" : "#/definitions/RecordType"
          }
        },
        "systemRecords" : {
          "type" : "array",
          "description" : "List of system record types the user has access",
          "items" : {
            "$ref" : "#/definitions/RecordType"
          }
        }
      },
      "description" : "Contains all permissions and configurations an user or guest can perform\nin the REST API\n"
    },
    "UsersPermissions" : {
      "type" : "object",
      "properties" : {
        "search" : {
          "type" : "boolean",
          "description" : "Permission to search other users"
        },
        "viewProfile" : {
          "type" : "boolean",
          "description" : "General permission to view the profile of other users. A fine-grained\npermission over specific groups can be configured. When attempting to\nview the profile of an user without permission, only very basic\ninformation is returned instead.\n"
        },
        "map" : {
          "type" : "boolean",
          "description" : "Permission to view the user map directory"
        },
        "contacts" : {
          "type" : "boolean",
          "description" : "Permission to own a contact list"
        }
      },
      "description" : "Permissions over other users"
    },
    "AccountPermissions" : {
      "type" : "object",
      "properties" : {
        "account" : {
          "description" : "The account",
          "$ref" : "#/definitions/AccountWithCurrency"
        },
        "systemPayments" : {
          "type" : "array",
          "description" : "Payment types allowed to be performed to system accounts",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "userPayments" : {
          "type" : "array",
          "description" : "Payment types allowed to be performed to other users",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "selfPayments" : {
          "type" : "array",
          "description" : "Payment types allowed to be performed to other self accounts",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "posPayments" : {
          "type" : "array",
          "description" : "Payment types allowed to be used on POS (receive payments\nfrom other users)\n",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        }
      },
      "description" : "Permissions over an account"
    },
    "MarketplacePermissions" : {
      "type" : "object",
      "properties" : {
        "search" : {
          "type" : "boolean",
          "description" : "Permission to search the marketplace"
        },
        "ownAdvertisements" : {
          "type" : "boolean",
          "description" : "Permission to manage own simple advertisements"
        }
      },
      "description" : "Permissions for the marketplace"
    },
    "PrincipalType" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "The kind of this principal type",
            "$ref" : "#/definitions/PrincipalTypeKind"
          }
        }
      } ],
      "description" : "A reference to a principal type"
    },
    "PrincipalTypeInput" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PrincipalType"
      }, {
        "type" : "object",
        "properties" : {
          "customField" : {
            "description" : "If this principal is based on a custom field, holds its definition\n",
            "$ref" : "#/definitions/CustomFieldDetailed"
          },
          "tokenType" : {
            "description" : "If this principal is a token, contains its type Possible values are: * nfcTag: A NFC tag/card  * nfcDevice: A device (e.g. cell phone) with support for NFC * barcode: A barcode with the token * swipe: A swipe/magnetic card containing the token * other: Any other type containing a token\n",
            "$ref" : "#/definitions/TokenTypeEnum"
          },
          "mask" : {
            "type" : "string",
            "description" : "If this principal is either a token or account number, holds the\n(optional) mask which clients can use to input the value.\n"
          },
          "allowManualInput" : {
            "type" : "boolean",
            "description" : "Specifies if the principal type allows enter manually the token value.\n"
          },
          "example" : {
            "type" : "string",
            "description" : "If this principal is mobile phone, holds an example number.\n"
          }
        }
      } ],
      "description" : "Definition on how a principal value can be entered by the user"
    },
    "PasswordInput" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "inputMethod" : {
            "description" : "The explanation for the value that should be sent for `virtualKeyboard`  cases is given above, in the description of this type. Possible values are: * textBox: A simple string should be requested * virtualKeyboard: A series of buttons should be presented to allow enter the password.\n",
            "$ref" : "#/definitions/PasswordInputMethodEnum"
          },
          "mode" : {
            "description" : "Indicates how a password is handled Possible values are: * manual: Passwords are manually typed by users * generated: Passwords are always generated * otp: One Time Passwords. are always generated and can be used only once * script: Passwords are not stored in Cyclos, but handed-over for a script to verify them. \n  Is normally used to implement single-sign-on with other apps.\n",
            "$ref" : "#/definitions/PasswordModeEnum"
          },
          "hasActivePassword" : {
            "type" : "boolean",
            "description" : "Only returned when there is an authenticated user (not for login).\nDescribes whether the user has created a password of this type.\nIf not, a proper message can be shown to the user indicating that\nthis password needs to be created.\n"
          },
          "confirmationPasswordOncePerSession" : {
            "type" : "boolean",
            "description" : "Only returned when there is an authenticated user (not for login).\nDetermines whether this password, when used as confirmation, should\nbe requested only once until the user logs out.\n"
          },
          "minLength" : {
            "type" : "integer",
            "description" : "For text passwords, the minimum password length"
          },
          "maxLength" : {
            "type" : "integer",
            "description" : "For text passwords, the maximum password length"
          },
          "otpSendMediums" : {
            "type" : "array",
            "description" : "Only for `otp`, the available mediums for the password to be sent Possibles values for each array element are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)\n",
            "items" : {
              "$ref" : "#/definitions/SendMediumEnum"
            }
          },
          "numberOfButtons" : {
            "type" : "integer",
            "description" : "Only for `virtualKeyboard`, is the number of buttons to be displayed\n"
          },
          "buttonsPerRow" : {
            "type" : "integer",
            "description" : "Only for `virtualKeyboard`, is the number of buttons that should be\ndisplayed on each row\n"
          },
          "buttons" : {
            "type" : "array",
            "description" : "Only for `virtualKeyboard`, contains the sequences of buttons that\nshould be displayed for the user. The explanation for the value that\nshould be sent on virtual keyboard mode is shown above, in the\ndescription of this type.\n",
            "items" : {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            }
          }
        }
      } ],
      "description" : "Contains all information for a password entry. Passwords in Cyclos may be entered as regular texts or as virtual keyboards. For `virtualKeyboard`, a number of information is sent, such as an unique id, the number of buttons to be displayed, the number of rows that should visually hold those buttons, the sequences of characters that should be displayed on each button. When sending the value of a password of type virtual keyboard, unique id should be sent, together with the entire sequence for each button, all separated by pipes. So, suppose a very simple (and weakly configured) example where the id is `987654321` and the sequences are: `[[\"abc\", \"def\", \"fgh\"], [\"ijk\", \"lmn\", \"opq\"]]`. This describes 2 sequences of 3 buttons each. First, the buttons with the options `abc`, `def` and `fgh` should be shown. Suppose the user chooses the second one. Then the button labels should be changed to `ijk`, `lmn` and `opq`. Now the user picks the first one. The value sent to the server should be `987654321|def|ijk`. \n"
    },
    "OtpError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Error"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Application-specific error codes for an OTP error. Possible values are: * errorSendingSms: An error has occurred trying to send the OTP through SMS. * unexpected: An unexpected error has occurred. \n",
            "$ref" : "#/definitions/OtpErrorCode"
          },
          "smsStatus" : {
            "description" : "Only if code is `errorSendingSms` Possible values are: * success: The SMS message was successfully sent * invalid: The parameters for sending an SMS message were invalid * maxMessagesReached: The maximum SMS messages for the user (or guest) have been reached * gatewayUreachable: Network problem, or gateway server down * timeout: Timeout while connecting or waiting for a gateway server reply * rejected: The gateway has rejected the SMS message * unexpected: An unexpected error has occurred\n",
            "$ref" : "#/definitions/OutboundSmsStatusEnum"
          }
        }
      } ],
      "description" : "Error when requesting a new One-time-Password (OTP)"
    },
    "ForgottenPasswordRequest" : {
      "type" : "object",
      "properties" : {
        "user" : {
          "type" : "string",
          "description" : "An identification method for the user. Allows the same identification\nmethods (principal types) as the login, plus e-mail.\n"
        },
        "captcha" : {
          "description" : "The captcha response required when something is returned in `DataForLogin.forgotPasswordCaptchaProvider`.",
          "$ref" : "#/definitions/CaptchaResponse"
        }
      },
      "description" : "Definitions to request a forgotten password reset"
    },
    "DataForChangeForgottenPassword" : {
      "type" : "object",
      "properties" : {
        "generated" : {
          "type" : "boolean",
          "description" : "Indicates whether the password that is being affected is generated (when `true`) or manual (when `false`).\n"
        },
        "securityQuestion" : {
          "type" : "string",
          "description" : "If configured in Cyclos, and defined by the user, will be the security question that needs to be answered in order to complete the forgotten password reset request.\n"
        }
      },
      "description" : "Definitions for an user to confirm a forgotten password request"
    },
    "ChangeForgottenPassword" : {
      "type" : "object",
      "properties" : {
        "key" : {
          "type" : "string",
          "description" : "The key received by e-mail on the forgotten password reset request\n"
        },
        "newPassword" : {
          "type" : "string",
          "description" : "The new password value. Required when the password is manual.\n"
        },
        "securityAnswer" : {
          "type" : "string",
          "description" : "When a security question is asked, this is the answer, and is required.\n"
        }
      },
      "description" : "The parameters for confirming a forgotten password reset"
    },
    "Principal" : {
      "type" : "object",
      "properties" : {
        "value" : {
          "type" : "string",
          "description" : "This is the value which is used to identify the user"
        },
        "type" : {
          "description" : "This is the type of the user identification which can be a token, profile field, etc",
          "$ref" : "#/definitions/EntityReference"
        }
      },
      "description" : "Represents an user identification method of an user"
    },
    "UserStatusEnum" : {
      "type" : "string",
      "description" : "The possible statuses for an user Possible values are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * removed: The user was permanently removed. It's profile is kept for historical purposes. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users.\n",
      "enum" : [ "active", "blocked", "disabled", "removed", "pending" ]
    },
    "UserOrderByEnum" : {
      "type" : "string",
      "description" : "Possible options for ordering the results of an user search. Possible values are: * relevance: This is the default if keywords are used. Best matching users come first. * creationDate: Newly registered users are returned first. * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Users will be randomly returned\n",
      "enum" : [ "relevance", "creationDate", "alphabeticallyAsc", "alphabeticallyDesc", "distance", "random" ]
    },
    "IUser" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The user's full name"
        },
        "username" : {
          "type" : "string",
          "description" : "The user's login name"
        },
        "email" : {
          "type" : "string",
          "description" : "The user's e-mail"
        }
      },
      "description" : "Interface containing the common user properties",
      "x-interface" : true
    },
    "User" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "display" : {
            "type" : "string",
            "description" : "Contains the formatting of the user according to the \nconfiguration. Is only returned if no profile fields are marked to\nreturn in user list\n"
          },
          "shortDisplay" : {
            "type" : "string",
            "description" : "Contains the short formatting of the user according to\nthe configuration. Is only returned if no profile fields are marked\nto return in user list\n"
          },
          "image" : {
            "description" : "The primary user profile image",
            "$ref" : "#/definitions/Image"
          },
          "user" : {
            "description" : "Is the operator owner, only returned if this user represents an\noperator. Even so, in some cases, like searching for operators of\na specific user, this field may not be returned.\n",
            "$ref" : "#/definitions/User"
          }
        }
      } ],
      "description" : "Basic representation of an user (both admin and regular)"
    },
    "UserResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/User"
      }, {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The user's full name"
          },
          "username" : {
            "type" : "string",
            "description" : "The user's login name"
          },
          "email" : {
            "type" : "string",
            "description" : "The user's e-mail"
          },
          "address" : {
            "description" : "Address to be placed on map. Is only returned when the search result type is `map`.\n",
            "$ref" : "#/definitions/Address"
          },
          "distance" : {
            "type" : "number",
            "format" : "double",
            "description" : "Only returned when there is a base location to calculate the\ndistance from. The unit (kilometers or miles) depends on\nconfiguration.\n"
          },
          "customValues" : {
            "type" : "object",
            "description" : "Holds the values for custom fields, keyed by field internal name or id. The format of the value depends on the custom field type. Example: `{..., \"customValues\": {\"gender\": \"male\", \"birthDate\": \"1980-10-27\"}}`\n",
            "additionalProperties" : {
              "type" : "string"
            }
          },
          "phone" : {
            "type" : "string",
            "description" : "First phone number, used when phone is marked on products to\nbe returned on user list\n"
          },
          "accountNumber" : {
            "type" : "string",
            "description" : "First account number, used when account number is marked on products\nto be returned on user list\n"
          },
          "group" : {
            "description" : "The user group. Only returned when the `includeGroup` parameter is\nset to `true` and the current user can see other users' groups.\n",
            "$ref" : "#/definitions/EntityReference"
          },
          "groupSet" : {
            "description" : "The user group. Only returned when the `includeGroupSet` parameter\nis set to `true` and the current user can see other users' group set.\n",
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "x-implements" : "IUser"
      } ],
      "description" : "Data returned from user search",
      "x-implements" : "IUser"
    },
    "UserView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/User"
      }, {
        "type" : "object",
        "properties" : {
          "role" : {
            "description" : "The main role the user has. Possible values are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data.\n",
            "$ref" : "#/definitions/RoleEnum"
          },
          "name" : {
            "type" : "string",
            "description" : "The user's full name"
          },
          "username" : {
            "type" : "string",
            "description" : "The user's login name"
          },
          "email" : {
            "type" : "string",
            "description" : "The user's e-mail"
          },
          "customValues" : {
            "type" : "array",
            "description" : "The list of custom field values this user has",
            "items" : {
              "$ref" : "#/definitions/UserCustomFieldValue"
            }
          },
          "group" : {
            "description" : "Reference to the user group. Is only returned if the authenticated\nuser has permission to see groups \n",
            "$ref" : "#/definitions/EntityReference"
          },
          "groupSet" : {
            "description" : "Reference to the user group set. Is only returned if the\nauthenticated user has permission to see group sets and the user\ngroup is in a group set \n",
            "$ref" : "#/definitions/EntityReference"
          },
          "additionalImages" : {
            "type" : "array",
            "description" : "Holds the images other than the primary image, which is returned in the `image` field\n",
            "items" : {
              "$ref" : "#/definitions/Image"
            }
          },
          "addresses" : {
            "type" : "array",
            "description" : "Visible addresses",
            "items" : {
              "$ref" : "#/definitions/AddressView"
            }
          },
          "phones" : {
            "type" : "array",
            "description" : "Visible phones",
            "items" : {
              "$ref" : "#/definitions/PhoneView"
            }
          },
          "contact" : {
            "type" : "boolean",
            "description" : "Indicates whether the given user is a contact of the currently\nauthenticated user\n"
          },
          "permissions" : {
            "description" : "Permissions the authenticated has over this user",
            "$ref" : "#/definitions/UserPermissions"
          }
        },
        "x-implements" : "IUser"
      } ],
      "description" : "Represents an user with all data for viewing the profile",
      "x-implements" : "IUser"
    },
    "UserManage" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The user's full name"
        },
        "username" : {
          "type" : "string",
          "description" : "The user's login name"
        },
        "email" : {
          "type" : "string",
          "description" : "The user's e-mail"
        },
        "customValues" : {
          "type" : "object",
          "description" : "Holds the custom field values, keyed by field internal name or id. The format of the value depends on the custom field type. In order to lookup the custom fields, use either the `GET /users/data-for-new` (when creating) or `GET /users/{user}/data-for-edit` (when modifying) an user, and lookup each field by either internal name. Example: `{..., \"customValues\": {\"gender\": \"male\", \"birthDate\": \"1980-10-27\"}}`\n",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "hiddenFields" : {
          "type" : "array",
          "description" : "An array with the internal names of either the basic or custom fields\nthat should be hidden from other users. Currently the only basic\nprofile field that can be hidden is email. Any other will be\nconsidered a custom field, and should be the same key as used in the\n'customValues' property.\n",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "Contains the fields for either creating or modifying an user",
      "x-abstract" : true,
      "x-implements" : "IUser"
    },
    "UserNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/UserManage"
      }, {
        "type" : "object",
        "properties" : {
          "group" : {
            "type" : "string",
            "description" : "The initial user group"
          },
          "addresses" : {
            "type" : "array",
            "description" : "Addresses to be registered together with the user",
            "items" : {
              "$ref" : "#/definitions/AddressNew"
            }
          },
          "mobilePhones" : {
            "type" : "array",
            "description" : "Mobile phones to be registered together with the user",
            "items" : {
              "$ref" : "#/definitions/PhoneNew"
            }
          },
          "landLinePhones" : {
            "type" : "array",
            "description" : "Land-line phones to be registered together with the user",
            "items" : {
              "$ref" : "#/definitions/PhoneNew"
            }
          },
          "passwords" : {
            "type" : "array",
            "description" : "The initial passwords of the user",
            "items" : {
              "$ref" : "#/definitions/PasswordRegistration"
            }
          },
          "images" : {
            "type" : "array",
            "description" : "The ids of previously uploaded user temporary images to be\ninitially used as profile images\n",
            "items" : {
              "type" : "string"
            }
          },
          "captcha" : {
            "description" : "The captcha response is required on public registrations, and ignored when administrators / brokers register another user.",
            "$ref" : "#/definitions/CaptchaResponse"
          },
          "acceptAgreement" : {
            "type" : "boolean",
            "description" : "When there are agreements that need to be accepted for registration, this property must be passed with the value true"
          },
          "skipActivationEmail" : {
            "type" : "boolean",
            "description" : "When set to true, the activation e-mail is not sent to the registered user. Can only be used when an administrator / broker is registering an user, and ignored on public registrations (the e-mail is always sent on public registrations)."
          }
        }
      } ],
      "description" : "Contains data used to register an user. All basic profile fields (full\nname, login name, e-mail, phones, addresses and image) can be enabled or\ndisabled on Cyclos, via products. Also, the available custom fields and\nwhether they can be hidden depend on the products the selected group has.\n"
    },
    "UserEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/UserManage"
      }, {
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version stamp for the current object, used for optimistic locking.\nWhen saving, the same version as previously received needs to be passed\nback. If no one else has saved the object, the version will match and\nthe object will be updated. However, if someone other has saved the\nobject, the version will no longer match, and an error will be raised.\nThis is used to prevent multiple users (or processes) from updating the\nsame object and unwilingly overridding the property values, leading to\ndata loss. \n"
          }
        }
      } ],
      "description" : "Contains data used to edit an user profile. Only the basic and custom\nprofile fields can be edited in this operation. Addresses, phones and\nimages are managed through separated paths.\n"
    },
    "GroupForRegistration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : "string",
            "description" : "The description set on the group to be displayed to the user\n"
          }
        }
      } ],
      "description" : "Contains data for a possible group for user registration"
    },
    "BasicProfileFieldEnum" : {
      "type" : "string",
      "description" : "The existing user basic profile fields Possible values are: * name: Full name * username: Login name * email: E-mail * phone: Phone (either mobile or land-line) * address: Address * accountNumber: Account number * image: Image\n",
      "enum" : [ "name", "username", "email", "phone", "address", "accountNumber", "image" ]
    },
    "BasicProfileFieldInput" : {
      "type" : "object",
      "properties" : {
        "field" : {
          "description" : "The basic field this refers to Possible values are: * name: Full name * username: Login name * email: E-mail * phone: Phone (either mobile or land-line) * address: Address * accountNumber: Account number * image: Image\n",
          "$ref" : "#/definitions/BasicProfileFieldEnum"
        },
        "mask" : {
          "type" : "string",
          "description" : "If this field has a mask used for input, contains this mask.\nCurrently only the account number can (optionally) have one.\n"
        },
        "example" : {
          "type" : "string",
          "description" : "If this field has an example value, holds that example\n"
        }
      },
      "description" : "Definitions to input a basic profile field"
    },
    "BaseUserDataForSearch" : {
      "type" : "object",
      "properties" : {
        "fieldsInSearch" : {
          "type" : "array",
          "description" : "The internal names of either basic or custom profile fields which \ncan be used as search filters (separated fields, not keywords) \n",
          "items" : {
            "type" : "string"
          }
        },
        "addressFieldsInSearch" : {
          "type" : "array",
          "description" : "Fields which can be used when filtering by user address, by using the `address.<addressField>` name Possibles values for each array element are: * address: Filters by any field in the street address: `addressLine1`, `addressLine2`, `street`, `buildingNumber` or `complement`   * zip: Filters by zip (postal) code (exact match) * poBox: Filters by post-office box (exact match) * neighborhood: Filters by neighborhood name  * city: Filters by city name * region: Filters by region or state * country: Filters by country, represented as 2-letter, uppercase, ISO 3166-1 code (exact match)\n",
          "items" : {
            "$ref" : "#/definitions/AddressQueryFieldEnum"
          }
        },
        "basicFields" : {
          "type" : "array",
          "description" : "The list of basic profile fields that can be used either as search filters (if the internal names are present in the `fieldsInSearch` property) or on the result list (if the internal names are present in the `fieldsInList` property)\n",
          "items" : {
            "$ref" : "#/definitions/BasicProfileFieldInput"
          }
        },
        "customFields" : {
          "type" : "array",
          "description" : "The list of custom profile fields that can be used either as search filters (if the internal names are present in the `fieldsInSearch` property) or on the result list (if the internal names are present in the `fieldsInList` property)\n",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "groups" : {
          "type" : "array",
          "description" : "The groups the authenticated user can use to filter users. Admins\ncan always filter by groups, while users depend on a permission,\nwhich can be to only view group sets, only groups or none.\n",
          "items" : {
            "$ref" : "#/definitions/Group"
          }
        },
        "defaultGroups" : {
          "type" : "array",
          "description" : "The internal names (or ids, if missing) of the groups which should\nbe presented by default on user search\n",
          "items" : {
            "type" : "string"
          }
        },
        "searchByDistanceData" : {
          "description" : "Data for searching users by distance",
          "$ref" : "#/definitions/SearchByDistanceData"
        }
      },
      "description" : "Contains basic data used to search users in distinct contexts\n"
    },
    "UserDataForSearch" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BaseUserDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "fieldsInList" : {
            "type" : "array",
            "description" : "The internal names of either basic or custom profile fields that are\nconfigured to be shown on the list. This actually defines the fields\nthat will be loaded on the result. It is possible that no fields are\nconfigured to be returned on list. In this case, the result objects\nwill have the 'display' property loaded with what is configured to\nbe the user formatting field(s). \n",
            "items" : {
              "type" : "string"
            }
          },
          "statuses" : {
            "type" : "array",
            "description" : "The possible user statuses the authenticated user can use to filter the search. Only administrators or brokers over their members can filter by status (also depends on permissions) Possibles values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * removed: The user was permanently removed. It's profile is kept for historical purposes. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users.\n",
            "items" : {
              "$ref" : "#/definitions/UserStatusEnum"
            }
          },
          "groupsForRegistration" : {
            "type" : "array",
            "description" : "Possible groups an administrator or broker can use to register users\n",
            "items" : {
              "$ref" : "#/definitions/Group"
            }
          }
        }
      } ],
      "description" : "Contains data with the configuration for searching users\n"
    },
    "UserDataForMap" : {
      "allOf" : [ {
        "$ref" : "#/definitions/UserDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "mapDirectoryField" : {
            "type" : "string",
            "description" : "Internal name of the custom field currently set as primary search\nfilter for the user directory (map) search. When not returned (null)\nit is assumed that keywords should be the primary filter.\n"
          },
          "defaultMapLocation" : {
            "description" : "The default location for the map to be displayed",
            "$ref" : "#/definitions/GeographicalCoordinate"
          },
          "defaultMapZoomMobile" : {
            "type" : "integer",
            "description" : "The default map zoom level for mobile applications"
          },
          "defaultMapZoomWeb" : {
            "type" : "integer",
            "description" : "The default map zoom level for web applications"
          }
        }
      } ],
      "description" : "Contains configuration data for the user directory (map)"
    },
    "UserBasicData" : {
      "type" : "object",
      "properties" : {
        "emailRequired" : {
          "type" : "boolean",
          "description" : "Indicates whether the e-mail is required"
        },
        "profileFieldActions" : {
          "type" : "object",
          "description" : "An object, keyed by profile field internal name (either one of the\nbasic profile fields or custom fields), containing other objects that\ndefines the allowed actions over these profile fields\n",
          "additionalProperties" : {
            "$ref" : "#/definitions/ProfileFieldActions"
          }
        },
        "customFields" : {
          "type" : "array",
          "description" : "The available custom field definitions",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "confirmationPasswordInput" : {
          "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
          "$ref" : "#/definitions/PasswordInput"
        }
      },
      "description" : "Contains properties shared by both UserDataForNew and UserDataForEdit\n"
    },
    "UserDataForNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/UserBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "allowSetSendActivationEmail" : {
            "type" : "boolean",
            "description" : "Whether the current user is allowed to skip the activateion e-mail\n"
          },
          "generatedUsername" : {
            "type" : "boolean",
            "description" : "Indicates whether the login name is generated"
          },
          "addressConfiguration" : {
            "description" : "Configuration for registering addresses",
            "$ref" : "#/definitions/AddressConfigurationForUserRegistration"
          },
          "phoneConfiguration" : {
            "description" : "Configuration for registering phones",
            "$ref" : "#/definitions/PhoneConfigurationForUserRegistration"
          },
          "passwordTypes" : {
            "type" : "array",
            "description" : "The password types that should be registered together with the user\n",
            "items" : {
              "$ref" : "#/definitions/PasswordTypeRegistration"
            }
          },
          "captchaType" : {
            "description" : "description: >\n  The captcha provider used to requested a captcha for registration,\n  or null if no captcha is needed.\nPossible values are: * internal: Default provider using images\n",
            "$ref" : "#/definitions/CaptchaProviderEnum"
          },
          "user" : {
            "description" : "The object that can be altered and posted back to register the user\n",
            "$ref" : "#/definitions/UserNew"
          },
          "agreements" : {
            "type" : "array",
            "description" : "The agreements that needs to be accepted by the user to be able to\nregister. Only returned for public registrations.\n",
            "items" : {
              "$ref" : "#/definitions/AgreementContent"
            }
          }
        }
      } ],
      "description" : "Contains data used to register an user"
    },
    "AddressConfigurationForUserRegistration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AddressConfiguration"
      }, {
        "type" : "object",
        "properties" : {
          "address" : {
            "description" : "Contains the default values for a new address",
            "$ref" : "#/definitions/AddressNew"
          },
          "availability" : {
            "description" : "The availability for addresses Possible values are: * disabled: The data is disabled * optional: The data is enabled and optional * required: The data is enabled and required\n",
            "$ref" : "#/definitions/AvailabilityEnum"
          }
        }
      } ],
      "description" : "Contains extended address configuration used on user registration"
    },
    "PhoneConfigurationForUserRegistration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PhoneConfiguration"
      }, {
        "type" : "object",
        "properties" : {
          "mobilePhone" : {
            "description" : "Contains the default values for a new mobile phone",
            "$ref" : "#/definitions/PhoneNew"
          },
          "landLinePhone" : {
            "description" : "Contains the default values for a new land-line phone",
            "$ref" : "#/definitions/PhoneNew"
          },
          "mobileAvailability" : {
            "description" : "The availability for mobile phones Possible values are: * disabled: The data is disabled * optional: The data is enabled and optional * required: The data is enabled and required\n",
            "$ref" : "#/definitions/AvailabilityEnum"
          },
          "landLineAvailability" : {
            "description" : "The availability for mobile phones Possible values are: * disabled: The data is disabled * optional: The data is enabled and optional * required: The data is enabled and required\n",
            "$ref" : "#/definitions/AvailabilityEnum"
          }
        }
      } ],
      "description" : "Contains extended phone configuration used on user registration"
    },
    "UserDataForEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/UserBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "user" : {
            "description" : "The object that can be altered and posted back to save the user\n",
            "$ref" : "#/definitions/UserEdit"
          },
          "emailPendingValidation" : {
            "type" : "string",
            "description" : "The new e-mail address, which is still pending validation. Is\nonly returned when e-mail validation is enabled for edit profile,\nand the user has changed the e-mail address.\n"
          }
        }
      } ],
      "description" : "Contains data used to edit an user profile"
    },
    "UserRegistrationStatusEnum" : {
      "type" : "string",
      "description" : "The status of the user after the registration Possible values are: * active: The user is initially active * inactive: The user is initially inactive, and an administrator needs to manually activate the user * emailValidation: The user has received an e-mail, with a link to verify the e-mail address. Once verified, the registration will be complete\n",
      "enum" : [ "active", "inactive", "emailValidation" ]
    },
    "UserRegistrationResult" : {
      "type" : "object",
      "properties" : {
        "user" : {
          "description" : "The user that has just been registered",
          "$ref" : "#/definitions/User"
        },
        "status" : {
          "description" : "The status of the user after the registration Possible values are: * active: The user is initially active * inactive: The user is initially inactive, and an administrator needs to manually activate the user * emailValidation: The user has received an e-mail, with a link to verify the e-mail address. Once verified, the registration will be complete\n",
          "$ref" : "#/definitions/UserRegistrationStatusEnum"
        },
        "generatedPasswords" : {
          "type" : "array",
          "description" : "The types of passwords that were generated",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "rootUrl" : {
          "type" : "string",
          "description" : "The root URL that can be used to access the web interface"
        },
        "principals" : {
          "type" : "array",
          "description" : "Contains information about each user principal (identification) and\nthe channels that can be accessed using it\n",
          "items" : {
            "$ref" : "#/definitions/UserRegistrationPrincipal"
          }
        }
      },
      "description" : "Result of an user registration"
    },
    "UserRegistrationPrincipal" : {
      "type" : "object",
      "properties" : {
        "value" : {
          "type" : "string",
          "description" : "The principal value"
        },
        "type" : {
          "description" : "The principal type",
          "$ref" : "#/definitions/PrincipalType"
        },
        "channels" : {
          "type" : "array",
          "description" : "The channels that can be accessed using this principal",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        }
      },
      "description" : "Contains information about a principal (user identification) and\nthe channels that can be accessed using it\n"
    },
    "PasswordTypeRegistration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : "string",
            "description" : "The description to be show on the registration form\n"
          },
          "canForceChange" : {
            "type" : "boolean",
            "description" : "Whether the current user can set the password to be changed on\nthe first user login\n"
          }
        }
      } ],
      "description" : "Data for a given password type to be used on user registration"
    },
    "PasswordRegistration" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "The password type"
        },
        "value" : {
          "type" : "string",
          "description" : "The password value"
        },
        "checkConfirmation" : {
          "type" : "boolean",
          "description" : "Depending on the client, if a confirm password field is shown to users, it might be useful to check the confirmation password value on the server. This way, if there are other validation exceptions, they are all shown together. In this case, this field should be set to `true` and the `confirmationValue` should be passed in with the user input. However, in cases where clients just want to register an user with a password non interactively (like in a bulk registration), passing the password value twice is not desirable. In such cases, this field can be left empty (or set to `false`), and the `confirmationValue` will be ignored.\n"
        },
        "confirmationValue" : {
          "type" : "string",
          "description" : "The password confirmation value. Is ignored unless `checkConfirmation` is set to `true`.\n"
        },
        "forceChange" : {
          "type" : "boolean",
          "description" : "When set to true will force the user to change it after the first login\n"
        }
      },
      "description" : "Data regarding a password being registered with the user"
    },
    "UserCustomFieldValue" : {
      "allOf" : [ {
        "$ref" : "#/definitions/CustomFieldValue"
      }, {
        "type" : "object",
        "properties" : {
          "hidden" : {
            "type" : "boolean",
            "description" : "Whether this field is hidden for other users"
          }
        }
      } ],
      "description" : "Contains the custom field value information, plus the hidden flag\n"
    },
    "ProfileFieldActions" : {
      "type" : "object",
      "properties" : {
        "edit" : {
          "type" : "boolean",
          "description" : "Can the authenticated user edit this field?"
        },
        "managePrivacy" : {
          "type" : "boolean",
          "description" : "Can the authenticated user manage the privacy for this field?"
        }
      },
      "description" : "Determines the allowed actions over a given profile field"
    },
    "AgreementContent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "content" : {
            "type" : "string",
            "description" : "The agreement content, formatted as HTML text"
          }
        }
      } ],
      "description" : "Contains the content of an user agreement"
    },
    "UserPermissions" : {
      "type" : "object",
      "properties" : {
        "profile" : {
          "description" : "Permissions over the user profile",
          "$ref" : "#/definitions/UserProfilePermissions"
        },
        "contact" : {
          "description" : "Permissions over a contact",
          "$ref" : "#/definitions/UserContactPermissions"
        },
        "marketplace" : {
          "description" : "Permissions over the user marketplace",
          "$ref" : "#/definitions/UserMarketplacePermissions"
        },
        "accounts" : {
          "type" : "array",
          "description" : "Accounts which can be viewed by the authenticated user",
          "items" : {
            "$ref" : "#/definitions/AccountWithCurrency"
          }
        },
        "payment" : {
          "description" : "Permissions for payments regarding this user",
          "$ref" : "#/definitions/UserPaymentPermissions"
        },
        "records" : {
          "type" : "array",
          "description" : "Records types the authenticated user can view over the given user\n",
          "items" : {
            "$ref" : "#/definitions/OwnerRecordPermissions"
          }
        },
        "tokens" : {
          "type" : "array",
          "description" : "Tokens the authenticated user can view over the given user\n",
          "items" : {
            "$ref" : "#/definitions/TokenType"
          }
        },
        "personalizeNfcTokens" : {
          "type" : "array",
          "description" : "NFC tokens the authenticated user can personalize for the given user\n",
          "items" : {
            "$ref" : "#/definitions/TokenType"
          }
        }
      },
      "description" : "Determines permission the authenticated have over a specific user"
    },
    "UserProfilePermissions" : {
      "type" : "object",
      "properties" : {
        "editProfile" : {
          "type" : "boolean",
          "description" : "Can edit the user profile?"
        },
        "manageAddresses" : {
          "type" : "boolean",
          "description" : "Can manage addresses?"
        },
        "managePhones" : {
          "type" : "boolean",
          "description" : "Can manage phones?"
        },
        "manageImages" : {
          "type" : "boolean",
          "description" : "Can manage profile images?"
        }
      },
      "description" : "Permissions over an user profile"
    },
    "UserContactPermissions" : {
      "type" : "object",
      "properties" : {
        "add" : {
          "type" : "boolean",
          "description" : "Can the current user be added to the contact list?"
        },
        "remove" : {
          "type" : "boolean",
          "description" : "Can the current user be removed from the contact list?"
        }
      },
      "description" : "Permissions regarding the contact list"
    },
    "UserMarketplacePermissions" : {
      "type" : "object",
      "properties" : {
        "viewAdvertisements" : {
          "type" : "boolean",
          "description" : "Can view simple advertisements?"
        },
        "manageAdvertisements" : {
          "type" : "boolean",
          "description" : "Can manage simple advertisements?"
        }
      },
      "description" : "Permissions over an user marketplace"
    },
    "UserPaymentPermissions" : {
      "type" : "object",
      "properties" : {
        "asUserToSelf" : {
          "type" : "boolean",
          "description" : "Can the authenticated administrator or broker perform a payment in\nbehalf of this user to another account belonging to the same user? \n"
        },
        "asUserToSystem" : {
          "type" : "boolean",
          "description" : "Can the authenticated administrator or broker perform a payment in\nbehalf of this user to a system account? \n"
        },
        "asUserToUser" : {
          "type" : "boolean",
          "description" : "Can the authenticated administrator or broker perform a payment in\nbehalf of this user to another user? \n"
        },
        "systemToUser" : {
          "type" : "boolean",
          "description" : "Can the authenticated administrator perform a payment from a system\naccount to this user? \n"
        },
        "userToUser" : {
          "type" : "boolean",
          "description" : "Can the authenticated member perform a payment from an himself to\nthis user? \n"
        }
      },
      "description" : "Permissions for payments regarding an user"
    },
    "UserOperatorsDataForSearch" : {
      "type" : "object",
      "properties" : {
        "canCreateNew" : {
          "type" : "boolean",
          "description" : "Indicates whether the authenticated user can create more operators \nfor the specified user\n"
        },
        "groups" : {
          "type" : "array",
          "description" : "The operator groups this user owns",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "fieldsInList" : {
          "type" : "array",
          "description" : "The internal names of either basic or custom profile fields that are\nconfigured to be shown on the list. This actually defines the fields\nthat will be loaded on the result. It is possible that no fields are\nconfigured to be returned on list. In this case, the result objects\nwill have the 'display' property loaded with what is configured to\nbe the user formatting field(s). \n",
          "items" : {
            "type" : "string"
          }
        },
        "basicFields" : {
          "type" : "array",
          "description" : "The basic profile fields in the result list",
          "items" : {
            "$ref" : "#/definitions/BasicProfileFieldInput"
          }
        },
        "customFields" : {
          "type" : "array",
          "description" : "The custom profile fields in the result list",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        }
      }
    },
    "GeneralOperatorsDataForSearch" : {
      "type" : "object",
      "properties" : {
        "userGroups" : {
          "type" : "array",
          "description" : "The groups the authenticated user can use to filter users. Admins\ncan always filter by groups, while users depend on a permission,\nwhich can be to only view group sets, only groups or none.\n",
          "items" : {
            "$ref" : "#/definitions/Group"
          }
        }
      }
    },
    "AddressFieldEnum" : {
      "type" : "string",
      "description" : "The address fields that can be configured to be enabled or required Possible values are: * addressLine1: The first line of the descriptive address * addressLine2: The second line of the descriptive address * street: The street name * buildingNumber: The numeric identifier for a land parcel, house, building or other * complement: The complement (like apartment number)   * zip: A zip code that identifies a specific geographic (postal) delivery area * poBox: The post-office box, is an uniquely addressable box * neighborhood: The neighborhood name  * city: The city name * region: The region or state * country: The country, represented as 2-letter, uppercase, ISO 3166-1 code\n",
      "enum" : [ "addressLine1", "addressLine2", "street", "buildingNumber", "complement", "zip", "poBox", "neighborhood", "city", "region", "country" ]
    },
    "AddressQueryFieldEnum" : {
      "type" : "string",
      "description" : "Fields which can be used when filtering by user address, by using the `address.<addressField>` name Possible values are: * address: Filters by any field in the street address: `addressLine1`, `addressLine2`, `street`, `buildingNumber` or `complement`   * zip: Filters by zip (postal) code (exact match) * poBox: Filters by post-office box (exact match) * neighborhood: Filters by neighborhood name  * city: Filters by city name * region: Filters by region or state * country: Filters by country, represented as 2-letter, uppercase, ISO 3166-1 code (exact match)\n",
      "enum" : [ "address", "zip", "poBox", "neighborhood", "city", "region", "country" ]
    },
    "AddressInSearchResultEnum" : {
      "type" : "string",
      "description" : "Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * none: Addresses are not returned. * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * primary: The primary (default) address is returned\n",
      "enum" : [ "none", "all", "nearest", "primary" ]
    },
    "IAddress" : {
      "type" : "object",
      "properties" : {
        "addressLine1" : {
          "type" : "string",
          "description" : "The first line of the descriptive address\n"
        },
        "addressLine2" : {
          "type" : "string",
          "description" : "The second line of the descriptive address\n"
        },
        "street" : {
          "type" : "string",
          "description" : "The street name\n"
        },
        "buildingNumber" : {
          "type" : "string",
          "description" : "The numeric identifier for a land parcel, house, building or other\n"
        },
        "complement" : {
          "type" : "string",
          "description" : "The complement (like apartment number)  \n"
        },
        "zip" : {
          "type" : "string",
          "description" : "A zip code that identifies a specific geographic (postal) delivery area\n"
        },
        "poBox" : {
          "type" : "string",
          "description" : "The post-office box, is an uniquely addressable box\n"
        },
        "neighborhood" : {
          "type" : "string",
          "description" : "The neighborhood name \n"
        },
        "city" : {
          "type" : "string",
          "description" : "The city name\n"
        },
        "region" : {
          "type" : "string",
          "description" : "The region or state\n"
        },
        "country" : {
          "type" : "string",
          "description" : "The country, represented as 2-letter, uppercase, ISO 3166-1 code\n"
        },
        "location" : {
          "description" : "The geolocation of the current address",
          "$ref" : "#/definitions/GeographicalCoordinate"
        }
      },
      "description" : "Interface containing the common address properties",
      "x-interface" : true
    },
    "Address" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "addressLine1" : {
            "type" : "string",
            "description" : "The first line of the descriptive address\n"
          },
          "addressLine2" : {
            "type" : "string",
            "description" : "The second line of the descriptive address\n"
          },
          "street" : {
            "type" : "string",
            "description" : "The street name\n"
          },
          "buildingNumber" : {
            "type" : "string",
            "description" : "The numeric identifier for a land parcel, house, building or other\n"
          },
          "complement" : {
            "type" : "string",
            "description" : "The complement (like apartment number)  \n"
          },
          "zip" : {
            "type" : "string",
            "description" : "A zip code that identifies a specific geographic (postal) delivery area\n"
          },
          "poBox" : {
            "type" : "string",
            "description" : "The post-office box, is an uniquely addressable box\n"
          },
          "neighborhood" : {
            "type" : "string",
            "description" : "The neighborhood name \n"
          },
          "city" : {
            "type" : "string",
            "description" : "The city name\n"
          },
          "region" : {
            "type" : "string",
            "description" : "The region or state\n"
          },
          "country" : {
            "type" : "string",
            "description" : "The country, represented as 2-letter, uppercase, ISO 3166-1 code\n"
          },
          "location" : {
            "description" : "The geolocation of the current address",
            "$ref" : "#/definitions/GeographicalCoordinate"
          }
        },
        "x-implements" : "IAddress"
      } ],
      "description" : "An address reference. The actually used fields depend on\nthe user configuration\n",
      "x-implements" : "IAddress"
    },
    "AddressResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Address"
      }, {
        "type" : "object",
        "properties" : {
          "defaultAddress" : {
            "type" : "boolean",
            "description" : "Indicates whether this is the default address for the user"
          }
        }
      } ],
      "description" : "Information of an address as returned on list"
    },
    "UserAddressesListData" : {
      "type" : "object",
      "properties" : {
        "canManage" : {
          "type" : "boolean",
          "description" : "Indicates whether the addresses can be managed by the\nauthenticated user\n"
        },
        "maxAddresses" : {
          "type" : "integer",
          "description" : "Indicates the maximum number of addresses the user can have\n"
        },
        "addresses" : {
          "type" : "array",
          "description" : "The address list",
          "items" : {
            "$ref" : "#/definitions/AddressResult"
          }
        }
      },
      "description" : "Contains, besides the user's addresses, additional data for its management\n"
    },
    "AddressView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AddressResult"
      }, {
        "type" : "object",
        "properties" : {
          "user" : {
            "description" : "The user which owns this address",
            "$ref" : "#/definitions/User"
          },
          "hidden" : {
            "type" : "boolean",
            "description" : "Indicates whether this address should be hidden for other users  \n"
          }
        }
      } ],
      "description" : "Detailed information when viewing an address"
    },
    "AddressManage" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The address name"
        },
        "addressLine1" : {
          "type" : "string",
          "description" : "The first line of the descriptive address\n"
        },
        "addressLine2" : {
          "type" : "string",
          "description" : "The second line of the descriptive address\n"
        },
        "street" : {
          "type" : "string",
          "description" : "The street name\n"
        },
        "buildingNumber" : {
          "type" : "string",
          "description" : "The numeric identifier for a land parcel, house, building or other\n"
        },
        "complement" : {
          "type" : "string",
          "description" : "The complement (like apartment number)  \n"
        },
        "zip" : {
          "type" : "string",
          "description" : "A zip code that identifies a specific geographic (postal) delivery area\n"
        },
        "poBox" : {
          "type" : "string",
          "description" : "The post-office box, is an uniquely addressable box\n"
        },
        "neighborhood" : {
          "type" : "string",
          "description" : "The neighborhood name \n"
        },
        "city" : {
          "type" : "string",
          "description" : "The city name\n"
        },
        "region" : {
          "type" : "string",
          "description" : "The region or state\n"
        },
        "country" : {
          "type" : "string",
          "description" : "The country, represented as 2-letter, uppercase, ISO 3166-1 code\n"
        },
        "location" : {
          "description" : "The geolocation of the current address",
          "$ref" : "#/definitions/GeographicalCoordinate"
        },
        "defaultAddress" : {
          "type" : "boolean",
          "description" : "Indicates whether this is the default address for the user"
        },
        "hidden" : {
          "type" : "boolean",
          "description" : "Whether this address should be hidden for other users"
        }
      },
      "description" : "Common fields for either creating or editing an address",
      "x-abstract" : true,
      "x-implements" : "IAddress"
    },
    "AddressNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AddressManage"
      } ],
      "description" : "Fields for a new address. The actually used and required fields depend\non the user configuration.\n"
    },
    "AddressEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AddressManage"
      }, {
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version stamp for the current object, used for optimistic locking.\nWhen saving, the same version as previously received needs to be passed\nback. If no one else has saved the object, the version will match and\nthe object will be updated. However, if someone other has saved the\nobject, the version will no longer match, and an error will be raised.\nThis is used to prevent multiple users (or processes) from updating the\nsame object and unwilingly overridding the property values, leading to\ndata loss. \n"
          }
        }
      } ],
      "description" : "Fields for editing an address. The actually used and required fields depend on the user configuration."
    },
    "AddressConfiguration" : {
      "type" : "object",
      "properties" : {
        "useMap" : {
          "type" : "boolean",
          "description" : "Indicates whether maps are enabled in Cyclos"
        },
        "enabledFields" : {
          "type" : "array",
          "description" : "Contains the address fields that are enabled in Cyclos Possibles values for each array element are: * addressLine1: The first line of the descriptive address * addressLine2: The second line of the descriptive address * street: The street name * buildingNumber: The numeric identifier for a land parcel, house, building or other * complement: The complement (like apartment number)   * zip: A zip code that identifies a specific geographic (postal) delivery area * poBox: The post-office box, is an uniquely addressable box * neighborhood: The neighborhood name  * city: The city name * region: The region or state * country: The country, represented as 2-letter, uppercase, ISO 3166-1 code\n",
          "items" : {
            "$ref" : "#/definitions/AddressFieldEnum"
          }
        },
        "requiredFields" : {
          "type" : "array",
          "description" : "Contains the address fields that are required in Cyclos Possibles values for each array element are: * addressLine1: The first line of the descriptive address * addressLine2: The second line of the descriptive address * street: The street name * buildingNumber: The numeric identifier for a land parcel, house, building or other * complement: The complement (like apartment number)   * zip: A zip code that identifies a specific geographic (postal) delivery area * poBox: The post-office box, is an uniquely addressable box * neighborhood: The neighborhood name  * city: The city name * region: The region or state * country: The country, represented as 2-letter, uppercase, ISO 3166-1 code\n",
          "items" : {
            "$ref" : "#/definitions/AddressFieldEnum"
          }
        }
      },
      "description" : "Contains configuration information related to addresses"
    },
    "AddressBasicData" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AddressConfiguration"
      }, {
        "type" : "object",
        "properties" : {
          "confirmationPasswordInput" : {
            "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
            "$ref" : "#/definitions/PasswordInput"
          }
        }
      } ],
      "description" : "Contains data shared by both AddressDataForNew and AddressDataForEdit\n"
    },
    "AddressDataForNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AddressBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "address" : {
            "description" : "The address populated with the default fields. This value can be modified and sent back on `POST /{user}/addresses`.\n",
            "$ref" : "#/definitions/AddressNew"
          }
        }
      } ],
      "description" : "Contains data for creating a new address\n"
    },
    "AddressDataForEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AddressBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "address" : {
            "description" : "The address that is being edited. This value can be modified and sent back on `PUT /addresses/{id}`.\n",
            "$ref" : "#/definitions/AddressEdit"
          },
          "edit" : {
            "type" : "boolean",
            "description" : "Can the authenticated user edit this address?"
          },
          "managePrivacy" : {
            "type" : "boolean",
            "description" : "Can the authenticated user manage the privacy of this address?"
          }
        }
      } ],
      "description" : "Contains data for editing a new address\n"
    },
    "DistanceEnum" : {
      "type" : "string",
      "description" : "Unit for measuring distances Possible values are: * kilometer: Unit representing kilometers * mile: Unit representing miles \n",
      "enum" : [ "kilometer", "mile" ]
    },
    "SearchByDistanceData" : {
      "type" : "object",
      "properties" : {
        "addresses" : {
          "type" : "array",
          "description" : "The list of addresses owned by the authenticated user",
          "items" : {
            "$ref" : "#/definitions/Address"
          }
        },
        "distanceUnit" : {
          "description" : "Unit for measuring distances Possible values are: * kilometer: Unit representing kilometers * mile: Unit representing miles \n",
          "$ref" : "#/definitions/DistanceEnum"
        },
        "defaultValues" : {
          "type" : "object",
          "description" : "The default values, keyed by field name, for address fields",
          "additionalProperties" : {
            "type" : "string"
          }
        }
      },
      "description" : "Contains configuration information for searching data by distance"
    },
    "GeographicalCoordinate" : {
      "type" : "object",
      "properties" : {
        "latitude" : {
          "type" : "number",
          "format" : "double",
          "description" : "The latitude"
        },
        "longitude" : {
          "type" : "number",
          "format" : "double",
          "description" : "The longitude"
        }
      },
      "description" : "A geographical coordinate with latitude and longitude"
    },
    "Country" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "type" : "string",
          "description" : "The 2-letter, `ISO 3166-1 alpha-2` code"
        },
        "name" : {
          "type" : "string",
          "description" : "The display name (in the user's language)"
        }
      },
      "description" : "Represents a country, with a code and display name"
    },
    "PhoneKind" : {
      "type" : "string",
      "description" : "Type of phone Possible values are: * mobile: A mobile phone * landLine: A landline phone\n",
      "enum" : [ "mobile", "landLine" ]
    },
    "CodeVerificationStatusEnum" : {
      "type" : "string",
      "description" : "The status of a mobile phone verification challenge Possible values are: * success: The code was correct and accepted. * failed: The code was wrong (it doesn't match the expected value) * codeNotSent: There isn't a current code to be verified (for example the was never sent or the code was reset by max attempts reached) * expired: The code has expired and can't be used anymore. * maxAttemptsReached: The max attempts with an invalid code was reached.\n",
      "enum" : [ "success", "failed", "codeNotSent", "expired", "maxAttemptsReached" ]
    },
    "IPhone" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The phone name"
        },
        "number" : {
          "type" : "string",
          "description" : "The formatted number"
        },
        "extension" : {
          "type" : "string",
          "description" : "The number extension, only for landLine phones, and is only used if the\nphone configuration states that extensions are enabled. \n"
        }
      },
      "description" : "Interface containing the common phone properties",
      "x-interface" : true
    },
    "IPhoneDetailed" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The phone name"
        },
        "number" : {
          "type" : "string",
          "description" : "The formatted number"
        },
        "extension" : {
          "type" : "string",
          "description" : "The number extension, only for landLine phones, and is only used if the\nphone configuration states that extensions are enabled. \n"
        },
        "enabledForSms" : {
          "type" : "boolean",
          "description" : "Only applicable if this represents a mobile phone.\nWhether this mobile phone is enabled for SMS, both receiving\nnotifications and sending SMS operations. Can only be set if the\nmobile phone is verified.\n"
        },
        "verified" : {
          "type" : "boolean",
          "description" : "Only applicable if this represents a mobile phone.\nWhether this mobile is verified. Can only be directly set by\nadministrators. Regular users need to verify it.\n"
        }
      },
      "description" : "Interface containing additional common phone properties",
      "x-interface" : true,
      "x-implements" : "IPhone"
    },
    "Phone" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The phone name"
          },
          "number" : {
            "type" : "string",
            "description" : "The formatted number"
          },
          "extension" : {
            "type" : "string",
            "description" : "The number extension, only for landLine phones, and is only used if the\nphone configuration states that extensions are enabled. \n"
          },
          "type" : {
            "description" : "Type of phone Possible values are: * mobile: A mobile phone * landLine: A landline phone\n",
            "$ref" : "#/definitions/PhoneKind"
          },
          "normalizedNumber" : {
            "type" : "string",
            "description" : "The number, normalized to the E.164 format",
            "readOnly" : true
          }
        }
      } ],
      "description" : "A phone reference"
    },
    "PhoneResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Phone"
      }, {
        "type" : "object",
        "properties" : {
          "verified" : {
            "type" : "boolean",
            "description" : "Indicates whether this phone is verified. Is only returned if `kind` is `mobile` and the authenticated user manages the owner of this phone.\n"
          },
          "enabledForSms" : {
            "type" : "boolean",
            "description" : "Indicates whether this phone is verified and enabled for SMS. Is only returned if `kind` is `mobile` and the authenticated user manages the owner of this phone.\n"
          },
          "hidden" : {
            "type" : "boolean",
            "description" : "Indicates whether this phone is hidden for other users. Is only returned if `kind` is `mobile` and the authenticated user manages the owner of this phone.\n"
          },
          "verificationCodeSendDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date the verification code was sent, if any. Is only returned if `kind` is `mobile` and the authenticated user manages the owner of this phone.\n"
          }
        }
      } ],
      "description" : "Data for a phone as returned on list"
    },
    "UserPhonesListData" : {
      "type" : "object",
      "properties" : {
        "canManage" : {
          "type" : "boolean",
          "description" : "Can the authenticated user manage phones of this user?"
        },
        "smsEnabled" : {
          "type" : "boolean",
          "description" : "Indicates whether outbound SMS is enabled in Cyclos"
        },
        "maxMobilePhones" : {
          "type" : "integer",
          "description" : "Indicates the maximum number of mobile phones this user can have. Is only returned when `canManage` is `true`.\n"
        },
        "maxLandLinePhones" : {
          "type" : "integer",
          "description" : "Indicates the maximum number of land line (fixed) phones this user can have. Is only returned when `canManage` is `true`.\n"
        },
        "phones" : {
          "type" : "array",
          "description" : "The list of (visible) phones",
          "items" : {
            "$ref" : "#/definitions/PhoneResult"
          }
        }
      },
      "description" : "Contains information for a list of phones"
    },
    "PhoneView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PhoneResult"
      }, {
        "type" : "object",
        "properties" : {
          "user" : {
            "description" : "The user which owns this phone",
            "$ref" : "#/definitions/User"
          },
          "name" : {
            "type" : "string",
            "description" : "The phone name"
          },
          "number" : {
            "type" : "string",
            "description" : "The formatted number"
          },
          "extension" : {
            "type" : "string",
            "description" : "The number extension, only for landLine phones, and is only used if the\nphone configuration states that extensions are enabled. \n"
          },
          "enabledForSms" : {
            "type" : "boolean",
            "description" : "Only applicable if this represents a mobile phone.\nWhether this mobile phone is enabled for SMS, both receiving\nnotifications and sending SMS operations. Can only be set if the\nmobile phone is verified.\n"
          },
          "verified" : {
            "type" : "boolean",
            "description" : "Only applicable if this represents a mobile phone.\nWhether this mobile is verified. Can only be directly set by\nadministrators. Regular users need to verify it.\n"
          }
        },
        "x-implements" : "IPhoneDetailed"
      } ],
      "description" : "Detailed information when viewing a phone",
      "x-implements" : "IPhoneDetailed"
    },
    "PhoneManage" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The phone name"
        },
        "number" : {
          "type" : "string",
          "description" : "The formatted number"
        },
        "extension" : {
          "type" : "string",
          "description" : "The number extension, only for landLine phones, and is only used if the\nphone configuration states that extensions are enabled. \n"
        },
        "enabledForSms" : {
          "type" : "boolean",
          "description" : "Only applicable if this represents a mobile phone.\nWhether this mobile phone is enabled for SMS, both receiving\nnotifications and sending SMS operations. Can only be set if the\nmobile phone is verified.\n"
        },
        "verified" : {
          "type" : "boolean",
          "description" : "Only applicable if this represents a mobile phone.\nWhether this mobile is verified. Can only be directly set by\nadministrators. Regular users need to verify it.\n"
        }
      },
      "description" : "Common fields for either creating or editing a phone",
      "x-abstract" : true,
      "x-implements" : "IPhoneDetailed"
    },
    "PhoneNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PhoneManage"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "Type of phone Possible values are: * mobile: A mobile phone * landLine: A landline phone\n",
            "$ref" : "#/definitions/PhoneKind"
          }
        }
      } ],
      "description" : "Parameters for creating a new phone"
    },
    "PhoneEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PhoneManage"
      }, {
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version stamp for the current object, used for optimistic locking.\nWhen saving, the same version as previously received needs to be passed\nback. If no one else has saved the object, the version will match and\nthe object will be updated. However, if someone other has saved the\nobject, the version will no longer match, and an error will be raised.\nThis is used to prevent multiple users (or processes) from updating the\nsame object and unwilingly overridding the property values, leading to\ndata loss. \n"
          }
        }
      } ],
      "description" : "Parameters for editing an existing phone"
    },
    "PhoneBasicData" : {
      "type" : "object",
      "properties" : {
        "extensionEnabled" : {
          "type" : "boolean",
          "description" : "Only returned for land line phones.\nIndicates whether the extension is enabled.\n"
        },
        "smsEnabled" : {
          "type" : "boolean",
          "description" : "Only returned for mobile phones.\nIndicates whether outbound SMS is enabled in Cyclos\n"
        },
        "confirmationPasswordInput" : {
          "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
          "$ref" : "#/definitions/PasswordInput"
        }
      },
      "description" : "Contains data shared by both PhoneDataForNew and PhoneDataForEdit\n"
    },
    "PhoneDataForNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PhoneBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "phone" : {
            "description" : "The phone populated with the default fields. This value can be modified and sent back on `POST /{user}/phones`.\n",
            "$ref" : "#/definitions/PhoneNew"
          },
          "example" : {
            "type" : "string",
            "description" : "An example phone number"
          }
        }
      } ],
      "description" : "Contains data for creating a new phone\n"
    },
    "PhoneDataForEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PhoneBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "phone" : {
            "description" : "The phone that is being edited. This value can be modified and sent back on `PUT /phones/{id}`.\n",
            "$ref" : "#/definitions/PhoneEdit"
          },
          "edit" : {
            "type" : "boolean",
            "description" : "Can the authenticated user edit this phone?"
          },
          "managePrivacy" : {
            "type" : "boolean",
            "description" : "Can the authenticated user manage the privacy of this phone?"
          }
        }
      } ],
      "description" : "Contains data for editing a new phone\n"
    },
    "PhoneConfiguration" : {
      "type" : "object",
      "properties" : {
        "country" : {
          "type" : "string",
          "description" : "The 2-letter country code used by default for numbers. Unless an international number is specified (using the `+` prefix), the phone number is assumed to belong to this country.\n"
        },
        "alwaysShowInternationalNumber" : {
          "type" : "boolean",
          "description" : "Indicates the it is configured to always format numbers using the\ninternational format. If set to false, numbers will be formatted\nin the national format.\n"
        },
        "extensionEnabled" : {
          "type" : "boolean",
          "description" : "Indicates whether the extension is enabled for land-line phones"
        },
        "smsEnabled" : {
          "type" : "boolean",
          "description" : "Indicates whether outbound SMS is enabled in Cyclos"
        },
        "landLineExample" : {
          "type" : "string",
          "description" : "An example phone number for a land-line phone"
        },
        "mobileExample" : {
          "type" : "string",
          "description" : "An example phone number for a mobile phone"
        }
      },
      "description" : "Contains configuration information related to phones"
    },
    "ImageKind" : {
      "type" : "string",
      "description" : "Determines the kind of an image Possible values are: * profile: User profile images are those associated with the user profile. The first profile image is used to depict the user on search results. * userCustom: User custom images are additional images that can be used on rich text contents. * systemCustom: System custom images are additional images an administrator that can be used on rich text contents. * ad: Advertisement images are associated with an advertisement, be it simple or for web shop. * temp: A temporary image which can upload for later associating with an entity being registered (for example, user or advertisement).\n",
      "enum" : [ "profile", "userCustom", "systemCustom", "ad", "temp" ]
    },
    "UserImageKind" : {
      "type" : "string",
      "description" : "Determines the kind of an user image Possible values are: * profile: User profile images are those associated with the user profile. The first profile image is used to depict the user on search results. * custom: User custom images are additional images that can be used on rich text contents.\n",
      "enum" : [ "profile", "custom" ]
    },
    "Image" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "url" : {
            "type" : "string",
            "description" : "The URL for getting the contents of the image"
          },
          "contentType" : {
            "type" : "string",
            "description" : "MIME type of the stored image"
          },
          "width" : {
            "type" : "integer",
            "description" : "The image width, in pixels"
          },
          "height" : {
            "type" : "integer",
            "description" : "The image height, in pixels"
          },
          "length" : {
            "type" : "integer",
            "description" : "The file size of the image in full size, in bytes"
          }
        }
      } ],
      "description" : "Contains data for displaying an image"
    },
    "ImageView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Image"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "Determines the kind of an image Possible values are: * profile: User profile images are those associated with the user profile. The first profile image is used to depict the user on search results. * userCustom: User custom images are additional images that can be used on rich text contents. * systemCustom: System custom images are additional images an administrator that can be used on rich text contents. * ad: Advertisement images are associated with an advertisement, be it simple or for web shop. * temp: A temporary image which can upload for later associating with an entity being registered (for example, user or advertisement).\n",
            "$ref" : "#/definitions/ImageKind"
          },
          "convertedToJpeg" : {
            "type" : "boolean",
            "description" : "Indicates whether this was originally a PNG format that exceeded the\nmaximum allowed size and was automatically converted to JPEG.\n"
          }
        }
      } ],
      "description" : "Details about an image"
    },
    "ImagesListData" : {
      "type" : "object",
      "properties" : {
        "canManage" : {
          "type" : "boolean",
          "description" : "Does the authenticated user has permission to manage these images?\n"
        },
        "maxImages" : {
          "type" : "integer",
          "description" : "The maximum number of images allowed"
        },
        "images" : {
          "type" : "array",
          "description" : "The list of images",
          "items" : {
            "$ref" : "#/definitions/Image"
          }
        }
      },
      "description" : "Contains information for a list of images, such as permissions and\nthe list of images itself\n"
    },
    "Agreement" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "content" : {
            "type" : "string",
            "description" : "The HTML formatted content of the agreement"
          },
          "contentVersion" : {
            "type" : "integer",
            "description" : "The content version (when updated, the version changes)\n"
          }
        }
      } ],
      "description" : "An agreement the user must accept in order to use the system\n"
    },
    "PasswordStatusEnum" : {
      "type" : "string",
      "description" : "The password status Possible values are: * active: The password is active and valid * neverCreated: The password has never been created for the user * pending: The password was manually allowed (by admins) for the user to generate it, but it was not yet generated (never used for manual passwords) * disabled: The password has been manually disabled * reset: The password has been reset (can be used for login but must then be changed) * temporarilyBlocked: The password is temporarily blocked by exceeding the maximum attempts * indefinitelyBlocked: The password is blocked by exceeding the maximum attempts until it is manually unblocked * expired: The password is expired\n",
      "enum" : [ "active", "neverCreated", "pending", "disabled", "reset", "temporarilyBlocked", "indefinitelyBlocked", "expired" ]
    },
    "PasswordModeEnum" : {
      "type" : "string",
      "description" : "Indicates how a password is handled Possible values are: * manual: Passwords are manually typed by users * generated: Passwords are always generated * otp: One Time Passwords. are always generated and can be used only once * script: Passwords are not stored in Cyclos, but handed-over for a script to verify them. \n  Is normally used to implement single-sign-on with other apps.\n",
      "enum" : [ "manual", "generated", "otp", "script" ]
    },
    "PasswordInputMethodEnum" : {
      "type" : "string",
      "description" : "Determines how passwords should be visually entered by users Possible values are: * textBox: A simple string should be requested * virtualKeyboard: A series of buttons should be presented to allow enter the password.\n",
      "enum" : [ "textBox", "virtualKeyboard" ]
    },
    "PasswordType" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "mode" : {
            "description" : "Indicates how a password is handled Possible values are: * manual: Passwords are manually typed by users * generated: Passwords are always generated * otp: One Time Passwords. are always generated and can be used only once * script: Passwords are not stored in Cyclos, but handed-over for a script to verify them. \n  Is normally used to implement single-sign-on with other apps.\n",
            "$ref" : "#/definitions/PasswordModeEnum"
          }
        }
      } ],
      "description" : "Contains definitions for a password type\n"
    },
    "DataForUserPasswords" : {
      "type" : "object",
      "properties" : {
        "confirmationPasswordInput" : {
          "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
          "$ref" : "#/definitions/PasswordInput"
        },
        "passwords" : {
          "type" : "array",
          "description" : "The status and permissions for each password",
          "items" : {
            "$ref" : "#/definitions/PasswordStatusAndPermissions"
          }
        }
      },
      "description" : "Contains the data used to manage passwords of an user"
    },
    "PasswordStatusAndPermissions" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "description" : "The password type",
          "$ref" : "#/definitions/PasswordType"
        },
        "status" : {
          "description" : "The password status Possible values are: * active: The password is active and valid * neverCreated: The password has never been created for the user * pending: The password was manually allowed (by admins) for the user to generate it, but it was not yet generated (never used for manual passwords) * disabled: The password has been manually disabled * reset: The password has been reset (can be used for login but must then be changed) * temporarilyBlocked: The password is temporarily blocked by exceeding the maximum attempts * indefinitelyBlocked: The password is blocked by exceeding the maximum attempts until it is manually unblocked * expired: The password is expired\n",
          "$ref" : "#/definitions/PasswordStatusEnum"
        },
        "date" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The date this status took place"
        },
        "permissions" : {
          "description" : "The permissions over actions the authenticated user can perform on\nthis password\n",
          "$ref" : "#/definitions/PasswordPermissions"
        }
      },
      "description" : "Contains the status and permissions over a password\n"
    },
    "PasswordPermissions" : {
      "type" : "object",
      "properties" : {
        "change" : {
          "type" : "boolean",
          "description" : "Manually change a generated password or generate another value for a generated password.\n"
        },
        "generate" : {
          "type" : "boolean",
          "description" : "Generate the password value for the first time. Can only be done for the authenticated user himself.\n"
        },
        "allowGeneration" : {
          "type" : "boolean",
          "description" : "For generated passwords that have a setting to require administration authorization, this action is the one that allows the user to generate the password value.\n"
        },
        "disable" : {
          "type" : "boolean",
          "description" : "Disables a password, making it unusable until being enabled again\n"
        },
        "enable" : {
          "type" : "boolean",
          "description" : "Enables a disabled password, either manually disabled or by exceeding the wrong tries, depending on the password type configuration.\n"
        },
        "reset" : {
          "type" : "boolean",
          "description" : "Resets a generated password, making it go back to the pending state. The user will then be able to generate a new value for it.\n"
        },
        "resetAndSend" : {
          "type" : "boolean",
          "description" : "Resets a manual password to a generated value and send it to the user. Can also be used to reset and send the main channel's access password if it is generated. The new password is initially expired, so the user needs to change it on first login.\n"
        },
        "unblock" : {
          "type" : "boolean",
          "description" : "Unblocks a password which has been blocked by exceeding the wrong tries\n"
        }
      },
      "description" : "The permissions the authenticated user can perform over this password\n"
    },
    "ChangePassword" : {
      "type" : "object",
      "properties" : {
        "oldPassword" : {
          "type" : "string",
          "description" : "The current password value. Required when the user is changing his own\npassword. Not used when admins / brokers are changing the password\nof an user they manage.\n"
        },
        "newPassword" : {
          "type" : "string",
          "description" : "The new password value. Required."
        },
        "forceChange" : {
          "type" : "boolean",
          "description" : "Indicates whether the new password needs to be changed on the next\nlogin. Only used when admins / brokers are changing the password\nof an user they manage.\n"
        }
      },
      "description" : "Contains fields used as parameters when changing an user's password\n"
    },
    "GroupKind" : {
      "type" : "string",
      "description" : "The possible kinds of group or group set Possible values are: * groupSet: A group set * adminGroup: An administrator group * brokerGroup: A broker group * memberGroup: A member (regular user) group\n",
      "enum" : [ "groupSet", "adminGroup", "brokerGroup", "memberGroup" ]
    },
    "Group" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "The possible kinds of group or group set Possible values are: * groupSet: A group set * adminGroup: An administrator group * brokerGroup: A broker group * memberGroup: A member (regular user) group\n",
            "$ref" : "#/definitions/GroupKind"
          },
          "groupSet" : {
            "type" : "string",
            "description" : "The internal name or id of the group set of this group.\nOnly makes sense if is an user or broker group. Administrator\ngroups or group sets cannot have a group set.\n"
          }
        }
      } ],
      "description" : "Contains data of a group\n"
    },
    "AccountKind" : {
      "type" : "string",
      "description" : "Indicates whether an account belongs to system or user Possible values are: * system: System account, there is only one account per type in the system. Managed only by administrators * user: User account, there is one account of this type per user.\n",
      "enum" : [ "system", "user" ]
    },
    "AccountHistoryOrderByEnum" : {
      "type" : "string",
      "description" : "Contains the possible 'order by' values when searching for transfers  Possible values are: * dateAsc: The result is ordered by date ascendant * dateDesc: The result is ordered by date descendant * amountAsc: The result is ordered by amount descendant * amountDesc: The result is ordered by amount descendant\n",
      "enum" : [ "dateAsc", "dateDesc", "amountAsc", "amountDesc" ]
    },
    "UserBalancesOrderByEnum" : {
      "type" : "string",
      "description" : "Contains the possible 'order by' values when searching for users with balances  Possible values are: * balanceAsc: User are ordered by balance, lower balances first. * balanceDesc: User are ordered by balance, higher balances first. * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order.\n",
      "enum" : [ "balanceAsc", "balanceDesc", "alphabeticallyAsc", "alphabeticallyDesc" ]
    },
    "BalanceLevelEnum" : {
      "type" : "string",
      "description" : "Contains the possible balance levels on the users with balances search  Possible values are: * low: Low balance, below the medium balance range lower bound * medium: Medium balance, between the lower and upper bounds of the medium balance range * high: High balance, above the medium balance range upper bound\n",
      "enum" : [ "low", "medium", "high" ]
    },
    "Currency" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "symbol" : {
            "type" : "string",
            "description" : "The currency symbol"
          },
          "prefix" : {
            "type" : "string",
            "description" : "The currency prefix when formatting numbers"
          },
          "suffix" : {
            "type" : "string",
            "description" : "The currency suffix when formatting numbers"
          },
          "transactionNumberPattern" : {
            "type" : "string",
            "description" : "If transaction number is enabled for this currency, contains\nthe pattern which is expected, in case of rendering a field for\nusers to type in a transaction number\n"
          },
          "decimalDigits" : {
            "type" : "integer",
            "description" : "The number of decimal digits used by this currency"
          }
        }
      } ],
      "description" : "Reference to a currency"
    },
    "TransferType" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "from" : {
            "description" : "Reference to the source account type",
            "$ref" : "#/definitions/EntityReference"
          },
          "to" : {
            "description" : "Reference to the destination account type",
            "$ref" : "#/definitions/EntityReference"
          }
        }
      } ],
      "description" : "Reference to a transfer type"
    },
    "TransferFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "accountType" : {
            "description" : "Reference to the account type",
            "$ref" : "#/definitions/EntityReference"
          }
        }
      } ],
      "description" : "Reference to a transfer filter"
    },
    "Account" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "number" : {
            "type" : "string",
            "description" : "The account number"
          },
          "type" : {
            "description" : "Reference to the account type",
            "$ref" : "#/definitions/EntityReference"
          }
        }
      } ],
      "description" : "Contains basic data for an account"
    },
    "AccountWithOwner" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Account"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "Indicates whether an account belongs to system or user Possible values are: * system: System account, there is only one account per type in the system. Managed only by administrators * user: User account, there is one account of this type per user.\n",
            "$ref" : "#/definitions/AccountKind"
          },
          "user" : {
            "description" : "Only returned if `kind` is `user`. Is a reference to the owner user.\n",
            "$ref" : "#/definitions/User"
          }
        }
      } ],
      "description" : "Contains account data, plus account owner reference"
    },
    "AccountWithCurrency" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Account"
      }, {
        "type" : "object",
        "properties" : {
          "currency" : {
            "description" : "Reference to the currency",
            "$ref" : "#/definitions/Currency"
          }
        }
      } ],
      "description" : "Contains account data, plus currency reference"
    },
    "AccountWithStatus" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AccountWithCurrency"
      }, {
        "type" : "object",
        "properties" : {
          "status" : {
            "description" : "The account status",
            "$ref" : "#/definitions/AccountStatus"
          }
        }
      } ],
      "description" : "Account data plus status information"
    },
    "AccountWithHistoryStatus" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AccountWithCurrency"
      }, {
        "type" : "object",
        "properties" : {
          "status" : {
            "description" : "The account history status",
            "$ref" : "#/definitions/AccountHistoryStatus"
          }
        }
      } ],
      "description" : "Account data plus account history status information"
    },
    "AccountStatus" : {
      "type" : "object",
      "properties" : {
        "balance" : {
          "type" : "string",
          "format" : "number",
          "description" : "The raw account balance"
        },
        "creditLimit" : {
          "type" : "string",
          "format" : "number",
          "description" : "The maximum negative balance an account may get"
        },
        "upperCreditLimit" : {
          "type" : "string",
          "format" : "number",
          "description" : "The maximum positive balance an account may get"
        },
        "reservedAmount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The reserved amount is part of the raw balance, but cannot be used\nfor payments because of some other events, like payments pending\nauthorization, confirmed webshop orders, scheduled payments (when\nconfigured to reserve the total amount) and so on.\n"
        },
        "availableBalance" : {
          "type" : "string",
          "format" : "number",
          "description" : "The available balance to be used, taking into account the raw\nbalance, credit limit and reserved amount \n"
        },
        "negativeSince" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "If the account is negative, contains the date since it became so \n"
        },
        "ARate" : {
          "type" : "string",
          "format" : "number",
          "description" : "The balance aging counter"
        },
        "DRate" : {
          "type" : "string",
          "format" : "number",
          "description" : "The balance maturity"
        },
        "rateBalanceCorrection" : {
          "type" : "string",
          "format" : "number"
        },
        "virtualRatedBalance" : {
          "type" : "string",
          "format" : "number"
        }
      },
      "description" : "Status information for an account"
    },
    "AccountHistoryStatus" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AccountStatus"
      }, {
        "type" : "object",
        "properties" : {
          "balanceAtBegin" : {
            "type" : "string",
            "format" : "number",
            "description" : "The raw balance at the beginning of the informed period"
          },
          "balanceAtEnd" : {
            "type" : "string",
            "format" : "number",
            "description" : "The raw balance at the end of the informed period"
          },
          "incoming" : {
            "description" : "The summary of incoming transfers",
            "$ref" : "#/definitions/AmountSummary"
          },
          "outgoing" : {
            "description" : "The summary of outgoing transfers",
            "$ref" : "#/definitions/AmountSummary"
          },
          "netInflow" : {
            "type" : "string",
            "format" : "number",
            "description" : "The raw difference between incoming and outgoing transfers in the informed period \n"
          }
        }
      } ],
      "description" : "Contains instant status information, as inherited from `AccountStatus`,  plus status that depend on an account history query parameters\n"
    },
    "DataForAccountHistory" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BaseTransferDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "account" : {
            "description" : "Information about this specific account",
            "$ref" : "#/definitions/AccountWithCurrency"
          },
          "customFieldsInSearch" : {
            "type" : "array",
            "description" : "Detailed references for custom fields that are set to be used\nas search filters \n",
            "items" : {
              "$ref" : "#/definitions/CustomFieldDetailed"
            }
          },
          "customFieldsInList" : {
            "type" : "array",
            "description" : "Simple references for custom fields that are set to be used\non the search result list \n",
            "items" : {
              "$ref" : "#/definitions/CustomField"
            }
          },
          "transferStatusFlows" : {
            "type" : "array",
            "description" : "References to the allowed transfer status flows for this account \n",
            "items" : {
              "$ref" : "#/definitions/TransferStatusFlow"
            }
          }
        }
      } ],
      "description" : "Contains data used to search the history of a given account"
    },
    "AccountHistoryResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "date" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The transfer date and time"
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The transfer amount. May be positive or negative."
          },
          "relatedAccount" : {
            "description" : "The account that either received / sent the balance",
            "$ref" : "#/definitions/AccountWithOwner"
          },
          "type" : {
            "description" : "The transfer type",
            "$ref" : "#/definitions/EntityReference"
          },
          "description" : {
            "type" : "string",
            "description" : "The transaction description. Is optional."
          },
          "transactionNumber" : {
            "type" : "string",
            "description" : "The transaction number identifying this balance transfer. The\ncurrency configuration has the definition on whether transaction\nnumbers are enabled and which format they have.\n"
          },
          "customValues" : {
            "type" : "object",
            "description" : "Holds the custom field values, keyed by field internal name or id. The format of the value depends on the custom field type. In order to lookup the custom fields, use the `GET /{owner}/accounts/{accountType}/data-for-history` operation, and lookup each field by either internal name (if configured) or id. Example: `{..., \"customValues\": {\"linkedAccount\": \"123456789\"}}`\n",
            "additionalProperties" : {
              "type" : "string"
            }
          },
          "transaction" : {
            "description" : "If this balance transfer was originated from a transaction (like a\npayment or scheduled payment), contains the reference to this\ntransaction.\n",
            "$ref" : "#/definitions/Transaction"
          },
          "statuses" : {
            "type" : "object",
            "description" : "contains the current status internal name or id, keyed by the flow\ninternal name or id\n",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      } ],
      "description" : "Represents a balance transfer between accounts, as viewed from the\npoint-of-view account of a a specific account. This means that credits\nwill have a positive amount, while debits will be negative.\n"
    },
    "AmountSummary" : {
      "type" : "object",
      "properties" : {
        "count" : {
          "type" : "integer",
          "description" : "The number of entries"
        },
        "sum" : {
          "type" : "string",
          "format" : "number",
          "description" : "The amount sum"
        },
        "average" : {
          "type" : "string",
          "format" : "number",
          "description" : "The amount average"
        }
      },
      "description" : "Contains summarized statistics over amounts\n"
    },
    "DataForUserBalancesSearch" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BaseUserDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "accountTypes" : {
            "type" : "array",
            "description" : "The available account types for the search",
            "items" : {
              "$ref" : "#/definitions/EntityReference"
            }
          }
        }
      } ],
      "description" : "Data used for an user search together with account balances"
    },
    "UserBalancesSummary" : {
      "type" : "object",
      "properties" : {
        "low" : {
          "description" : "Summary of low balances. Is only returned when a medium balance range\nis defined, either in the account type or in the query parameters. \n",
          "$ref" : "#/definitions/AmountSummary"
        },
        "medium" : {
          "description" : "Summary of medium balances. Is only returned when a medium balance\nrange is defined, either in the account type or in the query\nparameters. \n",
          "$ref" : "#/definitions/AmountSummary"
        },
        "high" : {
          "description" : "Summary of high balances. Is only returned when a medium balance\nrange is defined, either in the account type or in the query\nparameters. \n",
          "$ref" : "#/definitions/AmountSummary"
        },
        "total" : {
          "description" : "Summary of all balances. \n",
          "$ref" : "#/definitions/AmountSummary"
        }
      },
      "description" : "Contains summarized information about balances per range, plus the total\n"
    },
    "UserWithBalanceResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/UserResult"
      }, {
        "type" : "object",
        "properties" : {
          "balance" : {
            "type" : "string",
            "format" : "number",
            "description" : "The raw account balance"
          },
          "balanceLevel" : {
            "description" : "Contains the possible balance levels on the users with balances search  Possible values are: * low: Low balance, below the medium balance range lower bound * medium: Medium balance, between the lower and upper bounds of the medium balance range * high: High balance, above the medium balance range upper bound\n",
            "$ref" : "#/definitions/BalanceLevelEnum"
          },
          "negativeSince" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date since the account has been negative"
          }
        }
      } ],
      "description" : "Result of an user search with balance\n"
    },
    "TransferKind" : {
      "type" : "string",
      "description" : "Indicates the reason the transfer was created Possible values are: * payment: A transfer generated by a direct payment or accepting a webshop order * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * recurringPayment: A transfer generated when processing a recurring payment * chargeback: A transfer which is a chargeback of another transfer * initialCredit: A transfer which is the initial credit for a newly created account * transferFee: A transfer generated by a transfer fee charge * accountFee: A transfer generated by an account fee charge * import: An imported transfer\n",
      "enum" : [ "payment", "scheduledPaymentInstallment", "recurringPayment", "chargeback", "initialCredit", "transferFee", "accountFee", "import" ]
    },
    "TransferDirectionEnum" : {
      "type" : "string",
      "description" : "Indicates whether from an account POV a transfer is a credit or debit Possible values are: * credit: The transfer impacts the balance positively * debit: The transfer impacts the balance negatively\n",
      "enum" : [ "credit", "debit" ]
    },
    "Transfer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "date" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The transfer date and time"
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The transfer amount. May be positive or negative."
          },
          "type" : {
            "description" : "The transfer type",
            "$ref" : "#/definitions/EntityReference"
          },
          "currency" : {
            "description" : "The transfer currency",
            "$ref" : "#/definitions/Currency"
          },
          "from" : {
            "description" : "The account that sent the balance",
            "$ref" : "#/definitions/AccountWithOwner"
          },
          "to" : {
            "description" : "The account that received the balance",
            "$ref" : "#/definitions/AccountWithOwner"
          },
          "transactionNumber" : {
            "type" : "string",
            "description" : "The transaction number identifying this balance transfer. The\ncurrency configuration has the definition on whether transaction\nnumbers are enabled and which format they have.\n"
          },
          "statuses" : {
            "type" : "array",
            "description" : "Contains the current status for each status flow this transfer has\n",
            "items" : {
              "$ref" : "#/definitions/TransferStatus"
            }
          }
        }
      } ],
      "description" : "Reference to a balance transfer between accounts\n"
    },
    "TransferView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Transfer"
      }, {
        "type" : "object",
        "properties" : {
          "parent" : {
            "description" : "Reference to the parent transfer that generated this one, if any\n",
            "$ref" : "#/definitions/Transfer"
          },
          "children" : {
            "type" : "array",
            "description" : "Reference to the transfers generated by this one, if any\n",
            "items" : {
              "$ref" : "#/definitions/Transfer"
            }
          },
          "transaction" : {
            "description" : "If this balance transfer was originated from a transaction (like\na payment or scheduled payment), contains the reference to this\ntransaction. Only returned if this `TransferView` is not already\nin a `TransactionView`.\n",
            "$ref" : "#/definitions/TransactionView"
          },
          "ARate" : {
            "type" : "string",
            "format" : "number",
            "description" : "The balance aging counter"
          },
          "DRate" : {
            "type" : "string",
            "format" : "number",
            "description" : "The balance maturity"
          },
          "statusFlows" : {
            "type" : "array",
            "description" : "List with each status this transfer has, with additional\ninformation, such as the flow and the log\n",
            "items" : {
              "$ref" : "#/definitions/TransferStatusFlowForTransferView"
            }
          },
          "canChargeback" : {
            "type" : "boolean",
            "description" : "Can the authenticated user chargeback this transfer?\n"
          },
          "confirmationPasswordInput" : {
            "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
            "$ref" : "#/definitions/PasswordInput"
          },
          "usersWhichCanAddToContacts" : {
            "description" : "Reference to none, one of (from or to) or both subjects of a transaction (or transfer)  Possible values are: * none: Reference to none of the transaction subjects * from: Reference to the transaction from * to: Reference to the transaction to * both: Reference to both from and to subjects of the transaction\n",
            "$ref" : "#/definitions/TransactionSubjectsEnum"
          },
          "usersWhichCanViewProfile" : {
            "description" : "Reference to none, one of (from or to) or both subjects of a transaction (or transfer)  Possible values are: * none: Reference to none of the transaction subjects * from: Reference to the transaction from * to: Reference to the transaction to * both: Reference to both from and to subjects of the transaction\n",
            "$ref" : "#/definitions/TransactionSubjectsEnum"
          }
        }
      } ],
      "description" : "Details about a balance transfer between accounts\n"
    },
    "TransferStatusFlow" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "statuses" : {
            "type" : "array",
            "description" : "All statuses this flow has",
            "items" : {
              "$ref" : "#/definitions/EntityReference"
            }
          }
        }
      } ],
      "description" : "A transfer status flow determines a status a transfer may have. For each\nflow the transfer participates (can be multiple) the transfer will have a\nstatus. The transition between states is also defined on the flow.\n"
    },
    "TransferStatus" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "flow" : {
            "description" : "The status flow",
            "$ref" : "#/definitions/EntityReference"
          }
        }
      } ],
      "description" : "Reference to a status and its flow\n"
    },
    "TransferStatusFlowForTransferView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "canManage" : {
            "type" : "boolean",
            "description" : "Can this status flow be managed by the authenticated user?\n"
          },
          "log" : {
            "type" : "array",
            "description" : "A log of status changes for this flow",
            "items" : {
              "$ref" : "#/definitions/TransferStatusLog"
            }
          }
        }
      } ],
      "description" : "Contains other data for a transfer status flow when viewing a transfer.\n"
    },
    "TransferStatusLog" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "by" : {
            "description" : "The user that performed the change",
            "$ref" : "#/definitions/User"
          },
          "date" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date / time the action was performed"
          },
          "status" : {
            "description" : "The new status",
            "$ref" : "#/definitions/EntityReference"
          },
          "comments" : {
            "type" : "string",
            "description" : "Comments provided by the user which performed the change\n"
          }
        }
      } ],
      "description" : "Details of a change that took place in a transfer status."
    },
    "BaseTransferDataForSearch" : {
      "type" : "object",
      "properties" : {
        "transferFilters" : {
          "type" : "array",
          "description" : "References for transfer filters, which can be used to filter\nentries by transfer type\n",
          "items" : {
            "$ref" : "#/definitions/TransferFilter"
          }
        },
        "channels" : {
          "type" : "array",
          "description" : "References for channels which can be used to filter entries\nby transfers generated on a specific channel. Is only returned\nif the authenticated user is an administrator.\n",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "groups" : {
          "type" : "array",
          "description" : "Groups that can be used to filter entries, so that only transfers\nfrom or to users of those groups are returned on search. Is only\nreturned if the authenticated user is an administrator.\n",
          "items" : {
            "$ref" : "#/definitions/Group"
          }
        },
        "accessClients" : {
          "type" : "array",
          "description" : "References for access clients which can be used to filter entries\nby transfers generated by a specific access client \n",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "operators" : {
          "type" : "array",
          "description" : "References for operators, which can be used to filter entries\nby transfers performed or received by that specific operator \n",
          "items" : {
            "$ref" : "#/definitions/User"
          }
        },
        "preselectedPeriods" : {
          "type" : "array",
          "description" : "Contains the pre-selected period filter ranges according to\nthe Cyclos configuration  \n",
          "items" : {
            "$ref" : "#/definitions/PreselectedPeriod"
          }
        }
      },
      "description" : "Contains basic information used to search for transfers"
    },
    "TransferDataForSearch" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BaseTransferDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "accountTypes" : {
            "type" : "array",
            "description" : "References for the account types\n",
            "items" : {
              "$ref" : "#/definitions/EntityReference"
            }
          },
          "currencies" : {
            "type" : "array",
            "description" : "References for the available currencies\n",
            "items" : {
              "$ref" : "#/definitions/Currency"
            }
          },
          "defaultKinds" : {
            "type" : "array",
            "description" : "The transfer kinds that should be searched by default Possibles values for each array element are: * payment: A transfer generated by a direct payment or accepting a webshop order * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * recurringPayment: A transfer generated when processing a recurring payment * chargeback: A transfer which is a chargeback of another transfer * initialCredit: A transfer which is the initial credit for a newly created account * transferFee: A transfer generated by a transfer fee charge * accountFee: A transfer generated by an account fee charge * import: An imported transfer\n",
            "items" : {
              "$ref" : "#/definitions/TransferKind"
            }
          },
          "defaultHideChargedBack" : {
            "type" : "boolean",
            "description" : "Indicats whether clients should set the query to hide transfers that were charged-back by default, by setting the `chargedBack` parameter to `false` on search.\n"
          }
        }
      } ],
      "description" : "Contains data for searching transfers over multiple accounts"
    },
    "TransactionKind" : {
      "type" : "string",
      "description" : "The kind of a transaction  Possible values are: * payment: A direct payment * recurringPayment: A payment which is processed again periodically * scheduledPayment: A scheduled payment which is either a payment scheduled for a future date or has multiple installments * paymentRequest: A request for another user to accept a payment  * externalPayment: A payment to an external user * chargeback: Chargeback of a given transfer * import: An imported transaction * order: Transaction generated by confirming an order\n",
      "enum" : [ "payment", "recurringPayment", "scheduledPayment", "paymentRequest", "externalPayment", "chargeback", "import", "order" ]
    },
    "TransactionSubjectsEnum" : {
      "type" : "string",
      "description" : "Reference to none, one of (from or to) or both subjects of a transaction (or transfer)  Possible values are: * none: Reference to none of the transaction subjects * from: Reference to the transaction from * to: Reference to the transaction to * both: Reference to both from and to subjects of the transaction\n",
      "enum" : [ "none", "from", "to", "both" ]
    },
    "Transaction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "transactionNumber" : {
            "type" : "string",
            "description" : "The transaction number identifying this balance transfer. The\ncurrency configuration has the definition on whether transaction\nnumbers are enabled and which format they have.\n"
          },
          "kind" : {
            "description" : "The transaction kind. For example, if the front end has distinct views for a regular payment, scheduled payment and so on, this information is useful to determine the actual view. Possible values are: * payment: A direct payment * recurringPayment: A payment which is processed again periodically * scheduledPayment: A scheduled payment which is either a payment scheduled for a future date or has multiple installments * paymentRequest: A request for another user to accept a payment  * externalPayment: A payment to an external user * chargeback: Chargeback of a given transfer * import: An imported transaction * order: Transaction generated by confirming an order\n",
            "$ref" : "#/definitions/TransactionKind"
          },
          "date" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The transfer date and time"
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The transfer amount. May be positive or negative."
          },
          "fromKind" : {
            "description" : "The from account kind",
            "$ref" : "#/definitions/AccountKind"
          },
          "fromUser" : {
            "description" : "The user that performed this transaction. Is only returned if\n`fromKind` is `user`.\n",
            "$ref" : "#/definitions/User"
          },
          "toKind" : {
            "description" : "The to account kind",
            "$ref" : "#/definitions/AccountKind"
          },
          "toUser" : {
            "description" : "The user that performed this transaction. Is only returned if\n`toKind` is `user`.\n",
            "$ref" : "#/definitions/User"
          },
          "type" : {
            "description" : "The transaction type",
            "$ref" : "#/definitions/TransferType"
          },
          "currency" : {
            "description" : "The transaction currency. Is only returned if this object is not\nembedded in a `TransferView`.\n",
            "$ref" : "#/definitions/Currency"
          },
          "authorizationStatus" : {
            "description" : "The status regarding authorization a transaction is in. If configured, transactions can require one or more levels of authorization in order to be processed. If a transaction has the this status null, it means it never went through the authorization process.  Possible values are: * pending: The transaction is pending authorization * canceled: The authorization submission was canceled by the submitter * denied: The authorization was denied * authorized: The transaction was fully authorized and is processed\n",
            "$ref" : "#/definitions/AuthorizationStatusEnum"
          },
          "description" : {
            "type" : "string",
            "description" : "The transaction description. Is optional."
          }
        }
      } ],
      "description" : "Reference to a transaction"
    },
    "TransactionDataForSearch" : {
      "type" : "object",
      "properties" : {
        "channels" : {
          "type" : "array",
          "description" : "References for channels which can be used to filter entries\nby transfers generated on a specific channel. Is only returned\nif the authenticated user is an administrator.\n",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "groups" : {
          "type" : "array",
          "description" : "Groups that can be used to filter entries, so that only transfers\nfrom or to users of those groups are returned on search. Is only\nreturned if the authenticated user is an administrator.\n",
          "items" : {
            "$ref" : "#/definitions/Group"
          }
        },
        "accessClients" : {
          "type" : "array",
          "description" : "References for access clients which can be used to filter entries\nby transfers generated by a specific access client \n",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "operators" : {
          "type" : "array",
          "description" : "References for operators, which can be used to filter entries\nby transfers performed or received by that specific operator \n",
          "items" : {
            "$ref" : "#/definitions/User"
          }
        },
        "canViewAuthorized" : {
          "type" : "boolean",
          "description" : "Can the authenticated user view authorized transactions of this owner? \n"
        },
        "canViewScheduled" : {
          "type" : "boolean",
          "description" : "Can the authenticated user view scheduled payments of this owner? \n"
        }
      },
      "description" : "Contains data used to search transactions for a given owner"
    },
    "TransactionResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "The transaction kind. For example, if the front end has distinct views for a regular payment, scheduled payment and so on, this information is useful to determine the actual view. Possible values are: * payment: A direct payment * recurringPayment: A payment which is processed again periodically * scheduledPayment: A scheduled payment which is either a payment scheduled for a future date or has multiple installments * paymentRequest: A request for another user to accept a payment  * externalPayment: A payment to an external user * chargeback: Chargeback of a given transfer * import: An imported transaction * order: Transaction generated by confirming an order\n",
            "$ref" : "#/definitions/TransactionKind"
          },
          "transactionNumber" : {
            "type" : "string",
            "description" : "The transaction number identifying this balance transfer. The\ncurrency configuration has the definition on whether transaction\nnumbers are enabled and which format they have.\n"
          },
          "date" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The transfer date and time"
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The transfer amount. May be positive or negative."
          },
          "relatedKind" : {
            "description" : "The related account owner kind",
            "$ref" : "#/definitions/AccountKind"
          },
          "relatedUser" : {
            "description" : "The user that either performed or received this transaction.\nIs only returned if `relatedKind` is `user`.\n",
            "$ref" : "#/definitions/User"
          },
          "type" : {
            "description" : "The transaction type",
            "$ref" : "#/definitions/TransferType"
          },
          "currency" : {
            "type" : "string",
            "description" : "Either internal name or id of the transaction currency.\n"
          },
          "authorizationStatus" : {
            "description" : "The status regarding authorization a transaction is in. If configured, transactions can require one or more levels of authorization in order to be processed. If a transaction has the this status null, it means it never went through the authorization process.  Possible values are: * pending: The transaction is pending authorization * canceled: The authorization submission was canceled by the submitter * denied: The authorization was denied * authorized: The transaction was fully authorized and is processed\n",
            "$ref" : "#/definitions/AuthorizationStatusEnum"
          },
          "description" : {
            "type" : "string",
            "description" : "The transaction description. Is optional."
          }
        }
      } ],
      "description" : "Represents a transaction, as viewed from the point-of-view of an account\nowner. This means that credits will have a positive amount, while debits\nwill be negative.\n"
    },
    "TransactionView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Transaction"
      }, {
        "type" : "object",
        "properties" : {
          "channel" : {
            "description" : "The channel this transaction was performed on",
            "$ref" : "#/definitions/EntityReference"
          },
          "accessClient" : {
            "description" : "The access client in use when this transaction was performed\n",
            "$ref" : "#/definitions/EntityReference"
          },
          "usersWhichCanAddToContacts" : {
            "description" : "Reference to none, one of (from or to) or both subjects of a transaction (or transfer)  Possible values are: * none: Reference to none of the transaction subjects * from: Reference to the transaction from * to: Reference to the transaction to * both: Reference to both from and to subjects of the transaction\n",
            "$ref" : "#/definitions/TransactionSubjectsEnum"
          },
          "usersWhichCanViewProfile" : {
            "description" : "Reference to none, one of (from or to) or both subjects of a transaction (or transfer)  Possible values are: * none: Reference to none of the transaction subjects * from: Reference to the transaction from * to: Reference to the transaction to * both: Reference to both from and to subjects of the transaction\n",
            "$ref" : "#/definitions/TransactionSubjectsEnum"
          },
          "by" : {
            "description" : "The user that actually performed the action.\nMay be different than the from, for example, an administrator\ncan perform payments in behalf of other users\n",
            "$ref" : "#/definitions/User"
          },
          "receivedBy" : {
            "description" : "The operator that actually received the payment. \nOnly available if some other user has paid directly to it \nor the operator has received the payment va POS.\n",
            "$ref" : "#/definitions/User"
          },
          "received" : {
            "type" : "boolean",
            "description" : "True if the payment was received va POS.\n"
          },
          "customValues" : {
            "type" : "array",
            "description" : "The list of custom field values",
            "items" : {
              "$ref" : "#/definitions/CustomFieldValue"
            }
          },
          "confirmationPasswordInput" : {
            "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
            "$ref" : "#/definitions/PasswordInput"
          },
          "authorizationLevelData" : {
            "description" : "Only returned if the `kind` is either `payment`, `scheduledPayment` or `recurringPayment` and the transaction is pending for authorization. Contains data related to the current autorization level that can be authorized / denied.\n",
            "$ref" : "#/definitions/AuthorizationLevelData"
          },
          "authorizationPermissions" : {
            "description" : "Permissions the authenticated user has over this payment regarding authorizations.",
            "$ref" : "#/definitions/AuthorizationPermissions"
          },
          "authorizations" : {
            "type" : "array",
            "description" : "Contains the details of the authorizations this payment has (for the previous levels). To see the final status of the payment please check the `authorizationStatus` property. \n",
            "items" : {
              "$ref" : "#/definitions/Authorization"
            }
          },
          "transfer" : {
            "description" : "Only returned if the `kind` is `payment`. This is the transfer generated when the payment was processed. Will be null if the went through authorization and was not authorized. Only returned if this `TransactionView` is not already in a `TransactionView`. \n",
            "$ref" : "#/definitions/TransferView"
          },
          "scheduledPaymentStatus" : {
            "description" : "The status of a scheduled payment Possible values are: * open: The scheduled payment has open installments * closed: The scheduled payment is closed * blocked: The scheduled payment is blocked - won't have any installment processed until being unblocked again * canceled: The scheduled payment, as well as all open installments were canceled\n",
            "$ref" : "#/definitions/ScheduledPaymentStatusEnum"
          },
          "dueAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "Only returned if the `kind` is `scheduledPayment`. Means the amount that is still needs to be paid until the last installment.\n"
          },
          "installments" : {
            "type" : "array",
            "description" : "Only returned if the `kind` is `scheduledPayment`. Contains the installment references.\n",
            "items" : {
              "$ref" : "#/definitions/ScheduledPaymentInstallment"
            }
          },
          "recurringPaymentStatus" : {
            "description" : "The status of a recurring payment Possible values are: * open: The recurring payment is open, as there are more future occurrences * closed: The recurring payment is closed, as the last scheduled occurrence was processed * canceled: The recurring payment was manually canceled\n",
            "$ref" : "#/definitions/RecurringPaymentStatusEnum"
          },
          "nextOccurrenceDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Only returned if the `kind` is `recurringPayment`. The scheduled date for the next occurrence.\n"
          },
          "occurrenceInterval" : {
            "description" : "Only returned if the `kind` is `recurringPayment`. The interval between occurrences.\n",
            "$ref" : "#/definitions/TimeInterval"
          },
          "occurrencesCount" : {
            "type" : "integer",
            "description" : "Only returned if the `kind` is `recurringPayment`. The programmed number of occurrences. If not set, means the payment will be processed until manually canceled.\n"
          },
          "occurrences" : {
            "type" : "array",
            "description" : "Only returned if the `kind` is `recurringPayment`. A list with all occurrences this payment has.\n",
            "items" : {
              "$ref" : "#/definitions/RecurringPaymentOccurrence"
            }
          },
          "originalTransfer" : {
            "description" : "Only returned if the `kind` is `chargeback`. This is the original transfer that has been charged back.\n",
            "$ref" : "#/definitions/Transfer"
          },
          "chargebackTransfer" : {
            "description" : "Only returned if the `kind` is `chargeback`. This is the transfer which performed the chargeback.\n",
            "$ref" : "#/definitions/Transfer"
          },
          "comments" : {
            "type" : "string",
            "description" : "Only returned if the `kind` is either `paymentRequest` or `externalPayment`. The comments the user informed when performing the payment.\n"
          },
          "expirationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Only returned if the `kind` is either `paymentRequest` or `externalPayment`. The deadline for the payment to be processed. If no user is registered with either e-mail or mobile phone matching this external payment, it is canceled.\n"
          },
          "paymentRequestStatus" : {
            "description" : "The status of a payment request Possible values are: * open: The payment request is open and can be accepted * scheduled: The payment request has been accepted, and scheduled for processing on a future date * processed: The payment request was processed, and either a direct or scheduled payment was created from it * denied: The payment request was denied by the receiver * canceled: The payment request was canceled * expired: The payment request has expired - the received did not respond until the expiration date\n",
            "$ref" : "#/definitions/PaymentRequestStatusEnum"
          },
          "processDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Only returned if the `kind` is either `paymentRequest` and `status` is `processed`. The date the payment request was confirmed.\n"
          },
          "transaction" : {
            "description" : "Only returned if the `kind` is either `paymentRequest` and `status` is `processed`. Reference to the transaction that was generated when processing this payment request.\n",
            "$ref" : "#/definitions/Transaction"
          },
          "smsCode" : {
            "type" : "string",
            "description" : "Only returned if the `kind` is either `paymentRequest` and `status` is not `processed`. The code that can be used by the receiver to confirm this payment request via SMS operation.\n"
          },
          "scheduled" : {
            "type" : "boolean",
            "description" : "Only returned if the `kind` is `paymentRequest`. Indicates whether a scheduled payment (`true`) or a regular payment (`false`) will be generated once this payment request is confirmed.\n"
          },
          "installmentsCount" : {
            "type" : "integer",
            "description" : "Only returned if the `kind` is `paymentRequest` and `scheduled` is `true`. Indicates the number of installments to be generated.\n"
          },
          "firstInstallmentIsImmediate" : {
            "type" : "boolean",
            "description" : "Only returned if the `kind` is `paymentRequest` and `scheduled` is `true`. Indicates whether the first installment should be processed immediately when the payment request is confirmed.\n"
          },
          "externalPaymentStatus" : {
            "description" : "The status of an external payment Possible values are: * pending: The external payment is pending, awaiting the destination user to be activated in Cyclos * expired: The external payment has expired without the destination user activation * processed: The external payment was processed, and the destination payment was created * failed: The external payment has failed processing * canceled: The external payment was canceled\n",
            "$ref" : "#/definitions/ExternalPaymentStatusEnum"
          },
          "toPrincipalType" : {
            "description" : "Only returned if the `kind` is `externalPayment`.\nIs the user identification method for this external payment\n(for example, e-mail or mobile phone).\n",
            "$ref" : "#/definitions/EntityReference"
          },
          "toPrincipalValue" : {
            "type" : "string",
            "description" : "Only returned if the `kind` is `externalPayment`.\nIs the user identification value for this external payment\n(for example, the e-mail or mobile phone values).\n"
          }
        }
      } ],
      "description" : "Details about a transaction\n"
    },
    "ScheduledPaymentInstallment" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "number" : {
            "type" : "integer",
            "description" : "The installment number."
          },
          "dueDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The installment due date."
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The installment amount"
          },
          "status" : {
            "description" : "The status of a scheduled payment installment Possible values are: * scheduled: The installment is scheduled for a future date * processed: The installment was processed, generating a transfer * canceled: The installment was canceled * settled: The installment was marked as settled by the receiver * failed: The installment processing failed, for example, because there was no funds in the source account * blocked: The installment is blocked, and won't be automatically processed on its due date\n",
            "$ref" : "#/definitions/ScheduledPaymentInstallmentStatusEnum"
          },
          "by" : {
            "description" : "The user that performed an status change. For example, who\nmanually paid, settled or canceled an open installment\n",
            "$ref" : "#/definitions/User"
          },
          "transferId" : {
            "type" : "string",
            "description" : "Only if the installment was processed, contains the internal\nidentifier of the generated transfer.\n"
          },
          "transferDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date the transfer was processed."
          }
        }
      } ],
      "description" : "Contains details about an installment of a scheduled payment\n"
    },
    "RecurringPaymentOccurrence" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "number" : {
            "type" : "integer",
            "description" : "The occurrence number."
          },
          "date" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The occurrence date."
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The installment amount"
          },
          "status" : {
            "description" : "The status of a recurring payment occurrence Possible values are: * processed: The occurrence was correctly processed, generating a transfer * failed: The occurrence has failed processing (probably because there was not enough funds in the payer account)\n",
            "$ref" : "#/definitions/RecurringPaymentOccurrenceStatusEnum"
          },
          "by" : {
            "description" : "The user that performed an status change. For example, who\nmanually paid, settled or canceled an open installment\n",
            "$ref" : "#/definitions/User"
          },
          "transferId" : {
            "type" : "string",
            "description" : "Only if the installment was processed, contains the internal\nidentifier of the generated transfer.\n"
          },
          "transferDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date the transfer was processed. It might happen that the\noccurrence has first failed, then later processed\n"
          }
        }
      } ],
      "description" : "Contains details about an occurrence of a recurring payment\n"
    },
    "AuthorizationStatusEnum" : {
      "type" : "string",
      "description" : "The status regarding authorization a transaction is in. If configured, transactions can require one or more levels of authorization in order to be processed. If a transaction has the this status null, it means it never went through the authorization process.  Possible values are: * pending: The transaction is pending authorization * canceled: The authorization submission was canceled by the submitter * denied: The authorization was denied * authorized: The transaction was fully authorized and is processed\n",
      "enum" : [ "pending", "canceled", "denied", "authorized" ]
    },
    "AuthorizationLevelData" : {
      "type" : "object",
      "properties" : {
        "allowBroker" : {
          "type" : "boolean",
          "description" : "Indicates that any of the payer's brokers can authorize this level."
        },
        "allowPayer" : {
          "type" : "boolean",
          "description" : "Indicates that the payer can authorize this level."
        },
        "allowReceiver" : {
          "type" : "boolean",
          "description" : "Indicates that the payer can authorize this level."
        },
        "allowAdmin" : {
          "type" : "boolean",
          "description" : "Indicates that an administrator can authorize this level."
        },
        "brokers" : {
          "type" : "array",
          "description" : "Contains the brokers that can authorize this level.",
          "items" : {
            "$ref" : "#/definitions/User"
          }
        }
      },
      "description" : "Contains detailed data of a payment's authorization level.\n"
    },
    "AuthorizationPermissions" : {
      "type" : "object",
      "properties" : {
        "authorize" : {
          "type" : "boolean",
          "description" : "The payment can be authorized."
        },
        "deny" : {
          "type" : "boolean",
          "description" : "The payment can be denied."
        },
        "cancel" : {
          "type" : "boolean",
          "description" : "The payment can be cenceled regardless the current authorization level."
        }
      },
      "description" : "Permissions the user has over a pending payment."
    },
    "Authorization" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "by" : {
            "$ref" : "#/definitions/User"
          },
          "comments" : {
            "type" : "string",
            "description" : "The authorizer's comment."
          },
          "date" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "When the authorization was made."
          },
          "level" : {
            "type" : "integer",
            "description" : "The level number."
          }
        }
      } ],
      "description" : "Contains details of an authorization."
    },
    "ScheduledPaymentStatusEnum" : {
      "type" : "string",
      "description" : "The status of a scheduled payment Possible values are: * open: The scheduled payment has open installments * closed: The scheduled payment is closed * blocked: The scheduled payment is blocked - won't have any installment processed until being unblocked again * canceled: The scheduled payment, as well as all open installments were canceled\n",
      "enum" : [ "open", "closed", "blocked", "canceled" ]
    },
    "ScheduledPaymentInstallmentStatusEnum" : {
      "type" : "string",
      "description" : "The status of a scheduled payment installment Possible values are: * scheduled: The installment is scheduled for a future date * processed: The installment was processed, generating a transfer * canceled: The installment was canceled * settled: The installment was marked as settled by the receiver * failed: The installment processing failed, for example, because there was no funds in the source account * blocked: The installment is blocked, and won't be automatically processed on its due date\n",
      "enum" : [ "scheduled", "processed", "canceled", "settled", "failed", "blocked" ]
    },
    "RecurringPaymentStatusEnum" : {
      "type" : "string",
      "description" : "The status of a recurring payment Possible values are: * open: The recurring payment is open, as there are more future occurrences * closed: The recurring payment is closed, as the last scheduled occurrence was processed * canceled: The recurring payment was manually canceled\n",
      "enum" : [ "open", "closed", "canceled" ]
    },
    "RecurringPaymentOccurrenceStatusEnum" : {
      "type" : "string",
      "description" : "The status of a recurring payment occurrence Possible values are: * processed: The occurrence was correctly processed, generating a transfer * failed: The occurrence has failed processing (probably because there was not enough funds in the payer account)\n",
      "enum" : [ "processed", "failed" ]
    },
    "PaymentRequestStatusEnum" : {
      "type" : "string",
      "description" : "The status of a payment request Possible values are: * open: The payment request is open and can be accepted * scheduled: The payment request has been accepted, and scheduled for processing on a future date * processed: The payment request was processed, and either a direct or scheduled payment was created from it * denied: The payment request was denied by the receiver * canceled: The payment request was canceled * expired: The payment request has expired - the received did not respond until the expiration date\n",
      "enum" : [ "open", "scheduled", "processed", "denied", "canceled", "expired" ]
    },
    "ExternalPaymentStatusEnum" : {
      "type" : "string",
      "description" : "The status of an external payment Possible values are: * pending: The external payment is pending, awaiting the destination user to be activated in Cyclos * expired: The external payment has expired without the destination user activation * processed: The external payment was processed, and the destination payment was created * failed: The external payment has failed processing * canceled: The external payment was canceled\n",
      "enum" : [ "pending", "expired", "processed", "failed", "canceled" ]
    },
    "PerformTransaction" : {
      "type" : "object",
      "properties" : {
        "subject" : {
          "type" : "string",
          "description" : "The payment destination (in case of perform payment) or payer (in case of receive payment). Either an user principal (id, login name,  etc) or the word `system` when the payment is to be performed to / from a system account. \n"
        },
        "amount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The transaction amount"
        },
        "description" : {
          "type" : "string",
          "description" : "The (optional) transaction description"
        },
        "currency" : {
          "type" : "string",
          "description" : "The currency id or internal name. Only used when not specifying a\npayment type. In this case, will narrow the search for the it.\n"
        },
        "type" : {
          "type" : "string",
          "description" : "The payment type, either the id or qualified internal name (in the\nform `fromAccountType.paymentType`). If no payment type is specified,\nif a single one is possible, it will be used. If a currency is\nspecified, it will be taken into account in order to find the payment\ntype. If, however, there would be multiple possibilities, a\nvalidation error is returned.\n"
        },
        "customValues" : {
          "type" : "object",
          "description" : "Holds the custom field values, keyed by field internal name or id. The format of the value depends on the custom field type.\n",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "nfcChallence" : {
          "type" : "string",
          "description" : "If this transacction is used with a NFC token, must be the challenge\n(as returned by the server) encrypted by the NFC chip, encoded in HEX\nform (2 hex chars per byte).\n"
        }
      },
      "description" : "Base definitions for performing a transaction",
      "x-abstract" : true
    },
    "PerformInternalTransaction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PerformTransaction"
      }, {
        "type" : "object",
        "properties" : {
          "fromName" : {
            "type" : "string",
            "description" : "If the payment type allows setting a custom name for the origin\naccount, is its name. If not allowed, is ignored. For example,\nintegration with other systems could use 'Bank account [IBAN]'.\n"
          },
          "toName" : {
            "type" : "string",
            "description" : "If the payment type allows setting a custom name for the destination\naccount, is its name. If not allowed, is ignored. For example,\nintegration with other systems could use 'Bank account [IBAN]'.\n"
          }
        }
      } ],
      "description" : "Base definitions to performing a transaction to an internal account (any\nexcept `externalPayment`, or `chargeback` which is performed distinctly).\n"
    },
    "TransactionPreview" : {
      "type" : "object",
      "properties" : {
        "confirmationMessage" : {
          "type" : "string",
          "description" : "If configured in the payment type, is a message to be shown to the\nuser before confirming the transaction\n"
        },
        "confirmationPasswordInput" : {
          "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
          "$ref" : "#/definitions/PasswordInput"
        },
        "fromAccount" : {
          "description" : "A reference to the origin account",
          "$ref" : "#/definitions/AccountWithOwner"
        },
        "totalAmount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The final total transaction amount"
        },
        "customValues" : {
          "type" : "array",
          "description" : "The list of custom field values, in a detailed view",
          "items" : {
            "$ref" : "#/definitions/CustomFieldValue"
          }
        }
      },
      "description" : "Base definitions for a preview before performing a transaction"
    },
    "InternalTransactionPreview" : {
      "allOf" : [ {
        "$ref" : "#/definitions/TransactionPreview"
      }, {
        "type" : "object",
        "properties" : {
          "pendingAuthorization" : {
            "type" : "boolean",
            "description" : "Indicates whether the transaction would be initially pending\nauthorization in order to be processed\n"
          },
          "toAccount" : {
            "description" : "A reference to the destination account",
            "$ref" : "#/definitions/AccountWithOwner"
          }
        }
      } ],
      "description" : "Base definitions for a preview before performing an internal transaction\n"
    },
    "DataForTransaction" : {
      "type" : "object",
      "properties" : {
        "accounts" : {
          "type" : "array",
          "description" : "Only returned when the payment type is not selected.\nContains the possible accounts which can be used either as source\n(when performing the payment) or destination (when receiving the\npayment, on POS).\n",
          "items" : {
            "$ref" : "#/definitions/AccountWithStatus"
          }
        },
        "fromKind" : {
          "description" : "Indicates the account kind that will perform the payment",
          "$ref" : "#/definitions/AccountKind"
        },
        "fromUser" : {
          "description" : "Only returned if `fromKind` is `user`. Is the payer user.\n",
          "$ref" : "#/definitions/User"
        },
        "toKind" : {
          "description" : "Indicates the account kind that will receive the payment",
          "$ref" : "#/definitions/AccountKind"
        },
        "toUser" : {
          "description" : "Only returned if `toKind` is `user`. Is the payee user.\n",
          "$ref" : "#/definitions/User"
        },
        "paymentTypeData" : {
          "description" : "Contains the detailed data for the selected (or first) payment type\n",
          "$ref" : "#/definitions/TransactionTypeData"
        },
        "paymentTypes" : {
          "type" : "array",
          "description" : "Only returned when the payment type is not selected.\nContains the allowed payment types for a payment between the\nselected from and to owners.\n",
          "items" : {
            "$ref" : "#/definitions/TransferType"
          }
        },
        "allowAutocomplete" : {
          "type" : "boolean",
          "description" : "Only returned when no subject is selected.\nIndicates whether the payee can be obtaining by freely searching users\n"
        },
        "allowContacts" : {
          "type" : "boolean",
          "description" : "Only returned when no subject is selected.\nIndicates whether the payee can be obtaining from the contact list\n"
        },
        "principalTypes" : {
          "type" : "array",
          "description" : "Only returned when no subject is selected.\nThe possible principal types that can be used to locate the payee\n",
          "items" : {
            "$ref" : "#/definitions/PrincipalTypeInput"
          }
        },
        "defaultIdMethod" : {
          "description" : "Only returned when no subject is selected. The default option for the identification method when performing a payment. Possible values are: * autocomplete: The client application should search for an user and pass in the id * contacts: The client application should access the contact list of the authenticated user and pass the id * principalType: The client application should pass in an identification (principal) of the user, such as login name, e-mail and so on\n",
          "$ref" : "#/definitions/IdentificationMethodEnum"
        },
        "defaultPrincipalType" : {
          "type" : "string",
          "description" : "Only returned when no subject is selected. If the `defaultIdMethod` is `principalType`, contains the internal name or id of the principal type that should be the default. If there is a default, the user should be provided with the option to choose which principal type he's using. If there is no default, all possible principal types will be attempted. In this case, the UI will normally not show the option for which principal type should be used.\n"
        }
      },
      "description" : "Contains basic configuration data used when performing a transaction. The path that returns it will normally receive the main transaction owner (system or user), plus 2 other optional parameters: - The other subject (system or user) that will either receive or perform\n  the payment.\n- The payment type. There are 3 possibilities when returning: - When the other subject wasn't selected. In this case, will contain very\n  few information, mostly the accounts.\n- The other subject is selected, but not a payment type. If so, the\n  payment types will be returned, but not information on how to pick\n  the subject user, or the accounts.\n- Both other subject and payment type are selected: In this case\n  only the payment type data will be returned\n"
    },
    "MaturityPolicyEnum" : {
      "type" : "string",
      "description" : "Indicates how a this payment type restricts payments based on the balance maturity Possible values are: * always: The payment can always be performed, regardless its maturity * history: It the balance maturity ever reached zero in the past, that balance can be used on payment. If later on the maturity went above zero, that new balance cannot be used. Is normally used in conjunction with the maturity table, so the user can pick the balance from past maturity * zero: The payment can only be performed if the current maturity is zero\n",
      "enum" : [ "always", "history", "zero" ]
    },
    "TransactionTypeData" : {
      "type" : "object",
      "properties" : {
        "currency" : {
          "description" : "The payment type currency",
          "$ref" : "#/definitions/Currency"
        },
        "fixedAmount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The only allowed amount iff the payment type uses a fixed amount\n"
        },
        "allowsRecurringPayments" : {
          "type" : "boolean",
          "description" : "Can payments of this type be made recurring?\n"
        },
        "maxInstallments" : {
          "type" : "integer",
          "description" : "The maximum allowed installments. If it is zero, no kind of scheduled\npayments is allowed. If it is 1, a single future date can be used.\n"
        },
        "requiresDescription" : {
          "type" : "boolean",
          "description" : "The transaction description can be either required, or optional, depending on this setting."
        },
        "customFields" : {
          "type" : "array",
          "description" : "The custom fields related to this payment type",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "ARate" : {
          "type" : "string",
          "format" : "number",
          "description" : "The balance aging counter used for this payment"
        },
        "DRate" : {
          "type" : "string",
          "format" : "number",
          "description" : "The balance maturity used for this payment"
        },
        "DRateCreationValue" : {
          "type" : "string",
          "format" : "number",
          "description" : "The initial value for the balance maturity on this payment type\n"
        },
        "limitedAwaitingAuthorization" : {
          "type" : "boolean"
        },
        "noNegativesMaturityPolicy" : {
          "type" : "boolean"
        },
        "maturityPolicy" : {
          "description" : "Indicates how a this payment type restricts payments based on the balance maturity Possible values are: * always: The payment can always be performed, regardless its maturity * history: It the balance maturity ever reached zero in the past, that balance can be used on payment. If later on the maturity went above zero, that new balance cannot be used. Is normally used in conjunction with the maturity table, so the user can pick the balance from past maturity * zero: The payment can only be performed if the current maturity is zero\n",
          "$ref" : "#/definitions/MaturityPolicyEnum"
        },
        "maxAmountByMaturityPolicy" : {
          "type" : "string",
          "format" : "number",
          "description" : "The maximum amount that can be performed when `maturityPolicy` is `history`. It corresponds to the maturity table entry indicated by `maturityTableWinnerId`.\n"
        },
        "maturityTableWinnerId" : {
          "type" : "string",
          "description" : "When `maturityPolicy` is `history`, contains the id of the maturity table entry that granted \n"
        }
      },
      "description" : "Contains definitions regarding a given payment type when performing a\ntransaction.\n"
    },
    "IdentificationMethodEnum" : {
      "type" : "string",
      "description" : "The way an user is identified to either perform or receive a payment Possible values are: * autocomplete: The client application should search for an user and pass in the id * contacts: The client application should access the contact list of the authenticated user and pass the id * principalType: The client application should pass in an identification (principal) of the user, such as login name, e-mail and so on\n",
      "enum" : [ "autocomplete", "contacts", "principalType" ]
    },
    "PaymentSchedulingEnum" : {
      "type" : "string",
      "description" : "Determines how a payment is scheduled. When not specified, direct payments are performed. Possible values are: * direct: The payment won't be scheduled, but paid directly * scheduled: The payment will be scheduled, either to a single future date or multiple installments * recurring: The payment will be recurring, repeated either by a limited number of occurrences or until cancel\n",
      "enum" : [ "direct", "scheduled", "recurring" ]
    },
    "PerformPayment" : {
      "allOf" : [ {
        "$ref" : "#/definitions/PerformInternalTransaction"
      }, {
        "type" : "object",
        "properties" : {
          "scheduling" : {
            "description" : "Determines how a payment is scheduled. When not specified, direct payments are performed. Possible values are: * direct: The payment won't be scheduled, but paid directly * scheduled: The payment will be scheduled, either to a single future date or multiple installments * recurring: The payment will be recurring, repeated either by a limited number of occurrences or until cancel\n",
            "$ref" : "#/definitions/PaymentSchedulingEnum"
          },
          "installmentsCount" : {
            "type" : "integer",
            "description" : "Represents the number of installments. When not specified, assumes a single installment. Used only if `scheduling` is `scheduled`. Can be used together with `installmentsCount` as an alternative to providing individual `installments` definitions.\n",
            "minimum" : 1.0
          },
          "firstInstallmentDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Represents the first installment date. When not specified, assumes the first installment is processed instantly. Used only if `scheduling` is `scheduled`. Can be used together with `installmentsCount` as an alternative to providing individual `installments` definitions.\n"
          },
          "installments" : {
            "type" : "array",
            "description" : "An array containing individual installments definitions, allowing full control over generated installments. Used only if `scheduling` is `scheduled`.\n",
            "items" : {
              "$ref" : "#/definitions/PerformScheduledPaymentInstallment"
            }
          },
          "occurrencesCount" : {
            "type" : "integer",
            "description" : "Represents the number of occurrences in a recurring payment. When not provided, the payment will be repeated until it is manually canceled. Used only if `scheduling` is `recurring`.\n",
            "minimum" : 1.0
          },
          "firstOccurrenceDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Represents the first occurrence date for a recurring payment. If none is given, it is assumed that the first occurrence is immediate. Used only if `scheduling` is `recurring`.\n"
          },
          "occurrenceInterval" : {
            "description" : "Defines the interval between payment occurrences. If none is given, it is assumed 1 month between occurrences. Used only if `scheduling` is `recurring`.\n",
            "$ref" : "#/definitions/TimeInterval"
          }
        }
      } ],
      "description" : "Definitions used to perform either a direct, scheduled or recurring payment. Regarding scheduling, the `scheduling` field must be set if some scheduling option (other than direct payment) is desired. The scheduling possibilities are: - Direct payment: For a direct payment, leave empty the `scheduling` field\n  or set it to `direct`;\n- Single future payment: For a payment scheduled to a future date, set the\n  `scheduling` field to `scheduled` and set the \n  `firstDueDate` property with the desired due date;\n- Multiple installments, being the first immediately and the rest with\n  regular 1 month interval in-between: For this, set the `scheduling` field\n  to `scheduled` and the `installmentsCount`\n  to a value greater than 1;\n- Multiple installments, starting at a specific date, with other\n  installments with regular 1 month interval in-between: For this, set the\n  `scheduling` field to `scheduled`, the\n  `installmentsCount` to a value greater than 1 and the\n  `firstInstallmentDate` with a future date;\n- Custom installments: For a full control on the generated installments,\n   set the `scheduling` field to `scheduled`\n   and pass in the `installments` array. However, there are some rules:\n  - The total amount must be equals the sum of all installment amounts;\n  - The first due date must be in the future;\n  - The due dates of all installments must be in crescent order;\n  - There must be at least one day between distinct due dates.  \n- Recurring payment with the first payment immediately, the others at\n  fixed future dates: This can be achieved by setting the `scheduling`\n  field to `recurring` and leaving blank the\n  `firstOccurrenceDate`. It is possible to schedule a limited number of\n  occurrences, by setting `occurrencesCount`, or until it is manually\n  canceled, by leaving `occurrencesCount` empty. Also, it is possible to\n  customize the interval (default is 1 month) between each occurrence, by\n  setting the `occurrenceInterval` field.\n- Recurring payment starting in a future date: This can be achieved by\n  setting the `scheduling` field to `recurring`\n  and setting the `firstOccurrenceDate`. The other options, the fixed\n  number of occurrences (`occurrencesCount`) and interval between each\n  occurrence  (`occurrenceInterval`) can be set just like the case above.\n"
    },
    "PerformScheduledPaymentInstallment" : {
      "type" : "object",
      "required" : [ "amount", "dueDate" ],
      "properties" : {
        "dueDate" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The installment due date"
        },
        "amount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The installment amount"
        }
      },
      "description" : "An installment definition when performing a scheduled payment"
    },
    "PaymentPreview" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalTransactionPreview"
      }, {
        "type" : "object",
        "properties" : {
          "mainAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "Depending on the configured fees, it could happen that the main amount is deducted from fees amount. This reflects the new main amount. If no fees deduct, it will be the same as `totalAmount`.\n"
          },
          "fees" : {
            "type" : "array",
            "description" : "Only returned for direct payments. Contains the fees that would be\npaid by the payer if the payment is confirmed.\n",
            "items" : {
              "$ref" : "#/definitions/TransferFeePreview"
            }
          },
          "installments" : {
            "type" : "array",
            "description" : "Only returned for scheduled payments. Contains the previews of each\ninstallment, if the payment is confirmed.\n",
            "items" : {
              "$ref" : "#/definitions/ScheduledPaymentInstallmentPreview"
            }
          },
          "payment" : {
            "description" : "Depending on the configuration, some script might alter the payment object, for example, filling in custom fields. This object can be used to show the actual data to the user, and to be posted again to the `POST /{owner}/payments/` path.\n",
            "$ref" : "#/definitions/PerformPayment"
          },
          "ARate" : {
            "type" : "string",
            "format" : "number",
            "description" : "The balance aging counter used for this payment"
          },
          "DRate" : {
            "type" : "string",
            "format" : "number",
            "description" : "The balance maturity used for this payment"
          },
          "previousDRate" : {
            "type" : "string",
            "format" : "number",
            "description" : "The number of days until the present balance reaches its maturity \n"
          },
          "transferDRate" : {
            "type" : "string",
            "format" : "number",
            "description" : "The maturity used for this payment"
          }
        }
      } ],
      "description" : "Preview of either a direct or scheduled payment"
    },
    "ScheduledPaymentInstallmentPreview" : {
      "type" : "object",
      "properties" : {
        "number" : {
          "type" : "integer",
          "description" : "The installment number"
        },
        "dueDate" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The installment due date"
        },
        "totalAmount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The final total installment amount"
        },
        "mainAmount" : {
          "type" : "string",
          "format" : "number",
          "description" : "Depending on the configured fees, it could happen that the main amount is deducted from fees amount. This reflects the new main amount. If no fees deduct, it will be the same as `totalAmount`.\n"
        },
        "fees" : {
          "type" : "array",
          "description" : "Only returned for direct payments. Contains the fees that would be\npaid by the payer if the payment is confirmed.\n",
          "items" : {
            "$ref" : "#/definitions/TransferFeePreview"
          }
        }
      },
      "description" : "Preview of a direct or scheduled payment"
    },
    "TransferFeePreview" : {
      "type" : "object",
      "properties" : {
        "fee" : {
          "description" : "The transfer fee",
          "$ref" : "#/definitions/EntityReference"
        },
        "amount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The transfer fee amout"
        }
      },
      "description" : "Preview of a transfer fee in case a payment is confirmed"
    },
    "PaymentErrorCode" : {
      "type" : "string",
      "description" : "Application-specific error codes for a payment error  Possible values are: * insufficientBalance: The account selected for the payment does not have enough balance * dailyAmountExceeded: The maximum amount allowed per day was exceeded.   * weeklyAmountExceeded: The maximum amount allowed per week was exceeded. * monthlyAmountExceeded: The maximum amount allowed per month was exceeded. * dailyPaymentsExceeded: The maximum count of payments allowed per day was exceeded. * weeklyPaymentsExceeded: The maximum count of payments allowed per week was exceeded. * monthlyPaymentsExceeded: The maximum count of payments allowed per month was exceeded. * timeBetweenPaymentsNotMet: The minimum time between payments was not met. * destinationUpperLimitReached: The upper balance limit of the destination account was exceeded. * pos: A POS exception has happened when performing this payment. See the `posError` field for more details.    * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
      "enum" : [ "insufficientBalance", "dailyAmountExceeded", "weeklyAmountExceeded", "monthlyAmountExceeded", "dailyPaymentsExceeded", "weeklyPaymentsExceeded", "monthlyPaymentsExceeded", "timeBetweenPaymentsNotMet", "destinationUpperLimitReached", "pos", "unexpected" ]
    },
    "PaymentError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Error"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Application-specific error codes for a payment error  Possible values are: * insufficientBalance: The account selected for the payment does not have enough balance * dailyAmountExceeded: The maximum amount allowed per day was exceeded.   * weeklyAmountExceeded: The maximum amount allowed per week was exceeded. * monthlyAmountExceeded: The maximum amount allowed per month was exceeded. * dailyPaymentsExceeded: The maximum count of payments allowed per day was exceeded. * weeklyPaymentsExceeded: The maximum count of payments allowed per week was exceeded. * monthlyPaymentsExceeded: The maximum count of payments allowed per month was exceeded. * timeBetweenPaymentsNotMet: The minimum time between payments was not met. * destinationUpperLimitReached: The upper balance limit of the destination account was exceeded. * pos: A POS exception has happened when performing this payment. See the `posError` field for more details.    * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
            "$ref" : "#/definitions/PaymentErrorCode"
          },
          "currency" : {
            "description" : "Currency reference. Only if `code` is `dailyAmountExceeded`, `weeklyAmountExceeded` or `monthlyAmountExceeded`          \n",
            "$ref" : "#/definitions/Currency"
          },
          "maxAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The maximum amount. Only if `code` is `dailyAmountExceeded`, `weeklyAmountExceeded` or `monthlyAmountExceeded`          \n"
          },
          "maxPayments" : {
            "type" : "integer",
            "description" : "The maximum payments count. Only if `code` is `dailyPaymentsExceeded`, `weeklyPaymentsExceeded` or `monthlyPaymentsExceeded`          \n"
          },
          "posError" : {
            "description" : "The POS error details. Only if `code` is `pos`          \n",
            "$ref" : "#/definitions/PosError"
          }
        }
      } ],
      "description" : "Error when performing a payment"
    },
    "PosErrorCode" : {
      "type" : "string",
      "description" : "Application-specific error codes for a POS operation error  Possible values are: * payerNotInChannel: The specified payer user does not participate on the POS channel. * payerNotOperative: The specified payer has some restriction that renders he/she inoperative for POS operations. An example of such case is when the user has pending agreements. * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
      "enum" : [ "payerNotInChannel", "payerNotOperative", "unexpected" ]
    },
    "PosError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Error"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Application-specific error codes for a POS operation error  Possible values are: * payerNotInChannel: The specified payer user does not participate on the POS channel. * payerNotOperative: The specified payer has some restriction that renders he/she inoperative for POS operations. An example of such case is when the user has pending agreements. * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
            "$ref" : "#/definitions/PosErrorCode"
          }
        }
      } ],
      "description" : "Error when performing a POS operation"
    },
    "ClientStatusEnum" : {
      "type" : "string",
      "description" : "The status of an access client Possible values are: * unassigned: The access client is unassigned (disconnected) from an (remote) application * active: The access client is active, and can operate normally * blocked: The access client is blocked and cannot be used until it is unblocked * removed: The access client was removed, but had transactions, so couldn't be physically removed\n",
      "enum" : [ "unassigned", "active", "blocked", "removed" ]
    },
    "UserClientTypePermissions" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "canManage" : {
            "type" : "boolean",
            "description" : "Can the authenticated user manage access clients of this type?\n"
          },
          "canCreateNew" : {
            "type" : "boolean",
            "description" : "Can the authenticated user create a new access client of this type\nand user? Maybe the maximum allowed has been reached.\n"
          },
          "hasUnassigned" : {
            "type" : "boolean",
            "description" : "Is there at least one access client for this type and user which\nis in the unassigned status?\n"
          }
        }
      } ],
      "description" : "Contains details of an access client, together with permissions over it\n"
    },
    "ClientView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "status" : {
            "description" : "The status of an access client Possible values are: * unassigned: The access client is unassigned (disconnected) from an (remote) application * active: The access client is active, and can operate normally * blocked: The access client is blocked and cannot be used until it is unblocked * removed: The access client was removed, but had transactions, so couldn't be physically removed\n",
            "$ref" : "#/definitions/ClientStatusEnum"
          },
          "activationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date the client was activated"
          },
          "confirmationPasswordInput" : {
            "description" : "Data for a confirmation password input in case of an action\n",
            "$ref" : "#/definitions/PasswordInput"
          },
          "canGetActivationCode" : {
            "type" : "boolean",
            "description" : "Can the authenticated user get the activation code, to later\nactivate (assign) this client?\n"
          },
          "canUnassign" : {
            "type" : "boolean",
            "description" : "Can the authenticated user unassign this client?"
          },
          "canBlock" : {
            "type" : "boolean",
            "description" : "Can the authenticated user block this client?"
          },
          "canUnblock" : {
            "type" : "boolean",
            "description" : "Can the authenticated user unblock this client?"
          }
        }
      } ],
      "description" : "Details on an access client"
    },
    "ActivateClientResult" : {
      "type" : "object",
      "properties" : {
        "token" : {
          "type" : "string",
          "description" : "The generated access client token. It should be passed using the `Access-Client-Token` header. If a prefix was informed on activation, it will not be returned, here, but should be sent prepending the returned token\n"
        },
        "accessClient" : {
          "description" : "A reference to the activated access client",
          "$ref" : "#/definitions/EntityReference"
        },
        "accessClientType" : {
          "description" : "A reference to the access client type",
          "$ref" : "#/definitions/EntityReference"
        }
      },
      "description" : "Data about an access client activation"
    },
    "MobileBaseData" : {
      "type" : "object",
      "properties" : {
        "cyclosVersion" : {
          "type" : "string",
          "description" : "The version of the Cyclos server"
        },
        "currentClientTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The current client time according to the server"
        },
        "numberFormat" : {
          "description" : "The format for numbers Possible values are: * commaAsDecimal: 9.999,99 * periodAsDecimal: 9,999.99\n",
          "$ref" : "#/definitions/NumberFormatEnum"
        },
        "dateFormat" : {
          "description" : "The format for dates Possible values are: * dmySlash: DD/MM/YYYY * dmyDash: DD-MM-YYYY * dmyPeriod: DD.MM.YYYY * mdySlash: MM/DD/YYYY * mdyDash: MM-DD-YYYY * mdyPeriod: MM.DD.YYYY * ymdSlash: YYYY/MM/DD * ymdDash: YYYY-MM-DD * ymdPeriod: YYYY.MM.DD\n",
          "$ref" : "#/definitions/DateFormatEnum"
        },
        "timeFormat" : {
          "description" : "The format for times Possible values are: * h24: 24-hour * h12: 12-hour with AM/PM indicator\n",
          "$ref" : "#/definitions/TimeFormatEnum"
        },
        "locale" : {
          "type" : "string",
          "description" : "The current locale"
        },
        "theme" : {
          "description" : "The theme guests. Only returned when changed.",
          "$ref" : "#/definitions/UIElementWithContent"
        },
        "translations" : {
          "description" : "The mobile translations. Only returned when changed.",
          "$ref" : "#/definitions/MobileTranslations"
        }
      },
      "description" : "Contains basic definitions for the data for UI results for the mobile  \n"
    },
    "DataForMobileGuest" : {
      "allOf" : [ {
        "$ref" : "#/definitions/MobileBaseData"
      }, {
        "type" : "object",
        "properties" : {
          "dataForLogin" : {
            "description" : "The data for user login",
            "$ref" : "#/definitions/DataForLogin"
          },
          "groupsForRegistration" : {
            "type" : "array",
            "description" : "The list of groups the authenticated user can use to perform a new user registration",
            "items" : {
              "$ref" : "#/definitions/GroupForRegistration"
            }
          },
          "header" : {
            "description" : "The mobile header",
            "$ref" : "#/definitions/UIElementWithContent"
          },
          "footer" : {
            "description" : "The mobile footer",
            "$ref" : "#/definitions/UIElementWithContent"
          }
        }
      } ],
      "description" : "Contains definitions for the data for UI for guests  \n"
    },
    "MobileOperationEnum" : {
      "type" : "string",
      "description" : "The possible operations the mobile application can perform Possible values are: * viewUserProfile: View the profile of other users * viewAccountInformation: View own accounts * makeUserPayment: Perform payments to other users * makeSystemPayment: Perform payments to system * receivePayment: Receive payments from other users * boughtVouchers: View bought vouchers * redeemVoucher: Redeem vouchers * manageContacts: Manage own contacts * usersSearch: Search other users * mapDirectory: View the user directory (map) * activateNfcDevice: Activate the phone as NFC device * deactivateNfcDevice: Deactivate the phone as NFC device * assignPos: Assign an access client for POS mode * unassignPos: Unassign the current access client from POS mode * formatNfc: Format NFC tags * initializeNfc: Initialize NFC tags * personalizeNfc: Personalize NFC tags  * readNfc: Read NFC tags * manageOperators: Manage own/user operators * personalizeNfcSelf: Personalize NFC tags for the logged user or its operators * registerUsersAsMember: Register other users as member or operator \n",
      "enum" : [ "viewUserProfile", "viewAccountInformation", "makeUserPayment", "makeSystemPayment", "receivePayment", "boughtVouchers", "redeemVoucher", "manageContacts", "usersSearch", "mapDirectory", "activateNfcDevice", "deactivateNfcDevice", "assignPos", "unassignPos", "formatNfc", "initializeNfc", "personalizeNfc", "readNfc", "manageOperators", "personalizeNfcSelf", "registerUsersAsMember" ]
    },
    "DataForMobileUser" : {
      "allOf" : [ {
        "$ref" : "#/definitions/MobileBaseData"
      }, {
        "type" : "object",
        "properties" : {
          "autoCompleteResults" : {
            "type" : "integer",
            "description" : "Number of search results for user autocomplete component"
          },
          "hideUsersSearchMenu" : {
            "type" : "boolean",
            "description" : "Indicates if the user search menu should be hidden."
          },
          "auth" : {
            "description" : "The authenticated user",
            "$ref" : "#/definitions/Auth"
          },
          "mobileHelp" : {
            "description" : "The help content for mobile mode",
            "$ref" : "#/definitions/UIElementWithContent"
          },
          "posHelp" : {
            "description" : "The help content for mobile mode",
            "$ref" : "#/definitions/UIElementWithContent"
          },
          "mapBrowserApiKey" : {
            "type" : "string",
            "description" : "The Google Maps browser API key"
          },
          "pages" : {
            "type" : "array",
            "description" : "The visible mobile pages",
            "items" : {
              "$ref" : "#/definitions/MobilePage"
            }
          },
          "canReceiveFromNfcTag" : {
            "type" : "boolean",
            "description" : "Indicates whether there is at least one NFC tag the user can use\nto receive payments\n"
          },
          "mobileCameraOnPayment" : {
            "type" : "boolean",
            "description" : "Indicates whether the scan QR code option should be displayed for payments         \n"
          },
          "principalsAllowingQRCode" : {
            "type" : "array",
            "description" : "Indicates the possible principals which are allowed to be used in QR code generation",
            "items" : {
              "$ref" : "#/definitions/Principal"
            }
          },
          "allowedOperations" : {
            "type" : "array",
            "description" : "The possible operations the mobile application can perform Possibles values for each array element are: * viewUserProfile: View the profile of other users * viewAccountInformation: View own accounts * makeUserPayment: Perform payments to other users * makeSystemPayment: Perform payments to system * receivePayment: Receive payments from other users * boughtVouchers: View bought vouchers * redeemVoucher: Redeem vouchers * manageContacts: Manage own contacts * usersSearch: Search other users * mapDirectory: View the user directory (map) * activateNfcDevice: Activate the phone as NFC device * deactivateNfcDevice: Deactivate the phone as NFC device * assignPos: Assign an access client for POS mode * unassignPos: Unassign the current access client from POS mode * formatNfc: Format NFC tags * initializeNfc: Initialize NFC tags * personalizeNfc: Personalize NFC tags  * readNfc: Read NFC tags * manageOperators: Manage own/user operators * personalizeNfcSelf: Personalize NFC tags for the logged user or its operators * registerUsersAsMember: Register other users as member or operator \n",
            "items" : {
              "$ref" : "#/definitions/MobileOperationEnum"
            }
          }
        }
      } ],
      "description" : "Contains definitions for the data for UI for users  \n"
    },
    "MobilePage" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version stamp for the current object, used for optimistic locking.\nWhen saving, the same version as previously received needs to be passed\nback. If no one else has saved the object, the version will match and\nthe object will be updated. However, if someone other has saved the\nobject, the version will no longer match, and an error will be raised.\nThis is used to prevent multiple users (or processes) from updating the\nsame object and unwilingly overridding the property values, leading to\ndata loss. \n"
          },
          "icon" : {
            "type" : "string",
            "description" : "The character that represents the icon in the Cyclos font"
          }
        }
      } ],
      "description" : "Represents a content page for the mobile application"
    },
    "UIElementWithContent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VersionedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "content" : {
            "type" : "string",
            "description" : "The content of this element"
          }
        }
      } ],
      "description" : "Contains definitions for a UI element that has a content"
    },
    "MobileTranslations" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VersionedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "locale" : {
            "type" : "string",
            "description" : "The locale represented by this language, in either of the following formats: `<2-letter lowercase language code>` or `<2-letter lowercase language code>`_`<2-letter uppercase country code>`.\n"
          },
          "translations" : {
            "type" : "object",
            "description" : "The translation keys / values for the mobile application",
            "additionalProperties" : {
              "type" : "string"
            }
          },
          "countries" : {
            "type" : "array",
            "description" : "The list of countries, with translated display names. Whenever the\ntranslations are returned, the country list is returned as well. \n",
            "items" : {
              "$ref" : "#/definitions/Country"
            }
          }
        }
      } ],
      "description" : "Contains definitions for translations that are returned for the mobile app\n"
    },
    "VoucherRelationEnum" : {
      "type" : "string",
      "description" : "The ways a voucher is related to an user Possible values are: * bought: A voucher the user has bought * redeemed: A voucher the user has redeemed\n",
      "enum" : [ "bought", "redeemed" ]
    },
    "VoucherStatusEnum" : {
      "type" : "string",
      "description" : "The voucher statuses Possible values are: * open: The voucher has been generated / bought, and is open * expired: The voucher has expired without being redeemed * canceled: The voucher was canceled, and cannot be further used * redeemed: The voucher has been redeemed, and the corresponding payment was done\n",
      "enum" : [ "open", "expired", "canceled", "redeemed" ]
    },
    "VoucherCreationTypeEnum" : {
      "type" : "string",
      "description" : "Indicates how a voucher was created Possible values are: * generated: The voucher was generated by an administrator * bought: The voucher was bought by an user\n",
      "enum" : [ "generated", "bought" ]
    },
    "Voucher" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "status" : {
            "description" : "The voucher statuses Possible values are: * open: The voucher has been generated / bought, and is open * expired: The voucher has expired without being redeemed * canceled: The voucher was canceled, and cannot be further used * redeemed: The voucher has been redeemed, and the corresponding payment was done\n",
            "$ref" : "#/definitions/VoucherStatusEnum"
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The voucher amount"
          },
          "token" : {
            "type" : "string",
            "description" : "The voucher token"
          }
        }
      } ],
      "description" : "A voucher is a token which can be used to buy at places that accept\npayments in Cyclos. Even users which are not members can get a printed\ntoken (or scratch card, ticket, etc) and buy in such places.\n"
    },
    "VoucherResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Voucher"
      }, {
        "type" : "object",
        "properties" : {
          "buyer" : {
            "description" : "The voucher buyer. Is not returned when the voucher was generated\nor when searching for bought vouchers of an user.\n",
            "$ref" : "#/definitions/User"
          },
          "creationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date a voucher was generated or bought"
          },
          "expirationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date a voucher expires"
          },
          "redeemer" : {
            "description" : "The voucher redeemer. Is not returned when the voucher was not yet\nredeemed or when searching for redeemed vouchers of an user.\n",
            "$ref" : "#/definitions/User"
          },
          "redeemDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date a voucher was redeemed (if so)"
          },
          "redeemAfterDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date after which the voucher can be redeemed. Is only returned\nif the voucher `status` is `open`.\n"
          },
          "redeemOnWeekDays" : {
            "type" : "array",
            "description" : "The days of the week a voucher can be redeemed. Is only returned if the voucher `status` is `open`. Possibles values for each array element are: * sun: Sunday * mon: Monday * tue: Tuesday * wed: Wednesday * thu: Thursday * fri: Friday * sat: Saturday\n",
            "items" : {
              "$ref" : "#/definitions/WeekDayEnum"
            }
          },
          "type" : {
            "description" : "The voucher type",
            "$ref" : "#/definitions/VoucherType"
          }
        }
      } ],
      "description" : "Result of a voucher search\n"
    },
    "VoucherView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VoucherResult"
      }, {
        "type" : "object",
        "properties" : {
          "title" : {
            "type" : "string",
            "description" : "The voucher title when it was created."
          },
          "description" : {
            "type" : "string",
            "description" : "The voucher description when it was created."
          },
          "creationType" : {
            "description" : "Indicates how a voucher was created Possible values are: * generated: The voucher was generated by an administrator * bought: The voucher was bought by an user\n",
            "$ref" : "#/definitions/VoucherCreationTypeEnum"
          },
          "buy" : {
            "description" : "The transaction which bought this voucher, if any and visible.\n",
            "$ref" : "#/definitions/Transaction"
          },
          "redeemDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The date the voucher was redeemer, if any."
          },
          "redeem" : {
            "description" : "The transaction which redeemed this voucher, if any and visible.\n",
            "$ref" : "#/definitions/Transaction"
          },
          "canCancel" : {
            "type" : "boolean",
            "description" : "Can the authenticated user cancel this voucher?"
          },
          "showConfiguration" : {
            "type" : "boolean",
            "description" : "Should the voucher configuration be shown to users? This flag is `true` when there are multiple available configurations.\n"
          },
          "showQrCode" : {
            "type" : "boolean",
            "description" : "Should the voucher token be shown as QR-code for users?"
          }
        }
      } ],
      "description" : "Details of a voucher\n"
    },
    "VoucherType" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "configuration" : {
            "description" : "The voucher configuration",
            "$ref" : "#/definitions/VoucherConfiguration"
          },
          "image" : {
            "description" : "The voucher type image",
            "$ref" : "#/definitions/Image"
          }
        }
      } ],
      "description" : "Reference to a voucher type"
    },
    "VoucherConfiguration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "currency" : {
            "description" : "The voucher currency",
            "$ref" : "#/definitions/Currency"
          }
        }
      } ],
      "description" : "Reference to a voucher configuration"
    },
    "UserVouchersDataForSearch" : {
      "type" : "object",
      "properties" : {
        "mask" : {
          "type" : "string",
          "description" : "The input mask for voucher tokens. Optional."
        },
        "types" : {
          "type" : "array",
          "description" : "The voucher types that can be used for searching",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        }
      },
      "description" : "Contains configuration data for searching vouchers of an user\n"
    },
    "VoucherBasicData" : {
      "type" : "object",
      "properties" : {
        "title" : {
          "type" : "string",
          "description" : "The voucher title"
        },
        "description" : {
          "type" : "string",
          "description" : "The voucher description"
        },
        "type" : {
          "description" : "The voucher type",
          "$ref" : "#/definitions/VoucherType"
        },
        "customFields" : {
          "type" : "array",
          "description" : "The custom fields associated with this voucher type\n",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "confirmationPasswordInput" : {
          "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
          "$ref" : "#/definitions/PasswordInput"
        }
      },
      "description" : "Contains common data for either buying or redeeming a voucher"
    },
    "BuyVoucherErrorCode" : {
      "type" : "string",
      "description" : "Possible errors when buying a voucher Possible values are: * maxAmountForPeriod: The maximum allowed buy amount for a period (example, a month) has been exceeded * maxOpenAmount: The maximum open amount for this voucher type for the buyer user has been exceeded * notAllowedForUser: The user attempting to buy vouchers is not allowed to buy vouchers of this type * payment: There was an error when performing the payment * maxTotalOpenAmount: The maximum total open amount for this voucher type, for all users, has been exceeded * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
      "enum" : [ "maxAmountForPeriod", "maxOpenAmount", "notAllowedForUser", "payment", "maxTotalOpenAmount", "unexpected" ]
    },
    "BuyVoucherError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Error"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Possible errors when buying a voucher Possible values are: * maxAmountForPeriod: The maximum allowed buy amount for a period (example, a month) has been exceeded * maxOpenAmount: The maximum open amount for this voucher type for the buyer user has been exceeded * notAllowedForUser: The user attempting to buy vouchers is not allowed to buy vouchers of this type * payment: There was an error when performing the payment * maxTotalOpenAmount: The maximum total open amount for this voucher type, for all users, has been exceeded * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
            "$ref" : "#/definitions/BuyVoucherErrorCode"
          },
          "currency" : {
            "description" : "Currency reference. Only if `code` is `maxAmountForPeriod` or `maxTotalOpenAmount`          \n",
            "$ref" : "#/definitions/Currency"
          },
          "amountLeftForBuying" : {
            "type" : "string",
            "format" : "number",
            "description" : "Indicates the maximum amount the user can buy this time without exceeding the maximum. Only if `code` is `maxAmountForPeriod`.\n"
          },
          "dateAllowedAgain" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Indicates the date this user will be able to buy vouchers again for this type. Only if `code` is `maxAmountForPeriod`.\n"
          },
          "currentOpenAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "Indicates the current total amount that is open. Only if `code` is `maxOpenAmount` or `maxTotalOpenAmount`.\n"
          },
          "maxOpenAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "Indicates the maximum total open amount. Only if `code` is `maxOpenAmount` or `maxTotalOpenAmount`.\n"
          },
          "paymentError" : {
            "description" : "The `PaymentError` generated when the voucher payment was being created. Only if `code` is `payment`.\n",
            "$ref" : "#/definitions/PaymentError"
          }
        }
      } ],
      "description" : "Error when buying a voucher"
    },
    "VoucherDataForBuy" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VoucherBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "account" : {
            "description" : "The account from which the buy will be debited",
            "$ref" : "#/definitions/AccountWithStatus"
          },
          "fixedAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "Returned if the payment type for this voucher uses a fixed amount\n"
          }
        }
      } ],
      "description" : "Data used to buy a voucher"
    },
    "BuyVoucher" : {
      "type" : "object",
      "properties" : {
        "count" : {
          "type" : "integer",
          "description" : "The number of vouchers to buy. Defaults to 1."
        },
        "amount" : {
          "type" : "string",
          "format" : "number",
          "description" : "The amount per voucher"
        },
        "type" : {
          "type" : "string",
          "description" : "Either the `id` or `internalName` of the voucher type\n"
        },
        "customValues" : {
          "type" : "object",
          "description" : "Holds the payment custom field values, keyed by field internal name or id. The format of the value depends on the custom field type.\n",
          "additionalProperties" : {
            "type" : "string"
          }
        }
      },
      "description" : "Parameters for buying vouchers"
    },
    "RedeemVoucherErrorCode" : {
      "type" : "string",
      "description" : "Possible errors when redeeming a voucher Possible values are: * notAllowedYet: The redeem period for this voucher has not arrived yet * notAllowedToday: This voucher cannot be redeemed today  * notAllowedForUser: This user cannot redeem this voucher * notAllowedForVoucher: This voucher cannot be redeemed * userBlocked: The user has been blocked by exceeding redeem tries * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
      "enum" : [ "notAllowedYet", "notAllowedToday", "notAllowedForUser", "notAllowedForVoucher", "userBlocked", "unexpected" ]
    },
    "RedeemVoucherError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Error"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Possible errors when redeeming a voucher Possible values are: * notAllowedYet: The redeem period for this voucher has not arrived yet * notAllowedToday: This voucher cannot be redeemed today  * notAllowedForUser: This user cannot redeem this voucher * notAllowedForVoucher: This voucher cannot be redeemed * userBlocked: The user has been blocked by exceeding redeem tries * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
            "$ref" : "#/definitions/RedeemVoucherErrorCode"
          },
          "voucherStatus" : {
            "description" : "Only if `code` is `notAllowedForVoucher` Possible values are: * open: The voucher has been generated / bought, and is open * expired: The voucher has expired without being redeemed * canceled: The voucher was canceled, and cannot be further used * redeemed: The voucher has been redeemed, and the corresponding payment was done\n",
            "$ref" : "#/definitions/VoucherStatusEnum"
          },
          "allowedDays" : {
            "type" : "array",
            "description" : "Only if `code` is `notAllowedToday` Possibles values for each array element are: * sun: Sunday * mon: Monday * tue: Tuesday * wed: Wednesday * thu: Thursday * fri: Friday * sat: Saturday\n",
            "items" : {
              "$ref" : "#/definitions/WeekDayEnum"
            }
          },
          "redeemAfterDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "Indicates the date after which this voucher can be redeemed. Only if `code` is `notAllowedYet`.\n"
          },
          "currency" : {
            "description" : "Currency reference. Only if `code` is `notAllowedForVoucher`          \n",
            "$ref" : "#/definitions/Currency"
          },
          "amountLeftForRedeeming" : {
            "type" : "string",
            "format" : "number",
            "description" : "Indicates the maximum amount the user can buy this time without exceeding the maximum. Only if `code` is `notAllowedForVoucher`.\n"
          },
          "currentOpenAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "Indicates the current total amount that is open. Only if `code` is `notAllowedForVoucher`.\n"
          },
          "maxOpenAmount" : {
            "type" : "string",
            "format" : "number",
            "description" : "Indicates the maximum total open amount. Only if `code` is `notAllowedForVoucher`.\n"
          },
          "paymentError" : {
            "description" : "The `PaymentError` generated when the voucher payment was being created. Only if `code` is `notAllowedForVoucher`.\n",
            "$ref" : "#/definitions/PaymentError"
          }
        }
      } ],
      "description" : "Error when redeeming a voucher"
    },
    "VoucherInitialDataForRedeem" : {
      "type" : "object",
      "properties" : {
        "mask" : {
          "type" : "string",
          "description" : "The voucher token mask"
        }
      },
      "description" : "Initial data used to redeem vouchers"
    },
    "VoucherDataForRedeem" : {
      "allOf" : [ {
        "$ref" : "#/definitions/VoucherBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "token" : {
            "type" : "string",
            "description" : "The formatted voucher token"
          },
          "amount" : {
            "type" : "string",
            "format" : "number",
            "description" : "The voucher amount"
          },
          "buyer" : {
            "description" : "The voucher buyer, if any and visible",
            "$ref" : "#/definitions/User"
          }
        }
      } ],
      "description" : "Data used to redeem a voucher"
    },
    "RedeemVoucher" : {
      "type" : "object",
      "properties" : {
        "customValues" : {
          "type" : "object",
          "description" : "Holds the custom field values for the redeem payment, keyed by field internal name or id. The format of the value depends on the custom field type.\n",
          "additionalProperties" : {
            "type" : "string"
          }
        }
      },
      "description" : "Additional data to redeem a voucher"
    },
    "VoucherRedeemResult" : {
      "type" : "object",
      "properties" : {
        "voucherId" : {
          "type" : "string",
          "description" : "The voucher identifier"
        },
        "paymentId" : {
          "type" : "string",
          "description" : "The generated payment identifier"
        }
      },
      "description" : "Result when redeeming a voucher"
    },
    "RecordLayoutEnum" : {
      "type" : "string",
      "description" : "The layout this record should be presented Possible values are: * tiled: Should show the record list with a form to quickly add a new  * list: Should show a regular search filters / list * single: There should be a single record, with the form directly\n",
      "enum" : [ "tiled", "list", "single" ]
    },
    "RecordType" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "pluralName" : {
            "type" : "string",
            "description" : "The name for the plural form"
          },
          "layout" : {
            "description" : "The layout this record should be presented Possible values are: * tiled: Should show the record list with a form to quickly add a new  * list: Should show a regular search filters / list * single: There should be a single record, with the form directly\n",
            "$ref" : "#/definitions/RecordLayoutEnum"
          }
        }
      } ],
      "description" : "Contains definitions for a record type\n"
    },
    "RecordTypeWithMenu" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordType"
      }, {
        "type" : "object",
        "properties" : {
          "showInMenu" : {
            "type" : "boolean",
            "description" : "Should this record type be shown in the user menu?"
          }
        }
      } ],
      "description" : "A record type with information on whether to show on user menu\n"
    },
    "RecordBasePermissions" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "description" : "The record type",
          "$ref" : "#/definitions/RecordType"
        },
        "create" : {
          "type" : "boolean",
          "description" : "Can the authenticated user create new records of this type?"
        },
        "edit" : {
          "type" : "boolean",
          "description" : "Can the authenticated user edit records of this type?"
        },
        "remove" : {
          "type" : "boolean",
          "description" : "Can the authenticated user remove records of this type?"
        }
      },
      "description" : "Basic definitions shared by `OwnerRecordPermissions` and `OwnerRecordPermissions`\n"
    },
    "OwnerRecordPermissions" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordBasePermissions"
      }, {
        "type" : "object",
        "properties" : {
          "count" : {
            "type" : "integer",
            "description" : "The current number of records of this type for this owner"
          },
          "singleRecordId" : {
            "type" : "string",
            "description" : "If this record type layout is single, and the record exists,\ncontains its identifier\n"
          }
        }
      } ],
      "description" : "Permissions over an user record for a given owner"
    },
    "RecordDataForSearch" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordBasePermissions"
      }, {
        "type" : "object",
        "properties" : {
          "customFields" : {
            "type" : "array",
            "description" : "The list of custom profile fields that are either to be used as search filter (if its internal name is present on `fieldsInSearch`) and / or in the result list (if its internal name is present on `fieldsInList`) \n",
            "items" : {
              "$ref" : "#/definitions/CustomFieldDetailed"
            }
          },
          "fieldsInSearch" : {
            "type" : "array",
            "description" : "The internal names of the custom fields that should be used as\nsearch filters (separated fields, not keywords)\n",
            "items" : {
              "type" : "string"
            }
          },
          "addressFieldsInSearch" : {
            "type" : "array",
            "description" : "Fields which can be used when filtering by user address, by using the `address.<addressField>` name Possibles values for each array element are: * address: Filters by any field in the street address: `addressLine1`, `addressLine2`, `street`, `buildingNumber` or `complement`   * zip: Filters by zip (postal) code (exact match) * poBox: Filters by post-office box (exact match) * neighborhood: Filters by neighborhood name  * city: Filters by city name * region: Filters by region or state * country: Filters by country, represented as 2-letter, uppercase, ISO 3166-1 code (exact match)\n",
            "items" : {
              "$ref" : "#/definitions/AddressQueryFieldEnum"
            }
          },
          "fieldsInList" : {
            "type" : "array",
            "description" : "The internal names of the custom fields that will be returned\ntogether with each record, and should be shown in the result list\n",
            "items" : {
              "type" : "string"
            }
          },
          "basicProfileFields" : {
            "type" : "array",
            "description" : "The list of basic user profile fields that can be used as search filters. Only returned if searching user records.\n",
            "items" : {
              "$ref" : "#/definitions/BasicProfileFieldInput"
            }
          },
          "customProfileFields" : {
            "type" : "array",
            "description" : "The list of custom user profile fields that can be used as search filters. Only returned if searching user records.\n",
            "items" : {
              "$ref" : "#/definitions/CustomFieldDetailed"
            }
          }
        }
      } ],
      "description" : "Data for searching records of a specific type and owner"
    },
    "RecordDataForSharedSearch" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "recordTypes" : {
            "type" : "array",
            "description" : "The possible record types.\n",
            "items" : {
              "$ref" : "#/definitions/RecordType"
            }
          }
        }
      } ],
      "description" : "Data for searching records with shared fields"
    },
    "RecordKind" : {
      "type" : "string",
      "description" : "The possible kinds of a record, which can either belong to system or to an user Possible values are: * user: The record belongs to a specific user * system: The record belongs to the system, and is unrelated to an user\n",
      "enum" : [ "user", "system" ]
    },
    "Record" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Entity"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "The possible kinds of a record, which can either belong to system or to an user Possible values are: * user: The record belongs to a specific user * system: The record belongs to the system, and is unrelated to an user\n",
            "$ref" : "#/definitions/RecordKind"
          }
        }
      } ],
      "description" : "A custom record is a structured data stored either for an user or for\nsystem (a general record, unrelated to an user).\n"
    },
    "RecordResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Record"
      }, {
        "type" : "object",
        "properties" : {
          "creationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The record creation date"
          },
          "createdBy" : {
            "description" : "Reference to the user that created the record",
            "$ref" : "#/definitions/User"
          },
          "lastModificationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The record last modification date"
          },
          "lastModifiedBy" : {
            "description" : "Reference to the user that last modified the record",
            "$ref" : "#/definitions/User"
          },
          "customValues" : {
            "type" : "object",
            "description" : "Holds the values for custom record fields, keyed by field internal name\n",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      } ],
      "description" : "Contains data returned when searching for records\n"
    },
    "RecordWithOwnerResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordResult"
      }, {
        "type" : "object",
        "properties" : {
          "user" : {
            "description" : "The record owner",
            "$ref" : "#/definitions/User"
          }
        }
      } ],
      "description" : "Results for a shared record search, containing the owner user as well\n"
    },
    "RecordView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Record"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "description" : "The record type",
            "$ref" : "#/definitions/RecordType"
          },
          "user" : {
            "description" : "The user which owns this record, only returned if `kind` is `user`\n",
            "$ref" : "#/definitions/User"
          },
          "creationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The record creation date"
          },
          "createdBy" : {
            "description" : "Reference to the user that created the record",
            "$ref" : "#/definitions/User"
          },
          "lastModificationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The record last modification date"
          },
          "lastModifiedBy" : {
            "description" : "Reference to the user that last modified the record",
            "$ref" : "#/definitions/User"
          },
          "customValues" : {
            "type" : "array",
            "description" : "The list of custom field values this record has",
            "items" : {
              "$ref" : "#/definitions/CustomFieldValue"
            }
          },
          "edit" : {
            "type" : "boolean",
            "description" : "Can the authenticated user edit this record?"
          },
          "remove" : {
            "type" : "boolean",
            "description" : "Can the authenticated user remove this record?"
          }
        }
      } ],
      "description" : "Detailed information when viewing a record"
    },
    "RecordManage" : {
      "type" : "object",
      "properties" : {
        "customValues" : {
          "type" : "object",
          "description" : "Holds the custom field values, keyed by field internal name or id. The format of the value depends on the custom field type. Example: `{..., \"customValues\": {\"gender\": \"male\", \"birthDate\": \"1980-10-27\"}}`\n",
          "additionalProperties" : {
            "type" : "string"
          }
        }
      },
      "description" : "Common fields for either creating or editing a record",
      "x-abstract" : true
    },
    "RecordNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordManage"
      }, {
        "type" : "object"
      } ],
      "description" : "Parameters for creating a new record"
    },
    "RecordEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordManage"
      }, {
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version stamp for the current object, used for optimistic locking.\nWhen saving, the same version as previously received needs to be passed\nback. If no one else has saved the object, the version will match and\nthe object will be updated. However, if someone other has saved the\nobject, the version will no longer match, and an error will be raised.\nThis is used to prevent multiple users (or processes) from updating the\nsame object and unwilingly overridding the property values, leading to\ndata loss. \n"
          }
        }
      } ],
      "description" : "Parameters for editing an existing record"
    },
    "RecordBasicData" : {
      "type" : "object",
      "properties" : {
        "kind" : {
          "description" : "The possible kinds of a record, which can either belong to system or to an user Possible values are: * user: The record belongs to a specific user * system: The record belongs to the system, and is unrelated to an user\n",
          "$ref" : "#/definitions/RecordKind"
        },
        "type" : {
          "description" : "The record type",
          "$ref" : "#/definitions/RecordType"
        },
        "fields" : {
          "type" : "array",
          "description" : "The record custom fields (either defined within this record type\nor shared fields linked with this record type)\n",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "edit" : {
          "type" : "boolean",
          "description" : "Can the authenticated user edit records of this type?"
        },
        "remove" : {
          "type" : "boolean",
          "description" : "Can the authenticated user remove records of this type?"
        },
        "user" : {
          "description" : "The record owner user. Only returned if `kind` is\n`user`.\n",
          "$ref" : "#/definitions/User"
        }
      },
      "description" : "Contains data shared by both RecordDataForNew and RecordDataForEdit\n"
    },
    "RecordDataForNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "record" : {
            "description" : "The record populated with the default fields. This value can be modified and sent back to `POST /{owner}/records/{type}`.\n",
            "$ref" : "#/definitions/RecordNew"
          }
        }
      } ],
      "description" : "Contains data for creating a new record\n"
    },
    "RecordDataForEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/RecordBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "editableFields" : {
            "type" : "array",
            "description" : "The internal names of fields that can be edited",
            "items" : {
              "type" : "string"
            }
          },
          "record" : {
            "description" : "The record that is being edited. This value can be modified and sent back to `PUT /records/{id}`\n",
            "$ref" : "#/definitions/RecordEdit"
          }
        }
      } ],
      "description" : "Contains data for editing an existing record\n"
    },
    "OperationResultTypeEnum" : {
      "type" : "string",
      "description" : "The kind of data a custom operation execution is expected to return Possible values are: * notification: Returns a text to be displayed as a simple notification * plainText: Returns a plain text to be displayed in a page, and optionally printed * richText: Returns an HTML formatted text to be displayed in a page, and optionally printed * fileDownload: Returns a file, which can be downloaded * url: The result should be an URL to which the client should be redirected to * externalRedirect: The main execution returns an URL for another service.\n  Then a second execution is expected when this other service redirects the client back to Cyclos\n* resultPage: Returns a page or list of results, which should be displayed in a table like any other search / list\n",
      "enum" : [ "notification", "plainText", "richText", "fileDownload", "url", "externalRedirect", "resultPage" ]
    },
    "OperationScopeEnum" : {
      "type" : "string",
      "description" : "The scope determines where does a custom operation can be executed Possible values are: * system: A general, system custom operation * user: A custom operation over a single user * menu: A custom operation which is visible in a custom menu item * advertisement: A custom operation which is executed over an advertisement * internal: A custom operation which is executed by another custom operation * record: A custom operation which is executed over a record * bulkAction: A custom operation executed over a set of users (one at a time)\n",
      "enum" : [ "system", "user", "menu", "advertisement", "internal", "record", "bulkAction" ]
    },
    "OperationRowActionEnum" : {
      "type" : "string",
      "description" : "The action that should be performed when the user clicks a row in the results table Possible values are: * url: Navigate to an arbitrary URL, which is set in the custom operation itself * location: Navigate to a standard Cyclos location * operation: Run an internal custom operation, which is set on the custom operation itself\n",
      "enum" : [ "url", "location", "operation" ]
    },
    "OperationPageContextEnum" : {
      "type" : "string",
      "description" : "The context an operation with `resultType` is `$enum:OperationResultTypeEnum.resultPage` runs Possible values are: * page: Normal search, returning the data as rows in the result * pdf: Export results as printable PDF * csv: Export results as Comma-Separated-Values (CSV)\n",
      "enum" : [ "page", "pdf", "csv" ]
    },
    "Operation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "scope" : {
            "description" : "The scope determines where does a custom operation can be executed Possible values are: * system: A general, system custom operation * user: A custom operation over a single user * menu: A custom operation which is visible in a custom menu item * advertisement: A custom operation which is executed over an advertisement * internal: A custom operation which is executed by another custom operation * record: A custom operation which is executed over a record * bulkAction: A custom operation executed over a set of users (one at a time)\n",
            "$ref" : "#/definitions/OperationScopeEnum"
          }
        }
      } ],
      "description" : "Contains definitions used to run a custom operation\n"
    },
    "OperationDataForRun" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Operation"
      }, {
        "type" : "object",
        "properties" : {
          "informationText" : {
            "type" : "string",
            "description" : "A message to be displayed to the user when displaying the\nparameters form\n"
          },
          "confirmationText" : {
            "type" : "string",
            "description" : "A message to be shown to the user in order to confirm the\noperation execution\n"
          },
          "customSubmitLabel" : {
            "type" : "string",
            "description" : "A label to be shown on the submit button.\nWhen not returned, a generic 'Submit' should be displayed.\n"
          },
          "formParameters" : {
            "type" : "array",
            "description" : "The custom fields which are used in a form as parameters for the\noperation execution.\n",
            "items" : {
              "$ref" : "#/definitions/CustomFieldDetailed"
            }
          },
          "hasFileUpload" : {
            "type" : "boolean",
            "description" : "Indicates whether this operation accepts a file upload as input\n"
          },
          "confirmationPasswordInput" : {
            "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
            "$ref" : "#/definitions/PasswordInput"
          },
          "resultType" : {
            "description" : "The kind of data a custom operation execution is expected to return Possible values are: * notification: Returns a text to be displayed as a simple notification * plainText: Returns a plain text to be displayed in a page, and optionally printed * richText: Returns an HTML formatted text to be displayed in a page, and optionally printed * fileDownload: Returns a file, which can be downloaded * url: The result should be an URL to which the client should be redirected to * externalRedirect: The main execution returns an URL for another service.\n  Then a second execution is expected when this other service redirects the client back to Cyclos\n* resultPage: Returns a page or list of results, which should be displayed in a table like any other search / list\n",
            "$ref" : "#/definitions/OperationResultTypeEnum"
          },
          "rowAction" : {
            "description" : "The action that should be performed when the user clicks a row in the results table Possible values are: * url: Navigate to an arbitrary URL, which is set in the custom operation itself * location: Navigate to a standard Cyclos location * operation: Run an internal custom operation, which is set on the custom operation itself\n",
            "$ref" : "#/definitions/OperationRowActionEnum"
          },
          "allowExport" : {
            "type" : "boolean",
            "description" : "Does this operation allows exporting the results as CSV? Only returned if `resultType`  is `resultPage`.\n"
          },
          "allowPrint" : {
            "type" : "boolean",
            "description" : "Does this operation allows printing the results as PDF? Only returned if `resultType` is `resultPage`.\n"
          },
          "searchAutomatically" : {
            "type" : "boolean",
            "description" : "Should the operation be immediately executed by the third party client software when first presenting the form to the user  (when `true`) or only when the user clicks submit (when `false`)? Only returned if `resultType` is `resultPage`.\n"
          },
          "rowLocation" : {
            "type" : "string",
            "description" : "The location to which the client should be redirected when selecting a row in the results table. Only returned if `resultType` is `resultPage` and `rowAction` is `location`.\n"
          },
          "rowOperation" : {
            "description" : "The custom operation that should be executed when clicking a row. Only returned if `resultType` is `resultPage` and `rowAction` is `operation`.\n",
            "$ref" : "#/definitions/Operation"
          },
          "rowUrl" : {
            "type" : "string",
            "description" : "The URL the client should be redirected when clicking a row. Only returned if `resultType` is `resultPage` and `rowAction` is `url`.\n"
          }
        }
      } ],
      "description" : "Contains definitions used to run a custom operation\n"
    },
    "RunOperation" : {
      "type" : "object",
      "properties" : {
        "formParameters" : {
          "type" : "object",
          "description" : "Holds the form field values, keyed by field internal name or id. The format of the value depends on the custom field type.\n",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "confirmationPassword" : {
          "type" : "string",
          "description" : "If the custom operation requires confirmation password, the `OperationDataForRun.confirmationPasswordInput` will contain the data for inputting the confirmation password. When such value is present, the password value should be provided in this property.\n"
        },
        "page" : {
          "type" : "integer",
          "description" : "When running a custom operation with `resultType` = `resultPage`, determines the current page offset. Whether this is implemented depends on the script code itself.\n"
        },
        "pageSize" : {
          "type" : "integer",
          "description" : "When running a custom operation with `resultType` = `resultPage`, determines the number of results per page. Whether this is implemented depends on the script code itself.\n"
        },
        "pageContext" : {
          "description" : "Only when running a custom operation with `resultType` = `resultPage`. Possible values are: * page: Normal search, returning the data as rows in the result * pdf: Export results as printable PDF * csv: Export results as Comma-Separated-Values (CSV)\n",
          "$ref" : "#/definitions/OperationPageContextEnum"
        }
      },
      "description" : "Defines parameters used to run a custom operation\n"
    },
    "RunOperationResult" : {
      "type" : "object",
      "properties" : {
        "resultType" : {
          "description" : "The kind of data a custom operation execution is expected to return Possible values are: * notification: Returns a text to be displayed as a simple notification * plainText: Returns a plain text to be displayed in a page, and optionally printed * richText: Returns an HTML formatted text to be displayed in a page, and optionally printed * fileDownload: Returns a file, which can be downloaded * url: The result should be an URL to which the client should be redirected to * externalRedirect: The main execution returns an URL for another service.\n  Then a second execution is expected when this other service redirects the client back to Cyclos\n* resultPage: Returns a page or list of results, which should be displayed in a table like any other search / list\n",
          "$ref" : "#/definitions/OperationResultTypeEnum"
        },
        "title" : {
          "type" : "string",
          "description" : "The text title. May be returned only if `resultType` is either `plainText`, `richText` or `resultPage`.\n"
        },
        "content" : {
          "type" : "string",
          "description" : "The execution result content. Only returned if `resultType` is either `plainText` or  `richText`.\n"
        },
        "notification" : {
          "type" : "string",
          "description" : "The execution result as string that should be shown as a notification. Only returned if `resultType` is `notification`.\n"
        },
        "notificationLevel" : {
          "description" : "Only returned if `resultType` is `notification`. Possible values are: * information: A general informative message * warning: A warning message, when special caution is required * error: An error message, when some operation went wrong  \n",
          "$ref" : "#/definitions/NotificationLevelEnum"
        },
        "url" : {
          "type" : "string",
          "description" : "The execution result as an URL, to which the client should be redirected. Only returned if `resultType` is either `externalRedirect` or `url`.\n"
        },
        "columns" : {
          "type" : "array",
          "description" : "Contains the definitions for each column in the result. Only returned if `resultType` is `resultPage`. \n",
          "items" : {
            "$ref" : "#/definitions/RunOperationResultColumn"
          }
        },
        "rows" : {
          "type" : "array",
          "description" : "Each row is an object containing the cells for that row, keyed by each column's `property`. Only returned if `resultType` is `resultPage`.\n",
          "items" : {
            "$ref" : "#/definitions/RunOperationResultRow"
          }
        }
      },
      "description" : "Defines what is returned when a custom operation is executed. The actual property that are filled depend on the `resultType` property. Not returned when the `resultType` is file. In that case, the response content will be the file content \n"
    },
    "RunOperationResultColumn" : {
      "type" : "object",
      "properties" : {
        "header" : {
          "type" : "string",
          "description" : "The column header text"
        },
        "property" : {
          "type" : "string",
          "description" : "Contains the property name for each row element to access this\ncolumn value.\n"
        },
        "align" : {
          "type" : "string",
          "description" : "The horizontal alignment. The actual values depend on the semantics of\nboth the script result and the client application.\n"
        },
        "valign" : {
          "type" : "string",
          "description" : "The vertical alignment. The actual values depend on the semantics of\nboth the script result and the client application.\n"
        },
        "width" : {
          "type" : "string",
          "description" : "The column width. The actual values depend on the semantics of\nboth the script result and the client application.\n"
        }
      },
      "description" : "A column definition when the result type is `resultPage`.\n"
    },
    "RunOperationResultRow" : {
      "type" : "object",
      "description" : "A row returned when the custom operation resultType is `resultPage`. Even though by a swagger limitation the definition has `additionalProperties` as `string`, the actual type of each cell depend on the script. That means cells could be booleans, numbers or even other objects, beside string. \n",
      "additionalProperties" : {
        "type" : "string"
      },
      "x-parent" : "HashMap<String, Object>"
    },
    "AdKind" : {
      "type" : "string",
      "description" : "The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
      "enum" : [ "simple", "webshop" ]
    },
    "AdStatusEnum" : {
      "type" : "string",
      "description" : "The possible status for an advertisement Possible values are: * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * active: The advertisement is published and can be seen by other users. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users.\n",
      "enum" : [ "draft", "pending", "active", "scheduled", "expired", "hidden", "disabled" ]
    },
    "AdOrderByEnum" : {
      "type" : "string",
      "description" : "Indicates how advertisements results are ordered. Possible values are: * relevance: This is the default if keywords are used. Best matching advertisements come first. * date: Newest advertisements are returned first. * priceAsc: Smaller prices are returned first. Advertisements without price are returned last. * priceDesc: Higher prices are returned first. Advertisements without price are returned last. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Without definite order\n",
      "enum" : [ "relevance", "date", "priceAsc", "priceDesc", "distance", "random" ]
    },
    "AdCategoryWithChildren" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "children" : {
            "type" : "array",
            "description" : "The child categories",
            "items" : {
              "$ref" : "#/definitions/AdCategoryWithChildren"
            }
          }
        }
      } ],
      "description" : "An advertisement category, together with its children"
    },
    "AdCategoryWithParent" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "parent" : {
            "description" : "The parent category",
            "$ref" : "#/definitions/AdCategoryWithParent"
          }
        }
      } ],
      "description" : "An advertisement category, together with its parent"
    },
    "BasicAdDataForSearch" : {
      "type" : "object",
      "properties" : {
        "visibleKinds" : {
          "type" : "array",
          "description" : "The advertisement kinds that can be searched by the authenticated user Possibles values for each array element are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
          "items" : {
            "$ref" : "#/definitions/AdKind"
          }
        },
        "categories" : {
          "type" : "array",
          "description" : "The advertisement categoriesn each with its children, forming a tree\n",
          "items" : {
            "$ref" : "#/definitions/AdCategoryWithChildren"
          }
        },
        "customFields" : {
          "type" : "array",
          "description" : "The list of custom profile fields that are either to be used as search filter (if its internal name is present on either  `fieldsInBasicSearch` or `fieldsInAdvancedSearch`) and / or in the result list (if its internal name is present on `fieldsInList`). \n",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "fieldsInBasicSearch" : {
          "type" : "array",
          "description" : "The internal names of the custom fields that should be used as\nsearch filters in the basic section (separated fields, not keywords)\n",
          "items" : {
            "type" : "string"
          }
        },
        "fieldsInAdvancedSearch" : {
          "type" : "array",
          "description" : "The internal names of the custom fields that should be used as\nsearch filters in the advanced section (separated fields, not keywords)\n",
          "items" : {
            "type" : "string"
          }
        },
        "fieldsInList" : {
          "type" : "array",
          "description" : "The internal names of the custom fields that will be returned\ntogether with each advertisement, and should be shown in the result list.\nThis fature is planned, but not yet available.\n",
          "items" : {
            "type" : "string"
          }
        },
        "basicProfileFields" : {
          "type" : "array",
          "description" : "The list of basic user profile fields that can be used as search filters. Only returned if searching user advertisements.\n",
          "items" : {
            "$ref" : "#/definitions/BasicProfileFieldInput"
          }
        },
        "addressFieldsInSearch" : {
          "type" : "array",
          "description" : "Fields which can be used when filtering by user address, by using the `address.<addressField>` name Possibles values for each array element are: * address: Filters by any field in the street address: `addressLine1`, `addressLine2`, `street`, `buildingNumber` or `complement`   * zip: Filters by zip (postal) code (exact match) * poBox: Filters by post-office box (exact match) * neighborhood: Filters by neighborhood name  * city: Filters by city name * region: Filters by region or state * country: Filters by country, represented as 2-letter, uppercase, ISO 3166-1 code (exact match)\n",
          "items" : {
            "$ref" : "#/definitions/AddressQueryFieldEnum"
          }
        },
        "customProfileFields" : {
          "type" : "array",
          "description" : "The list of custom user profile fields that can be used as search filters. Only returned if searching user advertisements.\n",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "currencies" : {
          "type" : "array",
          "description" : "The currencies the authenticated user may use to filter by price \n",
          "items" : {
            "$ref" : "#/definitions/Currency"
          }
        },
        "searchByDistanceData" : {
          "description" : "Data for searching advertisements by distance",
          "$ref" : "#/definitions/SearchByDistanceData"
        }
      },
      "description" : "Common definitions for searching advertisements"
    },
    "AdDataForSearch" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BasicAdDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "groups" : {
            "type" : "array",
            "description" : "The groups the authenticated user can use to filter users. Admins\ncan always filter by groups, while users depend on a permission,\nwhich can be to only view group sets, only groups or none.\n",
            "items" : {
              "$ref" : "#/definitions/Group"
            }
          },
          "defaultGroups" : {
            "type" : "array",
            "description" : "The internal names (or ids, if missing) of the groups which should\nbe presented by default on user search\n",
            "items" : {
              "type" : "string"
            }
          }
        }
      } ],
      "description" : "Data for a general search of advertisements"
    },
    "UserAdDataForSearch" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BasicAdDataForSearch"
      }, {
        "type" : "object",
        "properties" : {
          "createNew" : {
            "type" : "boolean",
            "description" : "Indicates whether the authenticated user can create new advertisements for this user"
          },
          "maxAds" : {
            "type" : "integer",
            "description" : "The maximum number of advertisements this user can have\n"
          },
          "requiresAuthorization" : {
            "type" : "boolean",
            "description" : "Does advertisements of this user requires authorization to be \npublished for other users to see?\n"
          }
        }
      } ],
      "description" : "Data for a search of advertisements of a specific user"
    },
    "Ad" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
            "$ref" : "#/definitions/AdKind"
          },
          "image" : {
            "description" : "The primary advertisement image",
            "$ref" : "#/definitions/Image"
          }
        }
      } ],
      "description" : "A advertisement is a structured data stored either for an user or for\nsystem (a general advertisement, unrelated to an user).\n"
    },
    "AdDetailed" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Ad"
      }, {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : "string",
            "description" : "The advertisement description content, formatted as HTML\n"
          },
          "owner" : {
            "description" : "The user which owns this advertisement",
            "$ref" : "#/definitions/User"
          },
          "status" : {
            "description" : "The possible status for an advertisement Possible values are: * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * active: The advertisement is published and can be seen by other users. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users.\n",
            "$ref" : "#/definitions/AdStatusEnum"
          },
          "publicationPeriod" : {
            "description" : "The date period this advertisement is published",
            "$ref" : "#/definitions/DatePeriod"
          },
          "price" : {
            "type" : "string",
            "format" : "number",
            "description" : "The regular price"
          }
        }
      } ],
      "description" : "Contains data which is common for `AdResult` and `AdView`\n",
      "x-abstract" : true
    },
    "AdResult" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AdDetailed"
      }, {
        "type" : "object",
        "properties" : {
          "promotionalPrice" : {
            "type" : "string",
            "format" : "number",
            "description" : "The promotional price, only returned if there is a promotional\nprice set and the promotional period is active\n"
          },
          "address" : {
            "description" : "Address to be placed on map. Is only returned when the search result type is `map`.\n",
            "$ref" : "#/definitions/Address"
          },
          "distance" : {
            "type" : "number",
            "format" : "double",
            "description" : "Only returned when there is a base location to calculate the\ndistance from. The unit (kilometers or miles) depends on\nconfiguration.\n"
          },
          "categories" : {
            "type" : "array",
            "description" : "Either internal name or id of categories this ad belongs to.\nIn most cases an advertisement will have a single category,\nbut this depends on the Cyclos configuration.\n",
            "items" : {
              "type" : "string"
            }
          },
          "currency" : {
            "type" : "string",
            "description" : "Either internal name or id of the advertisement's price currency\n"
          },
          "editable" : {
            "type" : "boolean",
            "description" : "Indicates if the ad can be edited according to the logged user's permissions\nand ad status.\n"
          }
        }
      } ],
      "description" : "Contains data returned when searching for advertisements\n"
    },
    "AdView" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AdDetailed"
      }, {
        "type" : "object",
        "properties" : {
          "categories" : {
            "type" : "array",
            "description" : "Either internal name or id of categories this ad belongs to.\nIn most cases an advertisement will have a single category,\nbut this depends on the Cyclos configuration.\n",
            "items" : {
              "$ref" : "#/definitions/AdCategoryWithParent"
            }
          },
          "customValues" : {
            "type" : "array",
            "description" : "The list of custom field values this advertisement has",
            "items" : {
              "$ref" : "#/definitions/CustomFieldValue"
            }
          },
          "currency" : {
            "description" : "The advertisement's price currency",
            "$ref" : "#/definitions/Currency"
          },
          "promotionalPrice" : {
            "type" : "string",
            "format" : "number",
            "description" : "The promotional price, to be applied on the promotional period\nis active\n"
          },
          "promotionalPeriod" : {
            "description" : "The promotional period, the one when `promotionalPrice` is valid\n",
            "$ref" : "#/definitions/DatePeriod"
          },
          "promotionalPeriodActive" : {
            "type" : "boolean",
            "description" : "Indicates whether the promotional period is active at the moment\nthis data is returned\n"
          },
          "canManage" : {
            "type" : "boolean",
            "description" : "Can the authenticated user manage this advertisement?"
          },
          "additionalImages" : {
            "type" : "array",
            "description" : "Holds the images other than the primary image, which is returned in the `image` field\n",
            "items" : {
              "$ref" : "#/definitions/Image"
            }
          },
          "addresses" : {
            "type" : "array",
            "description" : "The addresses where this advertisement is available.\n",
            "items" : {
              "$ref" : "#/definitions/Address"
            }
          }
        }
      } ],
      "description" : "Detailed information when viewing a advertisement"
    },
    "AdManage" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "The advertisement title"
        },
        "description" : {
          "type" : "string",
          "description" : "The advertisement description content, formatted as HTML\n"
        },
        "publicationPeriod" : {
          "description" : "The date period this advertisement is published",
          "$ref" : "#/definitions/DatePeriod"
        },
        "categories" : {
          "type" : "array",
          "description" : "Either internal name or id of categories this ad belongs to.\nIn most cases an advertisement will have a single category,\nbut this depends on the Cyclos configuration.\n",
          "items" : {
            "type" : "string"
          }
        },
        "currency" : {
          "type" : "string",
          "description" : "Either internal name or id of the advertisement's price currency\n"
        },
        "price" : {
          "type" : "string",
          "format" : "number",
          "description" : "The regular price"
        },
        "promotionalPrice" : {
          "type" : "string",
          "format" : "number",
          "description" : "The promotional price, if any"
        },
        "promotionalPeriod" : {
          "description" : "The promotional period, the one when `promotionalPrice` is valid\n",
          "$ref" : "#/definitions/DatePeriod"
        },
        "customValues" : {
          "type" : "object",
          "description" : "Holds the custom field values, keyed by field internal name or id. The format of the value depends on the custom field type. Example: `{..., \"customValues\": {\"gender\": \"male\", \"birthDate\": \"1980-10-27\"}}`\n",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "addresses" : {
          "type" : "array",
          "description" : "Ids of addresses (belogining to the ad owner) this ad is available at.\n",
          "items" : {
            "type" : "string"
          }
        }
      },
      "description" : "Common fields for either creating or editing a advertisement",
      "x-abstract" : true
    },
    "AdNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AdManage"
      }, {
        "type" : "object",
        "properties" : {
          "kind" : {
            "description" : "The advertisement kind to be created. Currently only `simple` advertisements can be managed through this API. The default is `simple`. Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an web-shop. Can be bought, there is stock management, etc.\n",
            "$ref" : "#/definitions/AdKind"
          },
          "submitForAuthorization" : {
            "type" : "boolean",
            "description" : "Only useful when authorization is required (`AdDataForNew`/`AdDataForEdit`.`requiresAuthorization` flag is `true`). Indicates whether the advertisement will be initially submitted for authorization (status = `pending`) or kept in the `draft` status. \n"
          },
          "hidden" : {
            "type" : "boolean",
            "description" : "Only useful when authorization is not required (`AdDataForNew`/`AdDataForEdit`.`requiresAuthorization` flag is `false`). Indicates whether the initial status for the advertisement should be `hidden` (when `true`) or `active` (when `false`). \n"
          },
          "images" : {
            "type" : "array",
            "description" : "The ids of previously uploaded user temporary images to be\ninitially used as advertisement images\n",
            "items" : {
              "type" : "string"
            }
          }
        }
      } ],
      "description" : "Parameters for creating a new advertisement"
    },
    "AdEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AdManage"
      }, {
        "type" : "object",
        "properties" : {
          "version" : {
            "type" : "integer",
            "description" : "The version stamp for the current object, used for optimistic locking.\nWhen saving, the same version as previously received needs to be passed\nback. If no one else has saved the object, the version will match and\nthe object will be updated. However, if someone other has saved the\nobject, the version will no longer match, and an error will be raised.\nThis is used to prevent multiple users (or processes) from updating the\nsame object and unwilingly overridding the property values, leading to\ndata loss. \n"
          }
        }
      } ],
      "description" : "Parameters for editing an existing advertisement"
    },
    "AdBasicData" : {
      "type" : "object",
      "properties" : {
        "customFields" : {
          "type" : "array",
          "description" : "The possible advertisement custom fields\n",
          "items" : {
            "$ref" : "#/definitions/CustomFieldDetailed"
          }
        },
        "requiresAuthorization" : {
          "type" : "boolean",
          "description" : "Indicates whether advertisements require an authorization from the\nadministration in order to be published for other users to see\n"
        },
        "categories" : {
          "type" : "array",
          "description" : "The advertisement categoriesn each with its children, forming a tree\n",
          "items" : {
            "$ref" : "#/definitions/AdCategoryWithChildren"
          }
        },
        "addresses" : {
          "type" : "array",
          "description" : "The addresses of the advertisement owner, so specific ones can be linked to the advertisement.\n",
          "items" : {
            "$ref" : "#/definitions/Address"
          }
        }
      },
      "description" : "Contains data shared by both AdDataForNew and AdDataForEdit\n"
    },
    "AdDataForNew" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AdBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "advertisement" : {
            "description" : "The advertisement that is being created",
            "$ref" : "#/definitions/AdNew"
          }
        }
      } ],
      "description" : "Contains data for creating a new phone\n"
    },
    "AdDataForEdit" : {
      "allOf" : [ {
        "$ref" : "#/definitions/AdBasicData"
      }, {
        "type" : "object",
        "properties" : {
          "advertisement" : {
            "description" : "The advertisement that is being edited",
            "$ref" : "#/definitions/AdEdit"
          }
        }
      } ],
      "description" : "Contains data for editing a new phone\n"
    },
    "TokenStatusEnum" : {
      "type" : "string",
      "description" : "The possible statuses for a token Possible values are: * unassigned: The token is not assigned to an user. * pending: The token has been assigned to an user, but it's still pending for activation. * active: The token is active and can be used. * blocked: The token is blocked from being used. * canceled: The token is canceled and cannot be used. * activationExpired: The token has exceeded the activation deadline. * expired: The token has exceeded the expiration date.\n",
      "enum" : [ "unassigned", "pending", "active", "blocked", "canceled", "activationExpired", "expired" ]
    },
    "PhysicalTokenTypeEnum" : {
      "type" : "string",
      "description" : "The possible physical type for tokens. Determines how applications interact with hardware in order to read the token value. Possible values are: * nfcTag: A NFC tag, normally a DESFire NFC card * nfcDevice: A phone (or other device) with NFC support * barcode: Either a QR-code or a 1d barcode printed on a card * swipe: A swipe card * other: Other\n",
      "enum" : [ "nfcTag", "nfcDevice", "barcode", "swipe", "other" ]
    },
    "TokenType" : {
      "allOf" : [ {
        "$ref" : "#/definitions/InternalNamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "physicalType" : {
            "description" : "The possible physical type for tokens. Determines how applications interact with hardware in order to read the token value. Possible values are: * nfcTag: A NFC tag, normally a DESFire NFC card * nfcDevice: A phone (or other device) with NFC support * barcode: Either a QR-code or a 1d barcode printed on a card * swipe: A swipe card * other: Other\n",
            "$ref" : "#/definitions/PhysicalTokenTypeEnum"
          },
          "mask" : {
            "type" : "string",
            "description" : "In case the token value is entered by users or formatted, this is\nthe (optional) mask to be used.\n"
          }
        }
      } ],
      "description" : "A reference to a token type\n"
    },
    "Token" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NamedEntity"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "description" : "The reference to the NFC token type",
            "$ref" : "#/definitions/TokenType"
          },
          "value" : {
            "type" : "string",
            "description" : "The token value only if not NFC. Othwise the token's label.  \n"
          }
        }
      } ],
      "description" : "Contains reference to a token. Tokens are used to identify users.\n"
    },
    "TokenDetailed" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Token"
      }, {
        "type" : "object",
        "properties" : {
          "status" : {
            "description" : "The possible statuses for a token Possible values are: * unassigned: The token is not assigned to an user. * pending: The token has been assigned to an user, but it's still pending for activation. * active: The token is active and can be used. * blocked: The token is blocked from being used. * canceled: The token is canceled and cannot be used. * activationExpired: The token has exceeded the activation deadline. * expired: The token has exceeded the expiration date.\n",
            "$ref" : "#/definitions/TokenStatusEnum"
          },
          "user" : {
            "description" : "The assigned user. Only if status is not `unassigned`.",
            "$ref" : "#/definitions/User"
          },
          "activationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "When the owner user activated the token.\n"
          },
          "creationDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The creation date."
          },
          "expiryDate" : {
            "type" : "string",
            "format" : "date-time",
            "description" : "The expiration date. Only if the corresponding token type defines an expiration period."
          }
        }
      } ],
      "description" : "Contain all the information of a token.\n"
    },
    "NfcTagKeyEnum" : {
      "type" : "string",
      "description" : "Represent the different keys stored on NFC tags Possible values are: * piccMaster: The PICC master key, used to format the tag * appMaster: The application master key, used by Cyclos to create the application on the tag * operational: A key stored within the application that is used to guarantee the presence of the card in sensitive operations, such as receive payment (POS) or personalize the tag\n",
      "enum" : [ "piccMaster", "appMaster", "operational" ]
    },
    "NfcTokenParameter" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "Either the identifier or internal name of fhe NFC token type"
        },
        "token" : {
          "type" : "string",
          "description" : "The token value. Is normally the internal tag idenfifier, encoded\nas hex  \n"
        }
      },
      "description" : "Definitions for parameters of actions over NFC tokens\n"
    },
    "NfcExternalAuthenticateParameter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NfcTokenParameter"
      }, {
        "type" : "object",
        "properties" : {
          "key" : {
            "description" : "The NFC key over which the authentication is performed. Defaults to `operational`.         Possible values are: * piccMaster: The PICC master key, used to format the tag * appMaster: The application master key, used by Cyclos to create the application on the tag * operational: A key stored within the application that is used to guarantee the presence of the card in sensitive operations, such as receive payment (POS) or personalize the tag\n",
            "$ref" : "#/definitions/NfcTagKeyEnum"
          },
          "tagChallenge" : {
            "type" : "string",
            "description" : "The challenge generated by the NFC tag, encoded as hex"
          }
        }
      } ],
      "description" : "Parameters for an external authentication\n"
    },
    "NfcExternalAuthenticateResult" : {
      "type" : "object",
      "properties" : {
        "cyclosChallenge" : {
          "type" : "string",
          "description" : "The Cyclos-generated challenge encoded as hex. This challenge has\nto be encrypted by the NFC tag\n"
        },
        "sessionKey" : {
          "type" : "string",
          "description" : "The session key to be used on subsequent NFC operations, encoded as hex\n"
        }
      },
      "description" : "Result for a NFC external authenticate\n"
    },
    "NfcDataForInitialize" : {
      "type" : "object",
      "properties" : {
        "initilizeTypes" : {
          "type" : "array",
          "description" : "The NFC token types the authenticated user can initialize tags\n",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        },
        "personalizeTypes" : {
          "type" : "array",
          "description" : "The NFC token types the authenticated user can parsonalize tags\n",
          "items" : {
            "$ref" : "#/definitions/EntityReference"
          }
        }
      },
      "description" : "Contains data NFC tag initialization and personalization\n"
    },
    "NfcInitializeParameter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NfcTokenParameter"
      }, {
        "type" : "object",
        "properties" : {
          "user" : {
            "type" : "string",
            "description" : "An user to whom this tag is being personalized.\n"
          },
          "label" : {
            "type" : "string",
            "description" : "A label to be displayed on the tokens list."
          }
        }
      } ],
      "description" : "Parameters for initializing an NFC tag\n"
    },
    "NfcInitializeResult" : {
      "type" : "object",
      "properties" : {
        "tagKey" : {
          "type" : "string",
          "description" : "The PICC Master Key that should be used to seal the NFC tag,\nencoded as hex.\n"
        },
        "applicationKey" : {
          "type" : "string",
          "description" : "The Application Master Key that should be used on the application\nentry of the NFC tag, encoded as hex.\n"
        },
        "operationalKey" : {
          "type" : "string",
          "description" : "The Application Key used to operate with the tag, encoded as hex.\nUsed when making a payment or to assign an already initialized tag to a user.\n"
        }
      },
      "description" : "Contains the keys that should be stored on the NFC tag\n"
    },
    "NfcDataForPersonalize" : {
      "type" : "object",
      "properties" : {
        "tokenType" : {
          "description" : "The token type reference",
          "$ref" : "#/definitions/EntityReference"
        },
        "confirmationPasswordInput" : {
          "description" : "If a confirmation password is used, contains the definitions on how\nto request that password from the user. This confirmation password\nis required when performing sensible actions. Sometimes this is dynamic,\nfor example, the confirmation might be configured to be used only once\nper session, or operations like payments may have a limit per day to be\nwithout confirmation (pinless).\n",
          "$ref" : "#/definitions/PasswordInput"
        }
      },
      "description" : "Contains data NFC tag personalization\n"
    },
    "NfcPersonalizeParameter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/NfcInitializeParameter"
      }, {
        "type" : "object",
        "properties" : {
          "cyclosChallenge" : {
            "type" : "string",
            "description" : "The challenge that was previously generated by Cyclos, encrypted\nby the NFC tag. Encoded as hex.\n"
          }
        }
      } ],
      "description" : "Parameters for personalizing an NFC tag\n"
    },
    "NfcPersonalizeOtpParameter" : {
      "type" : "object",
      "properties" : {
        "user" : {
          "type" : "string",
          "description" : "An user to whom this tag is being personalized \n"
        },
        "type" : {
          "type" : "string",
          "description" : "Either the identifier or internal name of fhe NFC token type"
        }
      },
      "description" : "Parameters for requesting an OTP (One Time Password) when personalizing\nan NFC tag.\n"
    },
    "BaseNfcError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Error"
      }, {
        "type" : "object",
        "properties" : {
          "token" : {
            "description" : "NFC Token reference.",
            "$ref" : "#/definitions/TokenDetailed"
          }
        }
      } ],
      "description" : "Base Error when work with a NFC card"
    },
    "InitializeNfcErrorCode" : {
      "type" : "string",
      "description" : "Application-specific error codes for an initialize NFC error  Possible values are: * tokenInUse: The token specified for initialization is already in use (exists and it is active) * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
      "enum" : [ "tokenInUse", "unexpected" ]
    },
    "InitializeNfcError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BaseNfcError"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Application-specific error codes for an initialize NFC error  Possible values are: * tokenInUse: The token specified for initialization is already in use (exists and it is active) * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
            "$ref" : "#/definitions/InitializeNfcErrorCode"
          }
        }
      } ],
      "description" : "Error when initialize a NFC card"
    },
    "PersonalizeNfcErrorCode" : {
      "type" : "string",
      "description" : "Application-specific error codes for a personalize NFC error  Possible values are: * tokenInUse: The token specified for personalization is already in use (exists and it is active) * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
      "enum" : [ "tokenInUse", "unexpected" ]
    },
    "PersonalizeNfcError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/BaseNfcError"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Application-specific error codes for a personalize NFC error  Possible values are: * tokenInUse: The token specified for personalization is already in use (exists and it is active) * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
            "$ref" : "#/definitions/PersonalizeNfcErrorCode"
          }
        }
      } ],
      "description" : "Error when personalize a NFC card"
    },
    "NfcAuthErrorCode" : {
      "type" : "string",
      "description" : "Application-specific error codes for an NFC authentication error  Possible values are: * pos: A POS exception has happened when trying to make an external authenticate. See the `posError` field for more details.   * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
      "enum" : [ "pos", "unexpected" ]
    },
    "NfcAuthError" : {
      "allOf" : [ {
        "$ref" : "#/definitions/Error"
      }, {
        "type" : "object",
        "properties" : {
          "code" : {
            "description" : "Application-specific error codes for an NFC authentication error  Possible values are: * pos: A POS exception has happened when trying to make an external authenticate. See the `posError` field for more details.   * unexpected: An unexpected error has occurred. See the `exceptionType` and `exceptionMessage` fields for the internal information.\n",
            "$ref" : "#/definitions/NfcAuthErrorCode"
          },
          "posError" : {
            "description" : "The POS error details. Only if `code` is `pos`          \n",
            "$ref" : "#/definitions/PosError"
          }
        }
      } ],
      "description" : "Error when make a NFC external authentication"
    }
  },
  "parameters" : {
    "page" : {
      "name" : "page",
      "in" : "query",
      "description" : "The page number (zero-based) of the search. The default value is zero.\n",
      "required" : false,
      "type" : "integer"
    },
    "pageSize" : {
      "name" : "pageSize",
      "in" : "query",
      "description" : "The maximum number of records that will be returned on the search.\nThe default value is 40.\n",
      "required" : false,
      "type" : "integer"
    },
    "keywords" : {
      "name" : "keywords",
      "in" : "query",
      "description" : "Textual search keywords. Sometimes, like in user search, the fields\nmatched depends on what is configured on the products.\n",
      "required" : false,
      "type" : "string"
    },
    "fields" : {
      "name" : "fields",
      "in" : "query",
      "description" : "Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`). \n",
      "required" : false,
      "type" : "array",
      "items" : {
        "type" : "string"
      },
      "collectionFormat" : "multi"
    },
    "customFields" : {
      "name" : "customFields",
      "in" : "query",
      "description" : "Custom field values used as search criteria. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, profileFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either bronze or silver, and whose `birthDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customValues=birthDate:|2001-12-31`.      \n",
      "required" : false,
      "type" : "array",
      "items" : {
        "type" : "string"
      },
      "collectionFormat" : "multi"
    },
    "profileFields" : {
      "name" : "profileFields",
      "in" : "query",
      "description" : "User profile fields, both basic (full name, login name, phone, e-mail, \netc) and custom fields, that are used for search. Is a comma-separated\narray, where each part consists in two parts: the internal name (or\ncustom field id) of the field, and a value, both separated by : (colon).\nFor example, `profileFields=field1:value1,field2:value2`. Sometimes\nmultiple values are accepted. In this case, the multiple values are\nseparated by pipes. For example, `profileFields=field1:valueA|valueB`.\nThe accepted fields depend on the products the authenticated user has.\nEnumerated fields accept multiple values, while numeric and date\nfields also accept ranges, which are two values, pipe-separated.\nFor example,\n`profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31`\nwould match results whose custom field with internal name 'rank' is\neither bronze or silver, and whose 'birthDate' is between January 1, 2000\nand December 31, 2001. To specify a single bound in ranges (like birth\ndates before December 31, 2001), use a pipe in one of the values, like\n`customValues=birthDate:|2001-12-31`.\nThe basic profile fields have one of the following identifiers:\n* Full name: name, fullName\n* Login name: username, loginName, login\n* E-mail: email\n* Phone: phone\n* Account number: accountNumber, account\n* Image: image (accepts a boolean value, indicating the presence of images)\n\nIf address is an allowed profile field for search, specific address fields\nmay be searched. The allowed ones are normally returned as the\n`addressFieldsInSearch` field in the corresponding result from a\ndata-for-search request. The specific address fields are:\n* `address`: Searches on any address field (not a specific field);\n* `address.address`: Searches on the fields that represent the street\n  address, which are `addressLine1`, \n  `addressLine2`, `street`,\n  `buildingNumber` and\n  `complement`. Note that normally only a subset\n  of them should be enabled in the configuration (either line 1 / 2 or\n  street + number + complement);\n* `address.zip`: Searches for matching zip (postal) code;\n* `address.poBox`: Searches for matching postal box;\n* `address.neighborhood`: Searches by neighborhood;\n* `address.city`: Searches by city;\n* `address.region`: Searches by region (or state);\n* `address.country`: Searches by ISO 3166-1 alpha-2 country code.\n",
      "required" : false,
      "type" : "array",
      "items" : {
        "type" : "string"
      },
      "collectionFormat" : "multi"
    },
    "user" : {
      "name" : "user",
      "in" : "path",
      "description" : "The user identification.\nThe value 'self' (sans quotes) means the currently authenticated user.\nThe possible idenfitication methods are those whose profile\nfields are allowed in user keywords.\n",
      "required" : true,
      "type" : "string"
    },
    "owner" : {
      "name" : "owner",
      "in" : "path",
      "description" : "Either an user identification, supporting either the value 'self' (sans\nquotes) for the currently authenticated user or an identification method\nfor an user, or the value 'system' (sans quotes) for system data.\n",
      "required" : true,
      "type" : "string"
    },
    "id" : {
      "name" : "id",
      "in" : "path",
      "description" : "The object identification",
      "required" : true,
      "type" : "string"
    },
    "confirmationPassword" : {
      "name" : "confirmationPassword",
      "in" : "header",
      "description" : "The password used to confirm this action, if needed. The actual\npassword type, if any, depends on the Cyclos configuration for the\ncurrent channel.\n",
      "required" : false,
      "type" : "string"
    }
  }
}
